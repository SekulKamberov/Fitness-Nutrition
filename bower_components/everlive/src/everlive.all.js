/*!
 * The MIT License (MIT)
 * 
 * Copyright (c) 2016 Telerik AD
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.y distributed under the MIT license.
 * 
 * Everlive SDK 
 *     Version: 1.8.1
 *     Commit: c9eb4bd0378c4638019c7a873d2e2213ea08cf42
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("http"), (function webpackLoadOptionalExternalModule() { try { return require("application-settings"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("file-system"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("https"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("local-settings"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("nativescript-push-notifications"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("node-localstorage"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("platform"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("url"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("zlib"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define(["http", "application-settings", "file-system", "https", "local-settings", "nativescript-push-notifications", "node-localstorage", "platform", "url", "zlib"], factory);
	else if(typeof exports === 'object')
		exports["Everlive"] = factory(require("http"), (function webpackLoadOptionalExternalModule() { try { return require("application-settings"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("file-system"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("https"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("local-settings"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("nativescript-push-notifications"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("node-localstorage"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("platform"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("url"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("zlib"); } catch(e) {} }()));
	else
		root["Everlive"] = factory(root["http"], root["application-settings"], root["file-system"], root["https"], root["local-settings"], root["nativescript-push-notifications"], root["node-localstorage"], root["platform"], root["url"], root["zlib"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_132__, __WEBPACK_EXTERNAL_MODULE_182__, __WEBPACK_EXTERNAL_MODULE_183__, __WEBPACK_EXTERNAL_MODULE_184__, __WEBPACK_EXTERNAL_MODULE_185__, __WEBPACK_EXTERNAL_MODULE_186__, __WEBPACK_EXTERNAL_MODULE_187__, __WEBPACK_EXTERNAL_MODULE_188__, __WEBPACK_EXTERNAL_MODULE_189__, __WEBPACK_EXTERNAL_MODULE_190__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(144);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.2
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.
	
	(function() {
	
	  // Baseline setup
	  // --------------
	
	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;
	
	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;
	
	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
	
	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;
	
	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;
	
	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};
	
	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };
	
	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }
	
	  // Current version.
	  _.VERSION = '1.8.2';
	
	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };
	
	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };
	
	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };
	
	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };
	
	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var isArrayLike = function(collection) {
	    var length = collection && collection.length;
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };
	
	  // Collection Functions
	  // --------------------
	
	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };
	
	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };
	
	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }
	
	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }
	
	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);
	
	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);
	
	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };
	
	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };
	
	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };
	
	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };
	
	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };
	
	  // Determine if the array or object contains a given value (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
	  };
	
	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };
	
	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };
	
	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };
	
	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };
	
	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };
	
	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };
	
	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };
	
	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };
	
	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };
	
	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });
	
	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });
	
	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });
	
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };
	
	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };
	
	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };
	
	  // Array Functions
	  // ---------------
	
	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };
	
	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };
	
	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };
	
	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };
	
	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };
	
	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };
	
	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };
	
	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };
	
	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (array == null) return [];
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = array.length; i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };
	
	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };
	
	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    if (array == null) return [];
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = array.length; i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };
	
	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };
	
	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };
	
	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, 'length').length || 0;
	    var result = Array(length);
	
	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };
	
	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = list && list.length; i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };
	
	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = function(array, item, isSorted) {
	    var i = 0, length = array && array.length;
	    if (typeof isSorted == 'number') {
	      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
	    } else if (isSorted && length) {
	      i = _.sortedIndex(array, item);
	      return array[i] === item ? i : -1;
	    }
	    if (item !== item) {
	      return _.findIndex(slice.call(array, i), _.isNaN);
	    }
	    for (; i < length; i++) if (array[i] === item) return i;
	    return -1;
	  };
	
	  _.lastIndexOf = function(array, item, from) {
	    var idx = array ? array.length : 0;
	    if (typeof from == 'number') {
	      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
	    }
	    if (item !== item) {
	      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
	    }
	    while (--idx >= 0) if (array[idx] === item) return idx;
	    return -1;
	  };
	
	  // Generator function to create the findIndex and findLastIndex functions
	  function createIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = array != null && array.length;
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }
	
	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createIndexFinder(1);
	
	  _.findLastIndex = createIndexFinder(-1);
	
	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = array.length;
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };
	
	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (arguments.length <= 1) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;
	
	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);
	
	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }
	
	    return range;
	  };
	
	  // Function (ahem) Functions
	  // ------------------
	
	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };
	
	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };
	
	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };
	
	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };
	
	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };
	
	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };
	
	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);
	
	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };
	
	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;
	
	    var later = function() {
	      var last = _.now() - timestamp;
	
	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };
	
	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }
	
	      return result;
	    };
	  };
	
	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };
	
	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };
	
	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };
	
	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };
	
	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };
	
	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);
	
	  // Object Functions
	  // ----------------
	
	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
	
	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
	
	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
	
	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }
	
	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };
	
	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };
	
	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };
	
	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };
	
	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };
	
	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };
	
	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);
	
	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);
	
	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };
	
	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };
	
	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };
	
	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);
	
	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };
	
	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };
	
	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };
	
	
	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }
	
	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;
	
	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
	    
	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }
	
	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);
	
	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };
	
	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };
	
	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };
	
	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };
	
	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };
	
	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };
	
	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });
	
	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }
	
	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }
	
	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };
	
	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };
	
	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };
	
	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };
	
	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };
	
	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };
	
	  // Utility Functions
	  // -----------------
	
	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };
	
	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };
	
	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };
	
	  _.noop = function(){};
	
	  _.property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };
	
	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };
	
	  // Returns a predicate for checking whether an object has a given set of 
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };
	
	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };
	
	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };
	
	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };
	
	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);
	
	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);
	
	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };
	
	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };
	
	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };
	
	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;
	
	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };
	
	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);
	
	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');
	
	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;
	
	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }
	
	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";
	
	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
	
	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';
	
	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }
	
	    var template = function(data) {
	      return render.call(this, data, _);
	    };
	
	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';
	
	    return template;
	  };
	
	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };
	
	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.
	
	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };
	
	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };
	
	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);
	
	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });
	
	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });
	
	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };
	
	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
	  
	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };
	
	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Constants_1 = __webpack_require__(8);
	exports.DataQueryOperation = Constants_1.DataQueryOperation;
	/**
	 * Constants used by the SDK* @typedef {Object} Everlive.Constants
	 */
	var Constants = (function (_super) {
	    __extends(Constants, _super);
	    function Constants() {
	        _super.apply(this, arguments);
	    }
	    Constants.idField = 'Id';
	    Constants.guidEmpty = '00000000-0000-0000-0000-000000000000';
	    Constants.cloudFuncsEndpoint = 'Functions';
	    Constants.sqlProceduresEndpoint = 'Invoke/SqlProcedures';
	    Constants.everliveUrl = '//api.everlive.com/v1/';
	    Constants.DataQueryOperation = Constants_1.DataQueryOperation;
	    /**
	     * A class used to represent the conflict resolution strategies.
	     * @property {string} ClientWins
	     * @property {string} ServerWins
	     * @property {string} Custom
	     * @typedef {string} Everlive.Constants.ConflictResolutionStrategy
	     */
	    Constants.ConflictResolutionStrategy = {
	        ClientWins: 'clientWins',
	        ServerWins: 'serverWins',
	        Custom: 'custom'
	    };
	    Constants.ConflictResolution = {
	        KeepServer: 'keepServer',
	        KeepClient: 'keepClient',
	        Custom: 'custom',
	        Skip: 'skip'
	    };
	    /**
	     * A class used to represent the available storage providers.
	     * @property {string} LocalStorage
	     * @property {string} FileSystem
	     * @property {string} Custom
	     * @typedef {string} Everlive.Constants.StorageProvider
	     */
	    Constants.StorageProvider = {
	        LocalStorage: 'localStorage',
	        FileSystem: 'fileSystem',
	        Custom: 'custom'
	    };
	    Constants.DefaultStoragePath = 'el_store';
	    // the default location for storing files offline
	    Constants.DefaultFilesStoragePath = 'el_file_store';
	    // the default location for storing offline to online location map
	    Constants.DefaultFilesMetadataPath = 'el_file_mapping';
	    Constants.EncryptionProvider = {
	        Default: 'default',
	        Custom: 'custom'
	    };
	    // The headers used by the Everlive services
	    Constants.Headers = {
	        ContentType: 'content-type',
	        filter: 'x-everlive-filter',
	        select: 'x-everlive-fields',
	        sort: 'x-everlive-sort',
	        skip: 'x-everlive-skip',
	        take: 'x-everlive-take',
	        expand: 'x-everlive-expand',
	        singleField: 'x-everlive-single-field',
	        includeCount: 'x-everlive-include-count',
	        powerFields: 'x-everlive-power-fields',
	        debug: 'x-everlive-debug',
	        overrideSystemFields: 'x-everlive-override-system-fields',
	        sdk: 'x-everlive-sdk',
	        sync: 'x-everlive-sync',
	        aggregate: 'x-everlive-aggregate',
	        customParameters: 'x-everlive-custom-parameters'
	    };
	    //Constants for different platforms in Everlive
	    Constants.Platform = {
	        WindowsPhone: 1,
	        Windows: 2,
	        Android: 3,
	        iOS: 4,
	        OSX: 5,
	        Blackberry: 6,
	        Nokia: 7,
	        Unknown: 100
	    };
	    Constants.OperatorType = {
	        query: 1,
	        where: 100,
	        filter: 101,
	        and: 110,
	        or: 111,
	        not: 112,
	        equal: 120,
	        not_equal: 121,
	        lt: 122,
	        lte: 123,
	        gt: 124,
	        gte: 125,
	        isin: 126,
	        notin: 127,
	        all: 128,
	        size: 129,
	        regex: 130,
	        contains: 131,
	        startsWith: 132,
	        endsWith: 133,
	        nearShpere: 140,
	        withinBox: 141,
	        withinPolygon: 142,
	        withinShpere: 143,
	        select: 200,
	        exclude: 201,
	        order: 300,
	        order_desc: 301,
	        skip: 400,
	        take: 401,
	        expand: 402
	    };
	    /**
	     * A class used to represent the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
	     * @property {string} unauthenticated Indicates that no user is authenticated.
	     * @property {string} masterKey Indicates that a master key authentication is used.
	     * @property {string} invalidAuthentication Indicates an authentication has been attempted, but it was invalid.
	     * @property {string} authenticated Indicates that a user is authenticated.
	     * @property {string} authenticating Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
	     * @property {string} expiredAuthentication Indicates that a user's authentication has expired and that the user must log back in.
	     * @typedef {string} Everlive.AuthStatus
	     */
	    Constants.AuthStatus = {
	        unauthenticated: 'unauthenticated',
	        masterKey: 'masterKey',
	        invalidAuthentication: 'invalidAuthentication',
	        authenticated: 'authenticated',
	        expiredAuthentication: 'expiredAuthentication',
	        authenticating: 'authenticating'
	    };
	    Constants.offlineItemStates = {
	        created: 'create',
	        modified: 'update',
	        deleted: 'delete'
	    };
	    /**
	     * HTTP Methods
	     * @typedef {string} constants.HttpMethod
	     * @property {string} GET
	     * @property {string} POST
	     * @property {string} PUT
	     * @property {string} DELETE
	     */
	    Constants.HttpMethod = {
	        GET: 'GET',
	        POST: 'POST',
	        PUT: 'PUT',
	        DELETE: 'DELETE'
	    };
	    Constants.maxDistanceConsts = {
	        radians: '$maxDistance',
	        km: '$maxDistanceInKilometers',
	        miles: '$maxDistanceInMiles'
	    };
	    Constants.radiusConsts = {
	        radians: 'radius',
	        km: 'radiusInKilometers',
	        miles: 'radiusInMiles'
	    };
	    // using an invalid field name in the context of Everlive
	    // to ensure no naming collisions can occur
	    Constants.offlineItemsStateMarker = '__everlive_offline_state';
	    Constants.SyncErrors = {
	        generalError: 'generalError',
	        itemSyncError: 'itemSyncError'
	    };
	    Constants.syncBatchSize = 10;
	    Constants.AuthStoreKey = '__everlive_auth_key';
	    Constants.CachingStoreKey = '__everlive_cache';
	    // the minimum interval between sync requests
	    Constants.defaultSyncInterval = 1000 * 60 * 10; // 10 minutes
	    Constants.fileUploadKey = 'fileUpload';
	    Constants.fileUploadDelimiter = '_';
	    Constants.FilesTypeNameLegacy = 'system.files';
	    Constants.FilesTypeName = 'Files';
	    Constants.MaxConcurrentDownloadTasks = 3;
	    Constants.DefaultFilesystemStorageQuota = 10485760;
	    Constants.Events = {
	        SyncStart: 'syncStart',
	        SyncEnd: 'syncEnd',
	        Processed: 'processed',
	        ItemProcessed: 'itemProcessed',
	        BeforeExecute: 'beforeExecute'
	    };
	    Constants.Aggregation = {
	        MaxDocumentsCount: 100000
	    };
	    Constants.Push = {
	        NotificationsType: 'Push/Notifications',
	        DevicesType: 'Push/Devices'
	    };
	    Constants.EncodableHeaders = [
	        Constants.Headers.filter,
	        Constants.Headers.expand,
	        Constants.Headers.powerFields,
	        Constants.Headers.customParameters
	    ];
	    return Constants;
	}(Constants_1.Constants));
	exports.Constants = Constants;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var errors_1 = __webpack_require__(99);
	var EverliveErrors = (function (_super) {
	    __extends(EverliveErrors, _super);
	    function EverliveErrors() {
	        _super.apply(this, arguments);
	    }
	    EverliveErrors.itemNotFound = {
	        code: 801,
	        message: 'Item not found.'
	    };
	    EverliveErrors.syncConflict = {
	        code: 10001,
	        message: 'A conflict occurred while syncing data.'
	    };
	    EverliveErrors.syncError = {
	        code: 10002,
	        message: 'Synchronization failed for item.'
	    };
	    EverliveErrors.syncInProgress = {
	        code: 10003,
	        message: 'Cannot perform operation while synchronization is in progress.'
	    };
	    EverliveErrors.syncCancelledByUser = {
	        code: 10004,
	        message: 'Synchronization cancelled by user.'
	    };
	    EverliveErrors.syncErrorUnknown = {
	        code: 10005,
	        message: 'An unknown error occurred while synchronizing. Please make sure there is internet connectivity.'
	    };
	    EverliveErrors.operationNotSupportedOffline = {
	        code: 20000 // the error message is created dynamically based on the query filter for offline storage
	    };
	    EverliveErrors.invalidId = {
	        code: 20001,
	        message: 'Invalid or missing Id in model.'
	    };
	    EverliveErrors.bodyWithGetRequestNotSupported = {
	        code: 601,
	        message: 'Sending a request body is not supported for "GET" requests.'
	    };
	    EverliveErrors.invalidOrMissingFunctionName = {
	        code: 601,
	        message: 'Invalid or missing cloud function name.'
	    };
	    EverliveErrors.invalidOrMissingProcedureName = {
	        code: 601,
	        message: 'Invalid or missing procedure name.'
	    };
	    EverliveErrors.generalDatabaseError = {
	        code: 107,
	        message: 'General database error.'
	    };
	    EverliveErrors.invalidToken = {
	        code: 301,
	        message: 'Invalid access token.'
	    };
	    EverliveErrors.expiredToken = {
	        code: 302,
	        message: 'Expired access token.'
	    };
	    EverliveErrors.invalidExpandExpression = {
	        code: 618,
	        message: 'Invalid expand expression.'
	    };
	    EverliveErrors.invalidRequest = {
	        code: 601,
	        message: 'Invalid request.'
	    };
	    EverliveErrors.queryCancelled = {
	        code: 700,
	        message: 'Query cancelled.'
	    };
	    EverliveErrors.missingContentType = {
	        code: 701,
	        message: 'ContentType not specified.'
	    };
	    EverliveErrors.missingOrInvalidFileContent = {
	        code: 702,
	        message: 'Missing or invalid file content.'
	    };
	    EverliveErrors.customFileSyncNotSupported = {
	        code: 703,
	        message: 'Custom ConflictResolution for files is not allowed.'
	    };
	    EverliveErrors.cannotDownloadOffline = {
	        code: 704,
	        message: 'Cannot download a file while offline.'
	    };
	    EverliveErrors.cannotForceCacheWhenDisabled = {
	        code: 705,
	        message: 'Cannot use forceCache while the caching is disabled.'
	    };
	    EverliveErrors.filesNotSupportedInBrowser = {
	        code: 706,
	        message: 'Create and Update operations are not supported for Files in browsers while in offline mode.'
	    };
	    EverliveErrors.pushNotSupportedOffline = {
	        code: 707,
	        message: 'Push is not supported in offline mode.'
	    };
	    EverliveErrors.noOfflineSupport = {
	        code: 708,
	        message: 'You have instantiated the SDK without support for offline storage.'
	    };
	    EverliveErrors.cacheDisabled = {
	        code: 709 // the error message is created dynamically based on the cache operation
	    };
	    EverliveErrors.singleValueExpected = {
	        code: 710
	    };
	    return EverliveErrors;
	}(errors_1.Errors));
	exports.EverliveErrors = EverliveErrors;
	var EverliveErrorHelper = (function () {
	    function EverliveErrorHelper() {
	    }
	    EverliveErrorHelper.buildCacheDisabledErrorMessage = function (cacheOperation) {
	        return 'Cannot use ' + cacheOperation + ' while the caching is disabled.';
	    };
	    EverliveErrorHelper.buildSingleValueExpectedErrorMessage = function (operation) {
	        return 'A single value is expected in ' + operation + ' query modifier.';
	    };
	    return EverliveErrorHelper;
	}());
	exports.EverliveErrorHelper = EverliveErrorHelper;
	var EverliveError = (function (_super) {
	    __extends(EverliveError, _super);
	    function EverliveError(err) {
	        _super.call(this, err.message);
	        this.name = 'EverliveError';
	        this.message = err.message;
	        this.code = err.code;
	        this._err = new Error();
	    }
	    Object.defineProperty(EverliveError.prototype, "stack", {
	        get: function () {
	            return this._err.stack;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    EverliveError.prototype.toJSON = function () {
	        return {
	            name: this.name,
	            message: this.message,
	            code: this.code,
	            stack: this.stack
	        };
	    };
	    return EverliveError;
	}(Error));
	exports.EverliveError = EverliveError;
	(function (DeviceRegistrationErrorType) {
	    DeviceRegistrationErrorType[DeviceRegistrationErrorType["EverliveError"] = 1] = "EverliveError";
	    DeviceRegistrationErrorType[DeviceRegistrationErrorType["PluginError"] = 2] = "PluginError";
	})(exports.DeviceRegistrationErrorType || (exports.DeviceRegistrationErrorType = {}));
	var DeviceRegistrationErrorType = exports.DeviceRegistrationErrorType;
	var DeviceRegistrationError = (function (_super) {
	    __extends(DeviceRegistrationError, _super);
	    function DeviceRegistrationError(errorType, message, additionalInformation) {
	        _super.call(this, { message: message, code: additionalInformation && additionalInformation.code });
	        this.errorType = errorType;
	        this.additionalInformation = additionalInformation;
	    }
	    DeviceRegistrationError.fromEverliveError = function (err) {
	        return new DeviceRegistrationError(DeviceRegistrationErrorType.EverliveError, err.message, err);
	    };
	    DeviceRegistrationError.fromPluginError = function (errorObj) {
	        var message = 'A plugin error occurred';
	        if (errorObj) {
	            if (typeof errorObj.error === 'string') {
	                message = errorObj.error;
	            }
	            else if (typeof errorObj.message === 'string') {
	                message = errorObj.message;
	            }
	        }
	        return new DeviceRegistrationError(DeviceRegistrationErrorType.PluginError, message, errorObj);
	    };
	    return DeviceRegistrationError;
	}(EverliveError));
	exports.DeviceRegistrationError = DeviceRegistrationError;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var path = __webpack_require__(13);
	var platform = __webpack_require__(5);
	var constants_1 = __webpack_require__(2);
	var utils_1 = __webpack_require__(42);
	var unsupportedDbOperators = [
	    '$geoWithin',
	    '$geoIntersects',
	    '$near',
	    '$within',
	    '$nearSphere'
	];
	var DeviceRegistrationResult = (function () {
	    function DeviceRegistrationResult(token) {
	        this.token = token;
	    }
	    return DeviceRegistrationResult;
	}());
	exports.DeviceRegistrationResult = DeviceRegistrationResult;
	var Utils = (function (_super) {
	    __extends(Utils, _super);
	    function Utils() {
	        _super.apply(this, arguments);
	    }
	    Utils.normalizeKeys = function (obj) {
	        var normalizedKeys = {};
	        _.each(obj, function (val, key) {
	            var lowerKey = key.toLowerCase();
	            if (!normalizedKeys.hasOwnProperty(lowerKey)) {
	                normalizedKeys[lowerKey] = val;
	            }
	        });
	        return normalizedKeys;
	    };
	    Utils.buildAuthHeader = function (setup, options) {
	        var authHeaderValue = null;
	        if (options && options.authHeaders === false) {
	            return authHeaderValue;
	        }
	        if (setup.token) {
	            authHeaderValue = (setup.tokenType || 'bearer') + ' ' + setup.token;
	        }
	        else if (setup.masterKey) {
	            authHeaderValue = 'masterkey ' + setup.masterKey;
	        }
	        if (authHeaderValue) {
	            return { authorization: authHeaderValue };
	        }
	        else {
	            return null;
	        }
	    };
	    Utils.buildUrl = function (setup) {
	        var url = '';
	        if (typeof setup.scheme === 'string') {
	            url += setup.scheme + ':';
	        }
	        url += setup.url;
	        if (setup.appId) {
	            url += setup.appId + '/';
	        }
	        return url;
	    };
	    Utils.getDbOperators = function (expression, shallow) {
	        var dbOperators = [];
	        if (typeof expression === 'string' || typeof expression === 'number') {
	            return dbOperators;
	        }
	        var modifierKeys = Object.keys(expression || {});
	        _.each(modifierKeys, function (key) {
	            if (key.indexOf('$') === 0) {
	                dbOperators.push(key);
	            }
	            else if (typeof expression[key] === 'object' && !shallow) {
	                dbOperators = dbOperators.concat(Utils.getDbOperators(expression[key]));
	            }
	        });
	        return dbOperators;
	    };
	    ;
	    Utils.disableRequestCache = function (url, method) {
	        if (method === 'GET') {
	            var timestamp = (new Date()).getTime();
	            var separator = url.indexOf('?') > -1 ? '&' : '?';
	            url += separator + '_el=' + timestamp;
	        }
	        return url;
	    };
	    Utils.getUnsupportedOperators = function (filter) {
	        var dbOperators = Utils.getDbOperators(filter);
	        return _.intersection(dbOperators, unsupportedDbOperators);
	    };
	    Utils.isQuerySupportedOffline = function (query) {
	        var queryParams = query.getQueryParameters();
	        var hasExpandExpression = !_.isEmptyObject(queryParams.expand);
	        var unsupportedOperators = Utils.getUnsupportedOperators(queryParams.filter);
	        var hasUnsupportedOperators = unsupportedOperators.length !== 0;
	        var isUnsupportedInOffline = hasExpandExpression || hasUnsupportedOperators;
	        return !isUnsupportedInOffline;
	    };
	    // http://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript/16245768#16245768
	    Utils.b64toBlob = function (b64Data, contentType, sliceSize) {
	        if (contentType === void 0) { contentType = ''; }
	        if (sliceSize === void 0) { sliceSize = 512; }
	        var byteCharacters = atob(b64Data);
	        var byteArrays = [];
	        for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
	            var slice = byteCharacters.slice(offset, offset + sliceSize);
	            var byteNumbers = new Array(slice.length);
	            for (var i = 0; i < slice.length; i++) {
	                byteNumbers[i] = slice.charCodeAt(i);
	            }
	            var byteArray = new Uint8Array(byteNumbers);
	            byteArrays.push(byteArray);
	        }
	        var blob = new Blob(byteArrays, { type: contentType });
	        return blob;
	    };
	    // http://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
	    Utils.arrayBufferToBase64 = function (buffer) {
	        var binary = '';
	        var bytes = new Uint8Array(buffer);
	        var len = bytes.byteLength;
	        for (var i = 0; i < len; i++) {
	            binary += String.fromCharCode(bytes[i]);
	        }
	        return btoa(binary);
	    };
	    Utils.transformPlatformPath = function (platformPath) {
	        if (!platformPath) {
	            return '';
	        }
	        if (platform.isWindowsPhone) {
	            if (platformPath.charAt(0) === '/' && platformPath.charAt(1) !== '/') {
	                platformPath = '/' + platformPath;
	            }
	        }
	        else {
	            if (platformPath.indexOf('file:/') !== -1 && platformPath.indexOf('file:///') === -1) {
	                platformPath = platformPath.replace('file:/', 'file:///');
	            }
	        }
	        return platformPath;
	    };
	    Utils._stringCompare = function (string, check) {
	        return string.toLowerCase() === check;
	    };
	    Utils.joinPath = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var paths = [].slice.apply(args).map(function (arg) {
	            return arg || '';
	        });
	        var joinedPath = path.join.apply(path, paths);
	        return Utils.transformPlatformPath(joinedPath);
	    };
	    Utils.getId = function (obj) {
	        return obj.Id || obj._id || obj.id;
	    };
	    Utils._inAppBuilderSimulator = function () {
	        return typeof window !== 'undefined' && window.navigator && window.navigator.simulator;
	    };
	    Utils.isValidId = function (input) {
	        var isValidString = typeof input === 'string' && input !== '';
	        var isValidNumber = typeof input === 'number' && !_.isNaN(input);
	        return isValidString || isValidNumber;
	    };
	    Utils.modelHasValidId = function (model) {
	        var idToValidate = (typeof model === 'object' && model !== null) ? model.Id : model;
	        return Utils.isValidId(idToValidate);
	    };
	    Utils.callbackAndPromiseErrorResponse = function (err, errorHandler) {
	        errorHandler = errorHandler || _.noop;
	        errorHandler(err);
	        return Utils.rejectedPromise(err);
	    };
	    Utils.toQueryString = function (obj) {
	        var queryString = '', encode = encodeURIComponent, append = function (k, v) {
	            queryString += encode(k) + '=' + encode(v) + '&';
	        };
	        if (_.isArray(obj)) {
	            for (var i = 0; obj && i < obj.length; i++) {
	                append(obj[i].name, obj[i].value);
	            }
	        }
	        else {
	            for (var propName in obj) {
	                if (!obj.hasOwnProperty(propName)) {
	                    continue;
	                }
	                var value = obj[propName];
	                if (_.isArray(value)) {
	                    for (i = 0; i < value.length; i++) {
	                        append(propName, value[i]);
	                    }
	                }
	                else {
	                    append(propName, obj[propName]);
	                }
	            }
	        }
	        // spaces should be + according to spec
	        return queryString.replace(/&$/, '').replace(/%20/g, '+');
	    };
	    Utils.lazyRequire = function (_dynamic_module_, exportName) {
	        exportName = exportName || _dynamic_module_;
	        var obj = {};
	        Object.defineProperty(obj, exportName, {
	            get: function () {
	                return __webpack_require__(176)(_dynamic_module_);
	            }
	        });
	        return obj;
	    };
	    Utils.promiseHash = function (obj) {
	        return Utils._mapPromises(obj, true).then(function (res) {
	            var resultObj = {};
	            _.each(res, function (settlement, key) {
	                if (settlement.state === 'fulfilled') {
	                    resultObj[key] = settlement.value;
	                }
	            });
	            return Promise.resolve(resultObj);
	        }, function (err) { return Promise.reject(err); });
	    };
	    Utils.promiseHashSettled = function (obj) {
	        return Utils._mapPromises(obj);
	    };
	    Utils.promisesAllSettled = function (promises) {
	        return Utils._mapPromises(promises);
	    };
	    Utils._mapPromises = function (promises, stopOnError) {
	        if (stopOnError === void 0) { stopOnError = false; }
	        var promiseCount = _.size(promises);
	        var resultObj = Array.isArray(promises) ? [] : {};
	        if (promiseCount === 0) {
	            return Promise.resolve(resultObj);
	        }
	        return new Promise(function (resolve, reject) {
	            var aborted = false;
	            var settledCount = 0;
	            var storeResponse = function (response, key, isError) {
	                if (isError === void 0) { isError = false; }
	                if (aborted)
	                    return;
	                var settlement;
	                if (isError) {
	                    settlement = { state: 'rejected', reason: response };
	                }
	                else {
	                    settlement = { state: 'fulfilled', value: response };
	                }
	                resultObj[key] = settlement;
	                settledCount++;
	                if (settledCount === promiseCount) {
	                    resolve(resultObj);
	                }
	            };
	            _.each(promises, function (promise, key) {
	                promise.then(function (res) {
	                    storeResponse(res, key);
	                    return Promise.resolve(res);
	                }, function (err) {
	                    if (stopOnError) {
	                        reject(err);
	                        aborted = true;
	                    }
	                    storeResponse(err, key, true);
	                    return Promise.reject(err);
	                });
	            });
	        });
	    };
	    Utils.isOfflineStorageEnabled = function (setup) {
	        var offlineStorageOptions = setup.offlineStorage || setup.offline;
	        return offlineStorageOptions && offlineStorageOptions.enabled !== false;
	    };
	    Utils.isContentType = {
	        files: function (collectionName) {
	            return Utils._stringCompare(collectionName, 'files');
	        },
	        users: function (collectionName) {
	            return Utils._stringCompare(collectionName, 'users');
	        },
	        pushNotifications: function (collectionName) {
	            return Utils._stringCompare(collectionName, constants_1.Constants.Push.NotificationsType.toLowerCase());
	        },
	        pushDevices: function (collectionName) {
	            return Utils._stringCompare(collectionName, constants_1.Constants.Push.DevicesType.toLowerCase());
	        }
	    };
	    Utils.isElement = {
	        _isElement: function (el, check) {
	            var tag = el;
	            if (typeof tag !== 'string') {
	                if (el instanceof HTMLElement) {
	                    tag = el.tagName;
	                }
	            }
	            return Utils._stringCompare(tag, check);
	        },
	        image: function (el) {
	            return Utils.isElement._isElement(el, 'img');
	        },
	        anchor: function (el) {
	            return Utils.isElement._isElement(el, 'a');
	        }
	    };
	    return Utils;
	}(utils_1.Utils));
	exports.Utils = Utils;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isNativeScript = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
	    || (typeof UIButton !== 'undefined' && UIButton)));
	exports.isNativeScript = isNativeScript;
	var platform;
	exports.platform = platform;
	var isCordova = false;
	exports.isCordova = isCordova;
	var isWindowsPhone = false;
	exports.isWindowsPhone = isWindowsPhone;
	var isAndroid = false;
	exports.isAndroid = isAndroid;
	if (typeof window !== 'undefined' && !isNativeScript) {
	    exports.isCordova = isCordova = /^file:\/{3}[^\/]|x-wmapp/i.test(window.location.href) && /ios|iphone|ipod|ipad|android|iemobile/i.test(navigator.userAgent);
	    exports.isWindowsPhone = isWindowsPhone = isCordova && /iemobile/i.test(navigator.userAgent);
	    exports.isAndroid = isAndroid = isCordova && cordova.platformId === 'android';
	}
	var isNodejs = typeof exports === 'object' && typeof window === 'undefined';
	exports.isNodejs = isNodejs;
	var isRequirejs = "function" === 'function' && __webpack_require__(174);
	exports.isRequirejs = isRequirejs;
	var isDesktop = !isNativeScript && !isCordova && !isNodejs;
	exports.isDesktop = isDesktop;
	if (isNativeScript) {
	    exports.platform = platform = 'ns';
	}
	else if (isNodejs) {
	    exports.platform = platform = 'nodejs';
	}
	else if (isDesktop) {
	    exports.platform = platform = 'desktop';
	}
	else if (isCordova) {
	    exports.platform = platform = 'cordova';
	}
	var isInAppBuilderSimulator = function () {
	    return typeof window !== 'undefined' && window.navigator && window.navigator.simulator;
	};
	exports.isInAppBuilderSimulator = isInAppBuilderSimulator;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Expression_1 = __webpack_require__(18);
	var constants_1 = __webpack_require__(2);
	var WhereQuery_1 = __webpack_require__(68);
	var QueryBuilder_1 = __webpack_require__(22);
	var Query_1 = __webpack_require__(41);
	var OperatorType = constants_1.Constants.OperatorType;
	var Query = (function (_super) {
	    __extends(Query, _super);
	    /**
	     * @class Query
	     * @classdesc A query class used to describe a request that will be made to the {{site.TelerikBackendServices}} JavaScript API.
	     * @param {object} [filter] A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @param {object} [fields] A [fields expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-subset-fields) definition.
	     * @param {object} [sort] A [sort expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-sorting) definition.
	     * @param {number} [skip] Number of items to skip. Used for paging.
	     * @param {number} [take] Number of items to take. Used for paging.
	     * @param {object} [expand] An [expand expression](http://docs.telerik.com/platform/backend-services/rest/data/relations/relations-defining) definition.
	     */
	    function Query(filter, fields, sort, skip, take, expand) {
	        _super.call(this);
	        this.filter = filter;
	        this.fields = fields;
	        this.sort = sort;
	        this.toskip = skip;
	        this.totake = take;
	        this.expandExpression = expand;
	        this.expr = new Expression_1.Expression(OperatorType.query);
	    }
	    /** Applies a filter to the current query. This allows you to retrieve only a subset of the items based on various filtering criteria.
	     * @memberOf Query.prototype
	     * @method where
	     * @name where
	     * @param {object} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @returns {Query}
	     */
	    /** Defines a filter definition for the current query.
	     * @memberOf Query.prototype
	     * @method where
	     * @name where
	     * @returns {WhereQuery}
	     */
	    Query.prototype.where = function (filter) {
	        if (filter) {
	            return this._simple(OperatorType.filter, [filter]);
	        }
	        else {
	            return new WhereQuery_1.WhereQuery(this);
	        }
	    };
	    // TODO
	    //exclude: function () {
	    //    return this._simple(OperatorType.exclude, arguments);
	    //},
	    /** Applies a fields selection to the current query. This allows you to retrieve only a subset of all available item fields.
	     * @memberOf Query.prototype
	     * @method select
	     * @param {object} fieldsExpression A [fields expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-subset-fields) definition.
	     * @returns {Query}
	     */
	    Query.prototype.select = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this._simple(OperatorType.select, args);
	    };
	    /** Sorts the items in the current query in descending order by the specified field.
	     * @memberOf Query.prototype
	     * @method orderDesc
	     * @param {string} field The field name to order by in descending order.
	     * @returns {Query}
	     */
	    Query.prototype.order = function (field) {
	        return this._simple(OperatorType.order, [field]);
	    };
	    /** Skips a certain number of items from the beginning before returning the rest of the items. Used for paging.
	     * @memberOf Query.prototype
	     * @method skip
	     * @see [query.take]{@link query.take}
	     * @param {number} value The number of items to skip.
	     * @returns {Query}
	     */
	    Query.prototype.orderDesc = function (field) {
	        return this._simple(OperatorType.order_desc, [field]);
	    };
	    /** Takes a specified number of items from the query result. Used for paging.
	     * @memberOf Query.prototype
	     * @method take
	     * @see [query.skip]{@link query.skip}
	     * @param {number} value The number of items to take.
	     * @returns {Query}
	     */
	    Query.prototype.skip = function (value) {
	        return this._simple(OperatorType.skip, [value]);
	    };
	    /** Sets an expand expression for the current query. This allows you to retrieve complex data sets using a single query based on relations between data types.
	     * @memberOf Query.prototype
	     * @method expand
	     * @param {object} expandExpression An [expand expression](http://docs.telerik.com/platform/backend-services/rest/data/relations/relations-defining) definition.
	     * @returns {Query}
	     */
	    Query.prototype.take = function (value) {
	        return this._simple(OperatorType.take, [value]);
	    };
	    /** Builds an object containing the different expressions that will be sent to {{site.TelerikBackendServices}}. It basically translates any previously specified expressions into standard queries that {{site.bs}} can understand.
	     * @memberOf Query.prototype
	     * @method build
	     * @returns {{$where,$select,$sort,$skip,$take,$expand}}
	     */
	    Query.prototype.expand = function (expandExpression) {
	        return this._simple(OperatorType.expand, [expandExpression]);
	    };
	    Query.prototype.build = function () {
	        return new QueryBuilder_1.QueryBuilder(this).build();
	    };
	    Query.prototype._simple = function (op, oprs) {
	        var args = [].slice.call(oprs);
	        this.expr.addOperand(new Expression_1.Expression(op, args));
	        return this;
	    };
	    return Query;
	}(Query_1.Query));
	exports.Query = Query;


/***/ },
/* 7 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Constants used by the SDK* @typedef {Object} Everlive.Constants
	 */
	"use strict";
	(function (DataQueryOperation) {
	    DataQueryOperation[DataQueryOperation["Read"] = 0] = "Read";
	    DataQueryOperation[DataQueryOperation["Create"] = 1] = "Create";
	    DataQueryOperation[DataQueryOperation["Update"] = 2] = "Update";
	    DataQueryOperation[DataQueryOperation["Delete"] = 3] = "Delete";
	    DataQueryOperation[DataQueryOperation["DeleteById"] = 4] = "DeleteById";
	    DataQueryOperation[DataQueryOperation["ReadById"] = 5] = "ReadById";
	    DataQueryOperation[DataQueryOperation["Count"] = 6] = "Count";
	    DataQueryOperation[DataQueryOperation["RawUpdate"] = 7] = "RawUpdate";
	    DataQueryOperation[DataQueryOperation["SetAcl"] = 8] = "SetAcl";
	    DataQueryOperation[DataQueryOperation["SetOwner"] = 9] = "SetOwner";
	    DataQueryOperation[DataQueryOperation["UpdateById"] = 10] = "UpdateById";
	    DataQueryOperation[DataQueryOperation["UserLogin"] = 11] = "UserLogin";
	    DataQueryOperation[DataQueryOperation["UserLogout"] = 12] = "UserLogout";
	    DataQueryOperation[DataQueryOperation["UserChangePassword"] = 13] = "UserChangePassword";
	    DataQueryOperation[DataQueryOperation["UserLoginWithProvider"] = 14] = "UserLoginWithProvider";
	    DataQueryOperation[DataQueryOperation["UserLinkWithProvider"] = 15] = "UserLinkWithProvider";
	    DataQueryOperation[DataQueryOperation["UserUnlinkFromProvider"] = 16] = "UserUnlinkFromProvider";
	    DataQueryOperation[DataQueryOperation["UserResetPassword"] = 17] = "UserResetPassword";
	    DataQueryOperation[DataQueryOperation["UserSetPassword"] = 18] = "UserSetPassword";
	    DataQueryOperation[DataQueryOperation["FilesUpdateContent"] = 19] = "FilesUpdateContent";
	    DataQueryOperation[DataQueryOperation["FilesGetDownloadUrlById"] = 20] = "FilesGetDownloadUrlById";
	    DataQueryOperation[DataQueryOperation["Aggregate"] = 21] = "Aggregate";
	    DataQueryOperation[DataQueryOperation["InvokeCloudFunction"] = 22] = "InvokeCloudFunction";
	    DataQueryOperation[DataQueryOperation["InvokeStoredProcedure"] = 23] = "InvokeStoredProcedure";
	})(exports.DataQueryOperation || (exports.DataQueryOperation = {}));
	var DataQueryOperation = exports.DataQueryOperation;
	var Constants = (function () {
	    function Constants() {
	    }
	    return Constants;
	}());
	exports.Constants = Constants;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var utils_1 = __webpack_require__(4);
	var reqwest_everlive_1 = __webpack_require__(23);
	var constants_1 = __webpack_require__(2);
	var platform_1 = __webpack_require__(5);
	var Query_1 = __webpack_require__(6);
	var Headers = constants_1.Constants.Headers;
	var EncodableHeaders = constants_1.Constants.EncodableHeaders;
	var buildAuthHeader = utils_1.Utils.buildAuthHeader;
	var parseUtilities = utils_1.Utils.parseUtilities;
	var guardUnset = utils_1.Utils.guardUnset;
	var Request = (function () {
	    function Request(setup, options) {
	        this.setup = setup;
	        this.options = options;
	        guardUnset(setup, 'setup');
	        guardUnset(options, 'options');
	        this.method = null;
	        this.endpoint = null;
	        this.data = null;
	        this._headers = {};
	        _.extend(this, options);
	        this._init(options);
	    }
	    Request.sendRequest = function (request) {
	        var url = request.buildUrl();
	        url = utils_1.Utils.disableRequestCache(url, request.method);
	        request.method = request.method || constants_1.Constants.HttpMethod.GET;
	        var data = request.method === constants_1.Constants.HttpMethod.GET ? request.data : JSON.stringify(request.data);
	        request.headers['Accept'] = '*/*'; // Reqwest is case sensitive regarding this header
	        var requestParams = {
	            url: url,
	            method: request.method,
	            data: data,
	            headers: request.headers,
	            contentType: 'application/json',
	            crossOrigin: false
	        };
	        if (!platform_1.isNodejs) {
	            requestParams.crossOrigin = true;
	        }
	        return new Promise(function (resolve, reject) {
	            return reqwest_everlive_1.reqwest(requestParams)
	                .then(function (res) {
	                resolve(res);
	            }, function (err) {
	                reject(err);
	            });
	        });
	    };
	    Object.defineProperty(Request.prototype, "headers", {
	        //make sure that the headers are always normalized
	        get: function () {
	            return this._headers;
	        },
	        set: function (val) {
	            // If we let two identical headers with different casing slip into a request
	            // the browser concatenates them which brings chaos to earth
	            this._headers = utils_1.Utils.normalizeKeys(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Calls the underlying Ajax library
	    // If there is a logged in user for the Everlive instance then her/his authentication will be used.
	    Request.buildAuthHeader = function (setup, options) {
	        return buildAuthHeader(setup, options);
	    };
	    Request.prototype.send = function () {
	        return Request.sendRequest(this);
	    };
	    // Builds the URL of the target Everlive service
	    Request.prototype.buildUrl = function () {
	        var url = utils_1.Utils.buildUrl(this.setup) + this.endpoint;
	        if (_.size(this.queryStringParams)) {
	            url = url + '?' + utils_1.Utils.toQueryString(this.queryStringParams);
	        }
	        return url;
	    };
	    // Processes the given query to return appropriate headers to be used by the request
	    Request.buildQueryHeaders = function (query) {
	        if (query) {
	            if (query instanceof Query_1.Query) {
	                return Request._buildQueryHeaders(query);
	            }
	            else {
	                return Request._buildFilterHeader(query.filter);
	            }
	        }
	        else {
	            return {};
	        }
	    };
	    // Initialize the Request object by using the passed options
	    Request.prototype._init = function (options) {
	        _.extend(this.headers, Request.buildAuthHeader(this.setup, options), Request.buildQueryHeaders(options.query));
	        this.encodeHeaders();
	    };
	    // Translates an Everlive.Query to request headers
	    Request._buildQueryHeaders = function (query) {
	        query = query.build();
	        var headers = {};
	        if (query.$where !== null) {
	            headers[Headers.filter] = JSON.stringify(query.$where);
	        }
	        if (query.$select !== null) {
	            headers[Headers.select] = JSON.stringify(query.$select);
	        }
	        if (query.$sort !== null) {
	            headers[Headers.sort] = JSON.stringify(query.$sort);
	        }
	        if (query.$skip !== null) {
	            headers[Headers.skip] = query.$skip;
	        }
	        if (query.$take !== null) {
	            headers[Headers.take] = query.$take;
	        }
	        if (query.$expand !== null) {
	            headers[Headers.expand] = JSON.stringify(query.$expand);
	        }
	        if (query.$aggregate !== null) {
	            headers[Headers.aggregate] = JSON.stringify(query.$aggregate);
	        }
	        return headers;
	    };
	    Request._buildFilterHeader = function (filter) {
	        var headers = {};
	        headers[Headers.filter] = JSON.stringify(filter);
	        return headers;
	    };
	    Request.prototype.encodeHeaders = function () {
	        var headers = this.headers;
	        _.each(EncodableHeaders, function (headerName) {
	            if (headers[headerName] !== undefined) {
	                headers[headerName] = encodeURIComponent(headers[headerName]);
	            }
	        });
	    };
	    Request.reviver = parseUtilities.getReviver();
	    Request.parsers = {
	        simple: {
	            result: parseUtilities.parseResult.bind(null, Request.reviver),
	            error: parseUtilities.parseXhrError.bind(null, Request.reviver)
	        },
	        single: {
	            result: parseUtilities.parseSingleResult.bind(null, Request.reviver),
	            error: parseUtilities.parseXhrError.bind(null, Request.reviver)
	        },
	        update: {
	            result: parseUtilities.parseUpdateResult.bind(null, Request.reviver),
	            error: parseUtilities.parseXhrError.bind(null, Request.reviver)
	        },
	        customRequest: {
	            result: _.identity,
	            error: parseUtilities.parseXhrResponse
	        }
	    };
	    return Request;
	}());
	exports.Request = Request;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Request_1 = __webpack_require__(9);
	var utils_1 = __webpack_require__(4);
	var RequestOptionsBuilder_1 = __webpack_require__(33);
	var EverliveError_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(2);
	var platform_1 = __webpack_require__(5);
	exports.RequestService = {
	    buildRequest: function (query, data) {
	        var getRequestOptionsFromQuery = RequestOptionsBuilder_1.RequestOptionsBuilder[query.operation];
	        var requestOptions = getRequestOptionsFromQuery(query);
	        this.setAdditionalHeaders(query, requestOptions);
	        return new Request_1.Request(data.sdk.setup, requestOptions);
	    },
	    setAdditionalHeaders: function (query, requestOptions) {
	        if (query.isSync) {
	            requestOptions.headers[constants_1.Constants.Headers.sync] = true;
	        }
	        var sdkHeaderValue = {
	            sdk: 'js',
	            platform: platform_1.platform.platform
	        };
	        requestOptions.headers[constants_1.Constants.Headers.sdk] = JSON.stringify(sdkHeaderValue);
	    },
	    /**
	     * Sends a request and if it must applies the result offline.
	     * @param query
	     * @param data
	     * @param [request]
	     * @returns {Promise} Resolves with the response.
	     */
	    handleRequestProcessing: function (query, data, request) {
	        if (request === void 0) { request = this.buildRequest(query, data); }
	        return new Promise(function (resolve, reject) {
	            var successData;
	            request.send()
	                .then(function (res) {
	                successData = res;
	                if (query.applyOffline) {
	                    return data.applyQueryOffline(query, successData);
	                }
	                else {
	                    return successData;
	                }
	            }, function (err) {
	                reject(err);
	            }).then(function () {
	                resolve(successData);
	            }, function (err) {
	                var notSupported = EverliveError_1.EverliveErrors.operationNotSupportedOffline.code;
	                var notFound = EverliveError_1.EverliveErrors.itemNotFound.code;
	                var online = !query.canUseOffline || !query.useCache;
	                if (online && (err.code === notSupported || err.code === notFound)) {
	                    resolve(successData);
	                }
	                else {
	                    reject(err);
	                }
	            });
	        });
	    },
	    /**
	     * Sends a request.
	     * @param request
	     * @returns {Promise} Resolves with the parsed response.
	     */
	    sendRequest: function (request) {
	        return new Promise(function (resolve, reject) {
	            request.send()
	                .then(function (res) {
	                var result = res.Result || res;
	                var reviver = utils_1.Utils.parseUtilities.getReviver();
	                utils_1.Utils.parseUtilities.parseResult(reviver, result);
	                resolve(result);
	            }, function (err) {
	                reject(err);
	            });
	        });
	    }
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 12 */
/***/ function(module, exports) {

	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};
	
	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};
	
	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {
	        function F() {}
	
	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                F.prototype = this;
	                var subtype = new F();
	
	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }
	
	                // Create default initializer
	                if (!subtype.hasOwnProperty('init')) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }
	
	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;
	
	                // Reference supertype
	                subtype.$super = this;
	
	                return subtype;
	            },
	
	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);
	
	                return instance;
	            },
	
	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },
	
	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }
	
	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },
	
	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());
	
	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];
	
	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },
	
	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },
	
	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;
	
	            // Clamp excess bits
	            this.clamp();
	
	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else if (thatWords.length > 0xffff) {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            } else {
	                // Copy all words at once
	                thisWords.push.apply(thisWords, thatWords);
	            }
	            this.sigBytes += thatSigBytes;
	
	            // Chainable
	            return this;
	        },
	
	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;
	
	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },
	
	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);
	
	            return clone;
	        },
	
	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];
	            for (var i = 0; i < nBytes; i += 4) {
	                words.push((Math.random() * 0x100000000) | 0);
	            }
	
	            return new WordArray.init(words, nBytes);
	        }
	    });
	
	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};
	
	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	
	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }
	
	            return hexChars.join('');
	        },
	
	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;
	
	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }
	
	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };
	
	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	
	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }
	
	            return latin1Chars.join('');
	        },
	
	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;
	
	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }
	
	            return new WordArray.init(words, latin1StrLength);
	        }
	    };
	
	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },
	
	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };
	
	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },
	
	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }
	
	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },
	
	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;
	
	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }
	
	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;
	
	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
	
	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }
	
	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }
	
	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },
	
	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();
	
	            return clone;
	        },
	
	        _minBufferSize: 0
	    });
	
	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),
	
	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);
	
	            // Set initial values
	            this.reset();
	        },
	
	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);
	
	            // Perform concrete-hasher logic
	            this._doReset();
	        },
	
	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);
	
	            // Update the hash
	            this._process();
	
	            // Chainable
	            return this;
	        },
	
	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }
	
	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();
	
	            return hash;
	        },
	
	        blockSize: 512/32,
	
	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },
	
	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });
	
	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};
	
	    return C;
	}(Math));
	
	exports.CryptoJS = CryptoJS;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(91);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(26);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	var Readable = __webpack_require__(130);
	var Writable = __webpack_require__(93);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var DataQuery_1 = __webpack_require__(97);
	var Constants_1 = __webpack_require__(8);
	var platform = __webpack_require__(5);
	var Query_1 = __webpack_require__(41);
	var constants_1 = __webpack_require__(2);
	var utils_1 = __webpack_require__(4);
	var Query_2 = __webpack_require__(6);
	var Headers = constants_1.Constants.Headers;
	var DataQuery = (function (_super) {
	    __extends(DataQuery, _super);
	    function DataQuery(config) {
	        _super.call(this, config);
	        this.headers = config.headers || {};
	        this.useOffline = config.useOffline;
	        this.applyOffline = config.applyOffline;
	        this.noRetry = config.noRetry; //retry will be done by default, when a request fails because of expired token, once the authentication.completeAuthentication in sdk is called.
	        this.skipAuth = config.skipAuth; //if set to true, the sdk will not require authorization if the data query fails because of expired token. Used internally for various login methods.
	        this._normalizedHeaders = null;
	        this.isSync = config.isSync;
	        this.preserveState = config.preserveState;
	        this.query = config.query;
	        //TODO: this MUST extend itself with all properties from the config
	        // TODO remove when the offline module is ready
	        var meta = config.meta || config.config.meta || {};
	        if (meta.collectionName) {
	            this.collectionName = meta.collectionName;
	        }
	    }
	    Object.defineProperty(DataQuery.prototype, "canUseOffline", {
	        get: function () {
	            var canUseOffline = null;
	            if (utils_1.Utils.isContentType.files(this.collectionName) && platform.isDesktop) {
	                var op = this.operation;
	                canUseOffline = this.useOffline && (op === Constants_1.DataQueryOperation.Read ||
	                    op === Constants_1.DataQueryOperation.ReadById ||
	                    op === Constants_1.DataQueryOperation.FilesGetDownloadUrlById ||
	                    op === Constants_1.DataQueryOperation.Delete ||
	                    op === Constants_1.DataQueryOperation.DeleteById);
	            }
	            else {
	                canUseOffline = this.useOffline;
	            }
	            return canUseOffline;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DataQuery.prototype._normalizeHeaders = function () {
	        this._normalizedHeaders = utils_1.Utils.normalizeKeys(this.headers);
	    };
	    DataQuery.prototype.getHeader = function (header) {
	        this._normalizeHeaders();
	        var normalizedHeader = header.toLowerCase();
	        return this._normalizedHeaders[normalizedHeader];
	    };
	    DataQuery.prototype.getHeaders = function () {
	        this._normalizeHeaders();
	        var headers = _.deepExtend(this._normalizedHeaders);
	        return headers;
	    };
	    DataQuery.prototype.getHeaderAsJSON = function (header) {
	        this._normalizeHeaders();
	        var headerValue;
	        if (header) {
	            headerValue = this._normalizedHeaders[header.toLowerCase()];
	        }
	        if (_.isObject(headerValue)) {
	            return headerValue;
	        }
	        if (_.isString(headerValue)) {
	            try {
	                return JSON.parse(headerValue);
	            }
	            catch (e) {
	                return headerValue;
	            }
	        }
	        else {
	            return headerValue;
	        }
	    };
	    DataQuery.prototype.getQueryParameters = function () {
	        var queryParams = {};
	        if (this.operation === DataQuery.operations.ReadById) {
	            queryParams.expand = this.getHeaderAsJSON(Headers.expand);
	            queryParams.select = this.getHeaderAsJSON(Headers.select);
	        }
	        else if (!this.additionalOptions || this.additionalOptions.id === undefined) {
	            var sort = this.getHeaderAsJSON(Headers.sort);
	            var limit = this.getHeaderAsJSON(Headers.take);
	            var skip = this.getHeaderAsJSON(Headers.skip);
	            var select = this.getHeaderAsJSON(Headers.select);
	            var filter = this.getHeaderAsJSON(Headers.filter);
	            var expand = this.getHeaderAsJSON(Headers.expand);
	            var aggregate = this.getHeaderAsJSON(Headers.aggregate);
	            if (this.query instanceof Query_1.Query) {
	                var filterObj = this.query.build();
	                queryParams.filter = filterObj.$where || filter || {};
	                queryParams.sort = filterObj.$sort || sort;
	                queryParams.limit = filterObj.$take || limit;
	                queryParams.skip = filterObj.$skip || skip;
	                queryParams.select = filterObj.$select || select;
	                queryParams.expand = filterObj.$expand || expand;
	                queryParams.aggregate = filterObj.$aggregate || aggregate;
	            }
	            else {
	                // TODO left for backward compatibility, should be removed later
	                queryParams.filter = (this.filter || filter) || this.config.filter || {};
	                queryParams.sort = sort;
	                queryParams.limit = limit;
	                queryParams.skip = skip;
	                queryParams.select = select;
	                queryParams.expand = expand;
	                queryParams.aggregate = aggregate;
	            }
	        }
	        return queryParams;
	    };
	    DataQuery.prototype.applyEventQuery = function (eventQuery) {
	        this._applyCustomHeaders(eventQuery);
	        this._applyEventQueryHeaders(eventQuery);
	        this._applyEventQueryParams(eventQuery);
	        this.additionalOptions = this.additionalOptions || {};
	        this.additionalOptions.id = eventQuery.itemId;
	        this.data = eventQuery.data;
	        this._applyEventQuerySettings(eventQuery);
	    };
	    DataQuery.prototype._applyCustomHeaders = function (eventQuery) {
	        this.headers = eventQuery.headers;
	        this._normalizeHeaders();
	    };
	    DataQuery.prototype._applyEventQueryHeaders = function (eventQuery) {
	        this._applyEventHeader(Headers.filter, eventQuery.filter);
	        this._applyEventHeader(Headers.select, eventQuery.fields);
	        this._applyEventHeader(Headers.sort, eventQuery.sort);
	        this._applyEventHeader(Headers.skip, eventQuery.skip);
	        this._applyEventHeader(Headers.take, eventQuery.take);
	        this._applyEventHeader(Headers.expand, eventQuery.expand);
	        this._applyEventHeader(Headers.aggregate, eventQuery.aggregate);
	        this._applyEventHeader(Headers.powerFields, eventQuery.powerfields);
	    };
	    DataQuery.prototype._applyEventQueryParams = function (eventQuery) {
	        if (eventQuery.filter) {
	            this.query = this.query || new Query_2.Query();
	            this.query.filter = eventQuery.filter;
	        }
	        if (eventQuery.aggregate) {
	            this.query = this.query || new Query_2.Query();
	            this.query.aggregateExpression = eventQuery.aggregate;
	        }
	        this.fields = eventQuery.select;
	        this.sort = eventQuery.sort;
	        this.skip = eventQuery.skip;
	        this.take = eventQuery.take;
	        this.expand = eventQuery.expand;
	    };
	    DataQuery.prototype._applyEventQuerySettings = function (eventQuery) {
	        this.useOffline = eventQuery.settings.useOffline;
	        this.forceCache = eventQuery.settings.forceCache;
	        this.ignoreCache = eventQuery.settings.ignoreCache;
	        this.applyOffline = eventQuery.settings.applyOffline;
	    };
	    DataQuery.prototype._applyEventHeader = function (header, value) {
	        if (value && typeof value !== 'string') {
	            var headerToLower = header.toLowerCase();
	            this.headers[headerToLower] = JSON.stringify(value);
	        }
	    };
	    DataQuery.operations = Constants_1.DataQueryOperation;
	    return DataQuery;
	}(DataQuery_1.DataQuery));
	exports.DataQuery = DataQuery;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var utils_1 = __webpack_require__(4);
	var constants_1 = __webpack_require__(2);
	var DataQuery_1 = __webpack_require__(15);
	var EverliveError_1 = __webpack_require__(3);
	var Data_1 = __webpack_require__(134);
	/**
	 * @class Data
	 * @classdesc A class that provides methods for all CRUD operations to a given {{site.bs}} data type. Covers advanced scenarios with custom headers and special server-side functionality.
	 * @param {object} collectionName
	 * @param {object} sdk
	 * @protected
	 */
	var Data = (function (_super) {
	    __extends(Data, _super);
	    function Data(sdk, collectionName) {
	        _super.call(this, sdk, collectionName);
	        this.collectionName = collectionName;
	        this.setup = this.sdk.setup;
	        this.options = null;
	    }
	    Object.defineProperty(Data.prototype, "offlineStorage", {
	        get: function () {
	            return this.sdk.offlineStorage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Data.prototype._isOnline = function () {
	        return this.offlineStorage ? this.offlineStorage.isOnline() : true;
	    };
	    Data.prototype._getOfflineCreateData = function (query, requestResponse) {
	        var createData;
	        if (_.isArray(query.data)) {
	            createData = [];
	            for (var i = 0; i < query.data.length; i++) {
	                var objectToCreate = _.extend(query.data[i], requestResponse.Result[i]);
	                createData.push(objectToCreate);
	            }
	        }
	        else {
	            createData = _.extend(query.data, requestResponse.Result);
	        }
	        return createData;
	    };
	    Data.prototype._destroy = function (attrs, filterOrQuery, single, success, error) {
	        var op = single ? constants_1.DataQueryOperation.DeleteById : constants_1.DataQueryOperation.Delete;
	        var idField = (attrs && typeof attrs === 'object') ? attrs[constants_1.Constants.idField] : attrs;
	        var dataQuery = this.buildDataQuery({
	            additionalOptions: {
	                id: single ? idField : undefined
	            },
	            query: filterOrQuery
	        }, op);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    Data.prototype._setOption = function (key, value) {
	        this.options = this.options || {};
	        if (_.isObject(value)) {
	            this.options[key] = _.extend({}, this.options[key], value);
	        }
	        else {
	            this.options[key] = value;
	        }
	        return this;
	    };
	    // TODO: Check if there is a case in which replace = true is passed to this function
	    Data.prototype._update = function (attrs, filterOrQuery, single, replace, success, error) {
	        var dataQuery = this.buildDataQuery({
	            updateObject: (_a = {},
	                _a[replace ? '$replace' : '$set'] = attrs,
	                _a
	            ),
	            additionalOptions: {
	                id: single ? attrs[constants_1.Constants.idField] : undefined
	            },
	            query: filterOrQuery
	        }, constants_1.DataQueryOperation.Update);
	        return this.processDataQuery(dataQuery, success, error);
	        var _a;
	    };
	    Data.prototype._invalidIdErrorResponse = function (errorHandler) {
	        var err = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.invalidId);
	        return utils_1.Utils.callbackAndPromiseErrorResponse(err, errorHandler);
	    };
	    Data.prototype.applyQueryOffline = function (query, requestResponse) {
	        var autoSyncEnabled = this.offlineStorage && this.offlineStorage.options.autoSync;
	        if (autoSyncEnabled) {
	            switch (query.operation) {
	                case constants_1.DataQueryOperation.Read:
	                case constants_1.DataQueryOperation.ReadById:
	                case constants_1.DataQueryOperation.FilesGetDownloadUrlById:
	                    var syncReadQuery = new DataQuery_1.DataQuery(_.defaults({
	                        data: requestResponse.Result,
	                        isSync: true,
	                        operation: constants_1.DataQueryOperation.Create
	                    }, query));
	                    return this.offlineStorage.processQuery(syncReadQuery);
	                case constants_1.DataQueryOperation.Create:
	                    var createData = this._getOfflineCreateData(query, requestResponse);
	                    var createQuery = new DataQuery_1.DataQuery(_.defaults({
	                        data: createData,
	                        isSync: true
	                    }, query));
	                    return this.offlineStorage.processQuery(createQuery);
	                case constants_1.DataQueryOperation.Update:
	                case constants_1.DataQueryOperation.RawUpdate:
	                    query.isSync = true;
	                    query.ModifiedAt = requestResponse.ModifiedAt;
	                    return this.offlineStorage.processQuery(query);
	                default:
	                    query.isSync = true;
	                    return this.offlineStorage.processQuery(query);
	            }
	        }
	        return new Promise(function (resolve) {
	            resolve();
	        });
	    };
	    /**
	     * Modifies whether the query should be invoked on the offline storage.
	     * @memberOf Data.prototype
	     * @method useOffline
	     * @name useOffline
	     * @param {boolean} useOffline
	     * @returns {Data} Returns the same instance of the Data object.
	     */
	    Data.prototype.useOffline = function (useOffline) {
	        if (arguments.length !== 1) {
	            var message = EverliveError_1.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('useOffline()');
	            throw new EverliveError_1.EverliveError({ message: message, code: EverliveError_1.EverliveErrors.singleValueExpected.code });
	        }
	        var isOfflineEnabled = this.sdk._isOfflineStorageEnabled();
	        if (useOffline === true && !isOfflineEnabled) {
	            throw new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.noOfflineSupport);
	        }
	        return this._setOption('useOffline', useOffline);
	    };
	    /**
	     * Does not use the cache when retrieving the data.
	     * Only valid when caching is enabled.
	     * @memberOf Data.prototype
	     * @method ignoreCache
	     * @name ignoreCache
	     * @returns {Data}
	     * */
	    Data.prototype.ignoreCache = function () {
	        return this._setOption('ignoreCache', true);
	    };
	    /**
	     * Forces the request to get the data from the cache even if the data is already expired.
	     * Only valid when caching is enabled.
	     * @memberOf Data.prototype
	     * @method forceCache
	     * @name forceCache
	     * @returns {Data}
	     * */
	    Data.prototype.forceCache = function () {
	        return this._setOption('forceCache', true);
	    };
	    /**
	     * Sets cache expiration specifically for the current query.
	     * Only valid when caching is enabled.
	     * @memberOf Data.prototype
	     * @method maxAge
	     * @name maxAge
	     * @param maxAgeInMinutes {Number}
	     * @returns {Data}
	     * */
	    Data.prototype.maxAge = function (maxAgeInMinutes) {
	        var maxAge = maxAgeInMinutes * 1000 * 60;
	        return this._setOption('maxAge', maxAge);
	    };
	    Data.prototype.isSync = function (isSync) {
	        if (arguments.length !== 1) {
	            var message = EverliveError_1.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('isSync()');
	            throw new EverliveError_1.EverliveError({ message: message, code: EverliveError_1.EverliveErrors.singleValueExpected.code });
	        }
	        return this._setOption('isSync', isSync);
	    };
	    /**
	     * Modifies whether the query should try to authenticate if the security token has expired.
	     * Default is false.
	     * Only valid when the authentication module has an onAuthenticationRequired function.
	     * @memberOf Data.prototype
	     * @method skipAuth
	     * @param skipAuth {Boolean}
	     * @returns {Data}
	     * */
	    Data.prototype.skipAuth = function (skipAuth) {
	        if (arguments.length !== 1) {
	            var message = EverliveError_1.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('skipAuth()');
	            throw new EverliveError_1.EverliveError({ message: message, code: EverliveError_1.EverliveErrors.singleValueExpected.code });
	        }
	        return this._setOption('skipAuth', skipAuth);
	    };
	    /**
	     * Modifies whether the query should be applied offline, if the sdk is currently working online.
	     * Default is true.
	     * Only valid when offlineStorage is enabled.
	     * @memberOf Data.prototype
	     * @method applyOffline
	     * @param applyOffline {Boolean} Whether the operation should be applied offline or not
	     * @returns {Data}
	     * */
	    Data.prototype.applyOffline = function (applyOffline) {
	        if (arguments.length !== 1) {
	            var message = EverliveError_1.EverliveErrorHelper.buildSingleValueExpectedErrorMessage('applyOffline()');
	            throw new EverliveError_1.EverliveError({ message: message, code: EverliveError_1.EverliveErrors.singleValueExpected.code });
	        }
	        return this._setOption('applyOffline', applyOffline);
	    };
	    /**
	     * Sets additional non-standard HTTP headers in the current data request. See [List of Request Parameters](http://docs.telerik.com/platform/backend-services/rest/apireference/RESTfulAPI/custom_headers) for more information.
	     * @memberOf Data.prototype
	     * @method withHeaders
	     * @param {object} headers Additional headers to be sent with the data request.
	     * @returns {Data}
	     */
	    Data.prototype.withHeaders = function (headers) {
	        return this._setOption('headers', headers);
	    };
	    /**
	     * Sets an expand expression to be used in the data request. This allows you to retrieve complex data sets using a single query based on relations between data types.
	     * @memberOf Data.prototype
	     * @method expand
	     * @param {object} expandExpression An [expand expression](http://docs.telerik.com/platform/backend-services/rest/data/relations/relations-defining) definition.
	     * @returns {Data}
	     */
	    Data.prototype.expand = function (expandExpression) {
	        var expandHeader = {
	            'X-Everlive-Expand': JSON.stringify(expandExpression)
	        };
	        return this.withHeaders(expandHeader);
	    };
	    Data.prototype.buildDataQuery = function (data, op) {
	        return _super.prototype.buildDataQuery.call(this, data, op, {
	            collectionName: this.collectionName
	        });
	    };
	    // TODO implement options: { requestSettings: { executeServerCode: false } }. power fields queries could be added to that options argument
	    /**
	     * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
	     * @memberOf Data.prototype
	     * @method get
	     * @name get
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
	     * @memberOf Data.prototype
	     * @method get
	     * @name get
	     * @param {object|null} query A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.get = function (query, success, error) {
	        var dataQuery = this.buildDataQuery(query, constants_1.DataQueryOperation.Read);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    // TODO handle options
	    // TODO think to pass the id as a filter
	    /**
	     * Gets a data item by ID.
	     * @memberOf Data.prototype
	     * @method getById
	     * @name getById
	     * @param {string} id ID of the item.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Gets an item by ID.
	     * @memberOf Data.prototype
	     * @method getById
	     * @name getById
	     * @param {string} id ID of the item.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     * */
	    Data.prototype.getById = function (id, success, error) {
	        if (!utils_1.Utils.modelHasValidId(id)) {
	            return this._invalidIdErrorResponse(error);
	        }
	        var dataQuery = this.buildDataQuery({
	            additionalOptions: { id: id }
	        }, constants_1.DataQueryOperation.ReadById);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     *  A fluent API aggregation / grouping data from server. Can accept aggregationExpression or fluent chaining rules.
	     * @memberOf Data.prototype
	     * @method aggregate
	     * @name aggregate
	     * @param {object} aggregateQuery fields / Aggregation functions [aggregationExpression].
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     *  A fluent API aggregation / grouping data from server. Can accept aggregationExpression or fluent chaining rules.
	     * @memberOf Data.prototype
	     * @method aggregate
	     * @name aggregate
	     * @param {object} aggregateQuery fields / Aggregation functions [aggregationExpression].
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     * */
	    Data.prototype.aggregate = function (aggregateQuery, success, error) {
	        var dataQuery = this.buildDataQuery(aggregateQuery, constants_1.DataQueryOperation.Aggregate);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     * Gets the count of the data items that match the filter.
	     * @memberOf Data.prototype
	     * @method count
	     * @name count
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Gets the count of the items that match the filter.
	     * @memberOf Data.prototype
	     * @method count
	     * @name count
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.count = function (filter, success, error) {
	        var dataQuery = this.buildDataQuery(filter, constants_1.DataQueryOperation.Count);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     * Creates a data item.
	     * @memberOf Data.prototype
	     * @method create
	     * @name create
	     * @param {object|object[]} data Item or items that will be created.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Creates an item.
	     * @memberOf Data.prototype
	     * @method create
	     * @name create
	     * @param {object|object[]} data The item or items that will be created.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.create = function (data, success, error) {
	        var dataQuery = this.buildDataQuery(data, constants_1.DataQueryOperation.Create);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     * Updates all objects that match a filter with the specified update expression.
	     * @memberOf Data.prototype
	     * @method rawUpdate
	     * @name rawUpdate
	     * @param {object} updateObject Update object that contains the new values.
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Updates all objects that match a filter with the specified update expression.
	     * @memberOf Data.prototype
	     * @method rawUpdate
	     * @name rawUpdate
	     * @param {object} updateObject Update object that contains the new values.
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    /**
	     * Updates an object by ID with the specified update expression.
	     * @memberOf Data.prototype
	     * @method rawUpdate
	     * @name rawUpdate
	     * @param {object} updateObject Updated object that contains the new values.
	     * @param {string} filterOrId The ID of the item.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Updates an object by ID with the specified update expression.
	     * @memberOf Data.prototype
	     * @method rawUpdate
	     * @name rawUpdate
	     * @param {object} updateObject Updated object that contains the new values.
	     * @param {string} filterOrId The ID of the item.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.rawUpdate = function (updateObject, filterOrId, success, error) {
	        var self = this;
	        var isSingleUpdate = typeof filterOrId === 'string' || typeof filterOrId === 'number';
	        if (isSingleUpdate && !utils_1.Utils.modelHasValidId(filterOrId)) {
	            return self._invalidIdErrorResponse(error);
	        }
	        var query = isSingleUpdate ? filterOrId : this.sdk.dataQueryBuilder._buildQuery(filterOrId);
	        var additionalOptions = {
	            id: isSingleUpdate ? filterOrId : undefined
	        };
	        var dataQuery = this.buildDataQuery({
	            query: query,
	            additionalOptions: additionalOptions,
	            updateObject: updateObject
	        }, constants_1.DataQueryOperation.RawUpdate);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     * Updates a single data item. This operation takes an object that specifies both the data item to be updated and the updated values.
	     * @memberOf Data.prototype
	     * @method updateSingle
	     * @name updateSingle
	     * @param item {object} The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Updates the provided item.
	     * @memberOf Data.prototype
	     * @method updateSingle
	     * @name updateSingle
	     * @param item {object} The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.updateSingle = function (item, success, error) {
	        if (!utils_1.Utils.modelHasValidId(item)) {
	            return this._invalidIdErrorResponse(error);
	        }
	        return this._update(item, null, true, false, success, error);
	    };
	    /**
	     * Updates all items that match a filter with the specified update object.
	     * @memberOf Data.prototype
	     * @method update
	     * @name update
	     * @param {object} updateObject The update object.
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Updates all items that match the filter with the specified update object.
	     * @memberOf Data.prototype
	     * @method update
	     * @name update
	     * @param {object} updateObject The update object.
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.update = function (updateObject, filter, success, error) {
	        return this._update(updateObject, filter, false, false, success, error);
	    };
	    /**
	     * Deletes a single data item by ID.
	     * @memberOf Data.prototype
	     * @method destroySingle
	     * @name destroySingle
	     * @param {string} itemId The ID of the item to delete.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Deletes a single data item by ID.
	     * @memberOf Data.prototype
	     * @method destroySingle
	     * @name destroySingle
	     * @param {string} itemId The ID of the item to delete.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    /**
	     * Deletes a single data item by ID.
	     * @memberOf Data.prototype
	     * @method destroySingle
	     * @name destroySingle
	     * @param {object} item Object containing the item ID to be deleted.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Deletes a single data item by ID.
	     * @memberOf Data.prototype
	     * @method destroySingle
	     * @name destroySingle
	     * @param {object} model Object containing the item ID to be deleted.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.destroySingle = function (model, success, error) {
	        if (!utils_1.Utils.modelHasValidId(model)) {
	            return this._invalidIdErrorResponse(error);
	        }
	        return this._destroy(model, null, true, success, error);
	    };
	    /**
	     * Deletes all data items that match a filter.
	     * @memberOf Data.prototype
	     * @method destroy
	     * @name destroy
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Deletes all items that match the filter.
	     * @memberOf Data.prototype
	     * @method destroy
	     * @name destroy
	     * @param {object|null} filter A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.destroy = function (filter, success, error) {
	        return this._destroy(null, filter, false, success, error);
	    };
	    Data.prototype.setAcl = function (acl, filter, success, error) {
	        if (!utils_1.Utils.modelHasValidId(filter)) {
	            return this._invalidIdErrorResponse(error);
	        }
	        var additionalOptions = { acl: acl };
	        var data = { additionalOptions: additionalOptions };
	        additionalOptions.id = filter[constants_1.Constants.idField] || filter;
	        var dataQuery = this.buildDataQuery(data, constants_1.DataQueryOperation.SetAcl);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    Data.prototype.setOwner = function (ownerId, filter, success, error) {
	        if (!utils_1.Utils.modelHasValidId(filter)) {
	            return this._invalidIdErrorResponse(error);
	        }
	        var data = {
	            updateObject: { Owner: ownerId },
	            additionalOptions: {}
	        };
	        data.additionalOptions.id = filter[constants_1.Constants.idField] || filter;
	        var dataQuery = this.buildDataQuery(data, constants_1.DataQueryOperation.SetOwner);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
	     * @memberOf Data.prototype
	     * @method save
	     * @name save
	     * @param {object} item An object containing the item that is being saved.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
	     * @memberOf Data.prototype
	     * @method save
	     * @name save
	     * @param {object} model An object containing the item that is being saved.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Data.prototype.save = function (model, success, error) {
	        var _this = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            var isNew = _this.isNew(model);
	            var promise;
	            if (isNew) {
	                promise = _this.create(model);
	            }
	            else {
	                promise = _this.updateSingle(model);
	            }
	            var type = isNew ? 'create' : 'update';
	            promise
	                .then(function (res) {
	                res.type = type;
	                success(res);
	            })
	                .catch(function (err) {
	                err.type = type;
	                error(err);
	            });
	        }, success, error);
	    };
	    /**
	     * Checks if the specified data item is new or not.
	     * @memberOf Data.prototype
	     * @method isNew
	     * @param model Item to check.
	     * @returns {boolean}
	     */
	    Data.prototype.isNew = function (model) {
	        return typeof model[constants_1.Constants.idField] === 'undefined';
	    };
	    return Data;
	}(Data_1.default));
	exports.Data = Data;


/***/ },
/* 17 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];
	
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";
	var Expression = (function () {
	    function Expression(operator, operands) {
	        if (operands === void 0) { operands = []; }
	        this.operator = operator;
	        this.operands = operands;
	    }
	    Expression.prototype.addOperand = function (operand) {
	        this.operands.push(operand);
	    };
	    return Expression;
	}());
	exports.Expression = Expression;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var BasePersister_1 = __webpack_require__(20);
	exports.BasePersister = BasePersister_1.BasePersister;
	var LocalStoragePersister_1 = __webpack_require__(65);
	exports.LocalStoragePersister = LocalStoragePersister_1.LocalStoragePersister;
	var FileSystemPersister_1 = __webpack_require__(64);
	exports.FileSystemPersister = FileSystemPersister_1.FileSystemPersister;
	var constants_1 = __webpack_require__(2);
	var EverliveError_1 = __webpack_require__(3);
	function getPersister(storageKey, options) {
	    var persister;
	    var storageProvider = options.storage.provider;
	    var storageProviderImplementation = options.storage.implementation;
	    if (_.isObject(storageProviderImplementation) && storageProvider === constants_1.Constants.StorageProvider.Custom) {
	        persister = storageProviderImplementation;
	    }
	    else {
	        switch (storageProvider) {
	            case constants_1.Constants.StorageProvider.LocalStorage:
	                persister = new LocalStoragePersister_1.LocalStoragePersister(storageKey, options);
	                break;
	            case constants_1.Constants.StorageProvider.FileSystem:
	                persister = new FileSystemPersister_1.FileSystemPersister(storageKey, options);
	                break;
	            case constants_1.Constants.StorageProvider.Custom:
	                throw new EverliveError_1.EverliveError({ message: 'Custom storage provider requires an implementation object' });
	            default:
	                throw new EverliveError_1.EverliveError({ message: 'Unsupported storage type ' + storageProvider });
	        }
	    }
	    return persister;
	}
	exports.getPersister = getPersister;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(1);
	var EverliveError_1 = __webpack_require__(3);
	var utils_1 = __webpack_require__(4);
	/**
	 * @class BasePersister
	 * @classdesc An abstraction layer for all persisters. Every persister can write/read
	 * data to/from a specific place. The data is saved as key-value pairs where the keys are
	 * content types.
	 */
	var BasePersister = (function () {
	    function BasePersister(key, options) {
	        this.key = key;
	        this.options = options;
	        this.contentTypesStoreKey = this.key + '@ContentTypes';
	    }
	    /**
	     * Gets all the saved data.
	     * @method getAllData
	     * @memberof BasePersister
	     * @param {Function} success A success callback.
	     * @param {Function} error An error callback.
	     * @returns {Object} The keys are the content types and the values are the corresponding data items.
	     */
	    BasePersister.prototype.getAllData = function (success, error) {
	        var self = this;
	        var promises = {};
	        this._getContentTypes(function (contentTypes) {
	            _.each(contentTypes, function (contentType) {
	                promises[contentType] = new Promise(function (resolve, reject) {
	                    self.getData(contentType, resolve, reject);
	                });
	            });
	            utils_1.Utils.promiseHash(promises)
	                .then(success)
	                .catch(error);
	        }, error);
	    };
	    /**
	     * Returns the saved data for a specific content type.
	     * @method getData
	     * @param {string} contentType The content type for which to retrieve the data.
	     * @param {Function} success A success callback.
	     * @param {Function} error An error callback.
	     * @memberof BasePersister
	     * @returns {string} The retrieved data.
	     */
	    BasePersister.prototype.getData = function (contentType, success, error) {
	        throw new EverliveError_1.EverliveError({ message: 'The method getData is not implemented' });
	    };
	    /**
	     * Saves data for a specific content type.
	     * @method saveData
	     * @param {string} contentType The content for which to save the data.
	     * @param {string} data The data corresponding to the specified content type.
	     * @param {Function} success A success callback.
	     * @param {Function} error An error callback.
	     * @memberof BasePersister
	     */
	    BasePersister.prototype.saveData = function (contentType, data, success, error) {
	        throw new EverliveError_1.EverliveError({ message: 'The method saveData is not implemented' });
	    };
	    /**
	     * Clears the persisted data for a specific content type.
	     * @method purge
	     * @param {string} contentType The content type for which to clear the data.
	     * @param {Function} success A success callback.
	     * @param {Function} error An error callback.
	     * @memberof BasePersister
	     */
	    BasePersister.prototype.purge = function (contentType, success, error) {
	        throw new EverliveError_1.EverliveError({ message: 'The method clear is not implemented' });
	    };
	    /**
	     * Clears all persisted data in the offline store.
	     * @method purgeAll
	     * @memberof BasePersister
	     * @param {Function} success A success callback.
	     * @param {Function} error An error callback.
	     */
	    BasePersister.prototype.purgeAll = function (success, error) {
	        throw new EverliveError_1.EverliveError({ message: 'The method clearAll is not implemented' });
	    };
	    BasePersister.prototype._getKey = function (contentType) {
	        return this.key + '_' + contentType;
	    };
	    BasePersister.prototype._getContentTypes = function (success, error) {
	        throw new EverliveError_1.EverliveError({ message: 'The method _getContentTypes is not implemented' });
	    };
	    return BasePersister;
	}());
	exports.BasePersister = BasePersister;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var Query_1 = __webpack_require__(6);
	var EverliveError_1 = __webpack_require__(3);
	/**
	 * @class AggregateQuery
	 * @classdesc A query class used to describe a aggregation request that will be made to the {{site.TelerikBackendServices}} JavaScript API. Inherits from Query.
	 */
	var AggregateQuery = (function (_super) {
	    __extends(AggregateQuery, _super);
	    function AggregateQuery(filter, fields, sort, skip, take, expand, aggregateExpressionParam) {
	        _super.call(this, filter, fields, sort, skip, take, expand);
	        this.aggregateExpression = { 'GroupBy': [], 'Aggregate': {} };
	        // the aggregate expression will be the last argument when initializing the query
	        var aggregateExpression = aggregateExpressionParam;
	        var groupBy;
	        var aggregate;
	        if (aggregateExpression) {
	            groupBy = aggregateExpression.GroupBy;
	            aggregate = aggregateExpression.Aggregate;
	        }
	        this.aggregateExpression = { 'GroupBy': groupBy || [], 'Aggregate': aggregate || {} };
	    }
	    ;
	    // wrapper formatter to all aggregate functions, like min/max/sum/average/count
	    AggregateQuery.prototype._aggregateFunc = function (funcName, fieldName, destName) {
	        if (typeof fieldName !== 'string' && funcName !== 'count') {
	            throw new EverliveError_1.EverliveError({ message: funcName + '() accepts only string as parameter.' });
	        }
	        var aggregationObj = {};
	        aggregationObj[funcName] = fieldName;
	        this.aggregateExpression.Aggregate[destName || fieldName] = aggregationObj;
	        return this;
	    };
	    ;
	    /** Applies a groupBy to the current query. This allows you to group results by
	     * @memberOf AggregateQuery.prototype
	     * @method groupBy
	     * @name groupBy
	     * @param {String} field to group by
	     * @param {Array} array of strings with fields to group by
	     * @returns {AggregateQuery}
	     */
	    AggregateQuery.prototype.groupBy = function (data) {
	        if (_.isArray(data)) {
	            Array.prototype.push.apply(this.aggregateExpression.GroupBy, data);
	        }
	        else {
	            if (typeof data === 'string') {
	                this.aggregateExpression.GroupBy.push(data);
	            }
	            else {
	                throw new EverliveError_1.EverliveError({ message: 'groupBy() accepts only array or string as parameter.' });
	            }
	        }
	        return this;
	    };
	    ;
	    /** Adds aggregation function 'avg' (average) to the current query. Could set [resultFieldName]
	     * @memberOf AggregateQuery.prototype
	     * @method avg
	     * @name avg
	     * @param {String} field to apply aggregate function on
	     * @param {String} [resultFieldName] (Optional) Name of resulting field
	     * @returns {AggregateQuery}
	     */
	    AggregateQuery.prototype.avg = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        Array.prototype.unshift.call(args, 'avg');
	        return this._aggregateFunc.apply(this, args);
	    };
	    ;
	    /** Adds aggregation function 'count' to the current query. Could set [resultFieldName]
	     * @memberOf AggregateQuery.prototype
	     * @method count
	     * @name count
	     * @param {String} field to apply aggregate function on
	     * @param {String} [resultFieldName] (Optional) Name of resulting field
	     * @returns {AggregateQuery}
	     */
	    AggregateQuery.prototype.count = function (resultFieldName) {
	        return this._aggregateFunc('count', null, resultFieldName || 'Count');
	    };
	    ;
	    /** Adds aggregation function 'max' to the current query. Could set [resultFieldName]
	     * @memberOf AggregateQuery.prototype
	     * @method max
	     * @name max
	     * @param {String} field to apply aggregate function on
	     * @param {String} [resultFieldName] (Optional) Name of resulting field
	     * @returns {AggregateQuery}
	     */
	    AggregateQuery.prototype.max = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        Array.prototype.unshift.call(args, 'max');
	        return this._aggregateFunc.apply(this, args);
	    };
	    ;
	    /** Adds aggregation function 'min' to the current query. Could set [resultFieldName]
	     * @memberOf AggregateQuery.prototype
	     * @method min
	     * @name min
	     * @param {String} field to apply aggregate function on
	     * @param {String} [resultFieldName] (Optional) Name of resulting field
	     * @returns {AggregateQuery}
	     */
	    AggregateQuery.prototype.min = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        Array.prototype.unshift.call(args, 'min');
	        return this._aggregateFunc.apply(this, args);
	    };
	    ;
	    /** Adds aggregation function 'sum' to the current query. Could set [resultFieldName]
	     * @memberOf AggregateQuery.prototype
	     * @method sum
	     * @name sum
	     * @param {String} field to apply aggregate function on
	     * @param {String} [resultFieldName] (Optional) Name of resulting field
	     * @returns {AggregateQuery}
	     */
	    AggregateQuery.prototype.sum = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        Array.prototype.unshift.call(args, 'sum');
	        return this._aggregateFunc.apply(this, args);
	    };
	    ;
	    AggregateQuery.prototype.average = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this.avg.apply(this, args);
	    };
	    //TODO: these should be removed?
	    // select = undefined;
	    // skip  = undefined;
	    // take = undefined;
	    // order = undefined;
	    AggregateQuery.throwNotSupportedException = function (operationName) {
	        throw "Operation \"" + operationName + "\" is not supported in an aggregation query";
	    };
	    AggregateQuery.prototype.skip = function () {
	        return AggregateQuery.throwNotSupportedException('skip');
	    };
	    AggregateQuery.prototype.take = function () {
	        return AggregateQuery.throwNotSupportedException('take');
	    };
	    AggregateQuery.prototype.select = function () {
	        return AggregateQuery.throwNotSupportedException('select');
	    };
	    AggregateQuery.prototype.order = function () {
	        return AggregateQuery.throwNotSupportedException('order');
	    };
	    return AggregateQuery;
	}(Query_1.Query));
	exports.AggregateQuery = AggregateQuery;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var constants_1 = __webpack_require__(2);
	var GeoPoint_1 = __webpack_require__(28);
	var EverliveError_1 = __webpack_require__(3);
	var Expression_1 = __webpack_require__(18);
	var maxDistanceConsts = constants_1.Constants.maxDistanceConsts;
	var radiusConsts = constants_1.Constants.radiusConsts;
	var OperatorType = constants_1.Constants.OperatorType;
	var QueryBuilder = (function () {
	    function QueryBuilder(query) {
	        this.query = query;
	        this.expr = query.expr;
	    }
	    // TODO merge the two objects before returning them
	    QueryBuilder.prototype.build = function () {
	        var query = this.query;
	        if (query.filter || query.fields || query.sort || query.toskip || query.totake || query.expandExpression) {
	            return {
	                $where: query.filter || null,
	                $select: query.fields || null,
	                $sort: query.sort || null,
	                $skip: query.toskip || null,
	                $take: query.totake || null,
	                $expand: query.expandExpression || null,
	                $aggregate: query.aggregateExpression || null
	            };
	        }
	        return {
	            $where: this._buildWhere(),
	            $select: this._buildSelect(),
	            $sort: this._buildSort(),
	            $skip: this._getSkip(),
	            $take: this._getTake(),
	            $expand: this._getExpand(),
	            $aggregate: this._getAggregate()
	        };
	    };
	    QueryBuilder.prototype._getSkip = function () {
	        var skipExpression = _.find(this.expr.operands, function (value, index, list) {
	            return value.operator === OperatorType.skip;
	        });
	        return skipExpression ? skipExpression.operands[0] : null;
	    };
	    QueryBuilder.prototype._getTake = function () {
	        var takeExpression = _.find(this.expr.operands, function (value, index, list) {
	            return value.operator === OperatorType.take;
	        });
	        return takeExpression ? takeExpression.operands[0] : null;
	    };
	    QueryBuilder.prototype._getExpand = function () {
	        var expandExpression = _.chain(this.expr.operands)
	            .filter(function (value) {
	            return value.operator === OperatorType.expand;
	        })
	            .reduce(function (result, expression) {
	            return _.extend(result, expression.operands[0]);
	        }, {})
	            .value();
	        return _.isEmpty(expandExpression) ? null : expandExpression;
	    };
	    QueryBuilder.prototype._getAggregate = function () {
	        if (!this.query.aggregateExpression) {
	            return null;
	        }
	        // build $aggregate, delete empty aggregates, fail no aggregates at all
	        var aggregates = _.extend({}, this.query.aggregateExpression);
	        if (_.isEmpty(aggregates.GroupBy)) {
	            delete aggregates.GroupBy;
	        }
	        if (_.isEmpty(aggregates.Aggregate)) {
	            delete aggregates.Aggregate;
	        }
	        return aggregates;
	    };
	    QueryBuilder.prototype._buildSelect = function () {
	        var selectExpression = _.find(this.expr.operands, function (value, index, list) {
	            return value.operator === OperatorType.select;
	        });
	        var result = {};
	        if (selectExpression) {
	            _.reduce(selectExpression.operands, function (memo, value) {
	                memo[value] = 1;
	                return memo;
	            }, result);
	            return result;
	        }
	        else {
	            return null;
	        }
	    };
	    QueryBuilder.prototype._buildSort = function () {
	        var sortExpressions = _.filter(this.expr.operands, function (value, index, list) {
	            return value.operator === OperatorType.order || value.operator === OperatorType.order_desc;
	        });
	        var result = {};
	        if (sortExpressions.length > 0) {
	            _.reduce(sortExpressions, function (memo, value) {
	                memo[value.operands[0]] = value.operator === OperatorType.order ? 1 : -1;
	                return memo;
	            }, result);
	            return result;
	        }
	        else {
	            return null;
	        }
	    };
	    QueryBuilder.prototype._buildWhere = function () {
	        var whereExpression = _.find(this.expr.operands, function (value, index, list) {
	            return value.operator === OperatorType.where;
	        });
	        if (whereExpression) {
	            return this._build(new Expression_1.Expression(OperatorType.and, whereExpression.operands));
	        }
	        else {
	            var filterExpression = _.find(this.expr.operands, function (value, index, list) {
	                return value.operator === OperatorType.filter;
	            });
	            if (filterExpression) {
	                return filterExpression.operands[0];
	            }
	            return null;
	        }
	    };
	    QueryBuilder.prototype._build = function (expr) {
	        if (this._isSimple(expr)) {
	            return this._simple(expr);
	        }
	        else if (this._isRegex(expr)) {
	            return this._regex(expr);
	        }
	        else if (this._isGeo(expr)) {
	            return this._geo(expr);
	        }
	        else if (this._isAnd(expr)) {
	            return this._and(expr);
	        }
	        else if (this._isOr(expr)) {
	            return this._or(expr);
	        }
	        else if (this._isNot(expr)) {
	            return this._not(expr);
	        }
	    };
	    QueryBuilder.prototype._isSimple = function (expr) {
	        return expr.operator >= OperatorType.equal && expr.operator <= OperatorType.size;
	    };
	    QueryBuilder.prototype._simple = function (expr) {
	        var term = {}, fieldTerm = {};
	        var operands = expr.operands;
	        var operator = this._translateoperator(expr.operator);
	        if (operator) {
	            term[operator] = operands[1];
	        }
	        else {
	            term = operands[1];
	        }
	        fieldTerm[operands[0]] = term;
	        return fieldTerm;
	    };
	    QueryBuilder.prototype._isRegex = function (expr) {
	        return expr.operator >= OperatorType.regex && expr.operator <= OperatorType.endsWith;
	    };
	    QueryBuilder.prototype._regex = function (expr) {
	        var fieldTerm = {};
	        var regex = this._getRegex(expr);
	        var regexValue = this._getRegexValue(regex);
	        var operands = expr.operands;
	        fieldTerm[operands[0]] = regexValue;
	        return fieldTerm;
	    };
	    QueryBuilder.prototype._getRegex = function (expr) {
	        var pattern = expr.operands[1];
	        var flags = expr.operands[2] ? expr.operands[2] : '';
	        switch (expr.operator) {
	            case OperatorType.regex:
	                return pattern instanceof RegExp ? pattern : new RegExp(pattern, flags);
	            case OperatorType.startsWith:
	                return new RegExp("^" + pattern, flags);
	            case OperatorType.endsWith:
	                return new RegExp(pattern + "$", flags);
	            default:
	                throw new EverliveError_1.EverliveError({ message: 'Unknown operator type.' });
	        }
	    };
	    QueryBuilder.prototype._getRegexValue = function (regex) {
	        var options = '';
	        if (regex.global) {
	            options += 'g';
	        }
	        if (regex.multiline) {
	            options += 'm';
	        }
	        if (regex.ignoreCase) {
	            options += 'i';
	        }
	        return { $regex: regex.source, $options: options };
	    };
	    QueryBuilder.prototype._isGeo = function (expr) {
	        return expr.operator >= OperatorType.nearShpere && expr.operator <= OperatorType.withinShpere;
	    };
	    QueryBuilder.prototype._geo = function (expr) {
	        var fieldTerm = {};
	        var operands = expr.operands;
	        fieldTerm[operands[0]] = this._getGeoTerm(expr);
	        return fieldTerm;
	    };
	    QueryBuilder.prototype._getGeoTerm = function (expr) {
	        switch (expr.operator) {
	            case OperatorType.nearShpere:
	                return this._getNearSphereTerm(expr);
	            case OperatorType.withinBox:
	                return this._getWithinBox(expr);
	            case OperatorType.withinPolygon:
	                return this._getWithinPolygon(expr);
	            case OperatorType.withinShpere:
	                return this._getWithinCenterSphere(expr);
	            default:
	                throw new EverliveError_1.EverliveError({ message: 'Unknown operator type.' });
	        }
	    };
	    QueryBuilder.prototype._getNearSphereTerm = function (expr) {
	        var operands = expr.operands;
	        var center = this._getGeoPoint(operands[1]);
	        var maxDistance = operands[2];
	        var metrics = operands[3];
	        var maxDistanceConst;
	        var term = {
	            '$nearSphere': center
	        };
	        if (typeof maxDistance !== 'undefined') {
	            maxDistanceConst = maxDistanceConsts[metrics] || maxDistanceConsts.radians;
	            term[maxDistanceConst] = maxDistance;
	        }
	        return term;
	    };
	    QueryBuilder.prototype._getWithinBox = function (expr) {
	        var operands = expr.operands;
	        var bottomLeft = this._getGeoPoint(operands[1]);
	        var upperRight = this._getGeoPoint(operands[2]);
	        return {
	            '$within': {
	                '$box': [bottomLeft, upperRight]
	            }
	        };
	    };
	    QueryBuilder.prototype._getWithinPolygon = function (expr) {
	        var operands = expr.operands;
	        var points = this._getGeoPoints(operands[1]);
	        return {
	            '$within': {
	                '$polygon': points
	            }
	        };
	    };
	    QueryBuilder.prototype._getWithinCenterSphere = function (expr) {
	        var operands = expr.operands;
	        var center = this._getGeoPoint(operands[1]);
	        var radius = operands[2];
	        var metrics = operands[3];
	        var radiusConst = radiusConsts[metrics] || radiusConsts.radians;
	        var sphereInfo = {
	            'center': center
	        };
	        sphereInfo[radiusConst] = radius;
	        return {
	            '$within': {
	                '$centerSphere': sphereInfo
	            }
	        };
	    };
	    QueryBuilder.prototype._getGeoPoint = function (point) {
	        if (_.isArray(point)) {
	            return new GeoPoint_1.GeoPoint(point[0], point[1]);
	        }
	        return point;
	    };
	    QueryBuilder.prototype._getGeoPoints = function (points) {
	        var self = this;
	        return _.map(points, function (point) {
	            return self._getGeoPoint(point);
	        });
	    };
	    QueryBuilder.prototype._isAnd = function (expr) {
	        return expr.operator === OperatorType.and;
	    };
	    QueryBuilder.prototype._and = function (expr) {
	        var i, l, term, result = {};
	        var operands = expr.operands;
	        for (i = 0, l = operands.length; i < l; i++) {
	            term = this._build(operands[i]);
	            result = this._andAppend(result, term);
	        }
	        return result;
	    };
	    QueryBuilder.prototype._andAppend = function (andObj, newObj) {
	        var i, l, key, value, newValue;
	        var keys = _.keys(newObj);
	        for (i = 0, l = keys.length; i < l; i++) {
	            key = keys[i];
	            value = andObj[key];
	            if (typeof value === 'undefined') {
	                andObj[key] = newObj[key];
	            }
	            else {
	                newValue = newObj[key];
	                if (typeof value === 'object' && typeof newValue === 'object') {
	                    value = _.extend(value, newValue);
	                }
	                else {
	                    value = newValue;
	                }
	                andObj[key] = value;
	            }
	        }
	        return andObj;
	    };
	    QueryBuilder.prototype._isOr = function (expr) {
	        return expr.operator === OperatorType.or;
	    };
	    QueryBuilder.prototype._or = function (expr) {
	        var i, l, term, result = [];
	        var operands = expr.operands;
	        for (i = 0, l = operands.length; i < l; i++) {
	            term = this._build(operands[i]);
	            result.push(term);
	        }
	        return { $or: result };
	    };
	    QueryBuilder.prototype._isNot = function (expr) {
	        return expr.operator === OperatorType.not;
	    };
	    QueryBuilder.prototype._not = function (expr) {
	        return { $not: this._build(expr.operands[0]) };
	    };
	    QueryBuilder.prototype._translateoperator = function (operator) {
	        switch (operator) {
	            case OperatorType.equal:
	                return null;
	            case OperatorType.not_equal:
	                return '$ne';
	            case OperatorType.gt:
	                return '$gt';
	            case OperatorType.lt:
	                return '$lt';
	            case OperatorType.gte:
	                return '$gte';
	            case OperatorType.lte:
	                return '$lte';
	            case OperatorType.isin:
	                return '$in';
	            case OperatorType.notin:
	                return '$nin';
	            case OperatorType.all:
	                return '$all';
	            case OperatorType.size:
	                return '$size';
	        }
	        throw new EverliveError_1.EverliveError({ message: 'Unknown operator type.' });
	    };
	    return QueryBuilder;
	}());
	exports.QueryBuilder = QueryBuilder;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var platform = __webpack_require__(5);
	var isNativeScript = platform.isNativeScript;
	var isNodejs = platform.isNodejs;
	if (!isNodejs && !isNativeScript) {
	    exports.reqwest = __webpack_require__(169);
	}
	else if (isNativeScript) {
	    exports.reqwest = __webpack_require__(69);
	}
	else if (isNodejs) {
	    exports.reqwest = __webpack_require__(70);
	}


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(125)
	var ieee754 = __webpack_require__(126)
	var isArray = __webpack_require__(88)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36).Buffer, (function() { return this; }())))

/***/ },
/* 25 */
/***/ function(module, exports) {

	/**
	 * toString ref.
	 */
	
	var toString = Object.prototype.toString;
	
	/**
	 * Return the type of `val`.
	 *
	 * @param {Mixed} val
	 * @return {String}
	 * @api public
	 */
	
	module.exports = function(val){
	  switch (toString.call(val)) {
	    case '[object Date]': return 'date';
	    case '[object RegExp]': return 'regexp';
	    case '[object Arguments]': return 'arguments';
	    case '[object Array]': return 'array';
	    case '[object Error]': return 'error';
	  }
	
	  if (val === null) return 'null';
	  if (val === undefined) return 'undefined';
	  if (val !== val) return 'nan';
	  if (val && val.nodeType === 1) return 'element';
	
	  val = val.valueOf
	    ? val.valueOf()
	    : Object.prototype.valueOf.apply(val)
	
	  return typeof val;
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36).Buffer))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var Setup_1 = __webpack_require__(46);
	var Data_1 = __webpack_require__(16);
	var Users_1 = __webpack_require__(76);
	var Files_1 = __webpack_require__(75);
	var constants_1 = __webpack_require__(2);
	var utils_1 = __webpack_require__(4);
	var Push_1 = __webpack_require__(45);
	var Authentication_1 = __webpack_require__(47);
	var offline_1 = __webpack_require__(29);
	var Request_1 = __webpack_require__(9);
	var EverliveError_1 = __webpack_require__(3);
	var helpers_1 = __webpack_require__(54);
	var BusinessLogic_1 = __webpack_require__(49);
	var DataPreprocessor_1 = __webpack_require__(77);
	var OfflineQueryPreprocessor_1 = __webpack_require__(78);
	var BusinessLogicQueryProcessor_1 = __webpack_require__(80);
	var EventQueryProcessor_1 = __webpack_require__(82);
	var AuthenticationProcessor_1 = __webpack_require__(79);
	var OfflineQueryProcessor_1 = __webpack_require__(83);
	var OnlineQueryProcessor_1 = __webpack_require__(84);
	var CacheQueryProcessor_1 = __webpack_require__(81);
	var ResponseParserProcessor_1 = __webpack_require__(71);
	var ResponseTransformProcessor_1 = __webpack_require__(72);
	var DataQueryBuilder_1 = __webpack_require__(52);
	var QueryBuilder_1 = __webpack_require__(22);
	var caching_1 = __webpack_require__(51);
	var Query_1 = __webpack_require__(6);
	var AggregateQuery_1 = __webpack_require__(21);
	var GeoPoint_1 = __webpack_require__(28);
	var reqwest_everlive_1 = __webpack_require__(23);
	var offlinePersisters_1 = __webpack_require__(19);
	var kendo_everlive_1 = __webpack_require__(59);
	// An array keeping initialization functions called by the Everlive constructor.
	// These functions will be used to extend the functionality of an Everlive instance.
	var initializations = [];
	function protectOfflineEnabled() {
	    if (!this._isOfflineStorageEnabled()) {
	        throw new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.noOfflineSupport);
	    }
	}
	//Everlive extends KendoSdk so the typings lead to the Everlive constructor instead to the KendoSdk constructor
	var Everlive = (function (_super) {
	    __extends(Everlive, _super);
	    /**
	     * @class Everlive
	     * @classdesc The constructor of the {{site.bs}} (Everlive) JavaScript SDK. This is the entry point for the SDK.
	     * @param {object|string} options - An object containing configuration options for the Setup object. Alternatively, you can pass a string representing your App ID.
	     * @param {string} options.apiKey - Your API Key. *Deprecated*: use options.appId instead.
	     * @param {string} options.appId - Your Telerik Platform app's App ID.
	     * @param {string} [options.url=//api.everlive.com/v1/] - The {{site.TelerikBackendServices}} URL.
	     * @param {string} [options.token] - An authentication token. The instance will be associated with the provided previously obtained token.
	     * @param {string} [options.tokenType=bearer] - The type of the token that is used for authentication.
	     * @param {string} [options.masterKey] - The master key of the Telerik Platform app. Use this authorization scheme for operations that require it or to override you app's access control. Use only for development purposes. Do not deploy it with your app.
	     * @param {string} [options.scheme=http] - The URI scheme used to make requests. Supported values: http, https
	     * @param {boolean} [options.parseOnlyCompleteDateTimeObjects=false] - If set to true, the SDK will parse only complete date strings (according to the ISO 8601 standard).
	     * @param {boolean} [options.emulatorMode=false] - Set this option to true to set the SDK in emulator mode.
	     * @param {object|boolean} [options.offline] - Set this option to true to enable Offline Support using the default offline settings.
	     * @param {boolean} [options.offline.enabled=false] - When using an object to initialize Offline Support with non-default settings, set this option to enable or disable Offline Support.
	     * @param {boolean} [options.offline.isOnline=true] - Whether the storage is in online mode initially.
	     * @param {ConflictResolutionStrategy|function} [options.offline.conflicts.strategy=ConflictResolutionStrategy.ClientWins] - A constant specifying the conflict resolution strategy or a function used to resolve the conflicts.
	     * @param {boolean} [options.offline.syncUnmodified=false] - Whether to synchronize items updated or deleted on the server but not on the device.
	     * @param {object} [options.offline.storage] - An object specifying settings for the offline storage.
	     * @param {string} [options.offline.storage.provider=_platform dependant_] - Allows you to select an offline storage provider. Possible values: Everlive.Constants.StorageProvider.LocalStorage, Everlive.Constants.StorageProvider.FileSystem, Everlive.Constants.StorageProvider.Custom. Default value: Cordova, Web: Everlive.Constants.StorageProvider.LocalStorage; NativeScript, Node.js: Everlive.Constants.StorageProvider.FileSystem.
	     * @param {string} [options.offline.storage.storagePath=el_store] - A relative path specifying where data will be saved if the FileSystem provider is used.
	     * @param {number} [options.offline.storage.requestedQuota=10485760] - How much memory (in bytes) to be requested when using FileSystem for persistence. This option is only valid for Chrome as the other platforms use all the available space.
	     * @param {object} [options.offline.storage.implementation] - When storage.provider is set to custom, use this object to specify your custom offline storage implementation.
	     * @param {string} [options.offline.encryption.key] - A key that will be used to encrypt the data stored offline.
	     * @param {string} [options.offline.files.storagePath=el_file_store] - A relative path specifying where the files will be saved if file system is used for persistence of files in offline mode.
	     * @param {string} [options.offline.files.metaPath=el_file_mapping] - A relative path specifying where the metadata file will be saved if file system is used for persistence of files in offline mode.
	     * @param {object|boolean} [options.offline.files] - Set this option to true to enable support for files in offline mode.
	     * @param {number} [options.offline.files.maxConcurrentDownloads] - The maximum amount of files that can be downloaded simultaneously.
	     * @param {boolean} [options.authentication.persist=false] - Indicates whether the current user's authentication will be persisted.
	     * @param {Function} [options.authentication.onAuthenticationRequired] - Invoked when the user's credentials have expired. Allowing you to perform custom logic.
	     * @param {object} [options.helpers] - An object holding options for all Everlive helper components.
	     * @param {object} [options.helpers.html] - HTML Helper configuration objects.
	     * @param {boolean} [options.helpers.html.processOnLoad=false] - Whether to process all HTML elements when the window loads.
	     * @param {boolean} [options.helpers.html.processOnResize=false] - Whether to process all HTML elements when the window resizes.
	     * @param {string} [options.helpers.html.loadingImageUrl] - The image to be displayed while the original image is being processed.
	     * @param {string} [options.helpers.html.errorImageUrl] - The image to be displayed when the original image processing fails.
	     * @param {object} [options.helpers.html.attributes] - HTML Helper attributes configuration object.
	     * @param {object} [options.helpers.html.attributes.loadingImage=data-loading-image] - A custom name for the attribute to be used to set a loading image.
	     * @param {object} [options.helpers.html.attributes.errorImage=data-error-image] - A custom name for the attribute to be used to set an error image.
	     * @param {object} [options.helpers.html.attributes.dpi=data-dpi] - A custom name for the attribute to be used to specify DPI settings.
	     * @param {object} [options.helpers.html.attributes.imageSource=data-src] - A custom name for the attribute to be used to set the image source.
	     * @param {object} [options.helpers.html.attributes.fileSource=data-href] - A custom name for the attribute to be used to set the anchor source.
	     * @param {object} [options.helpers.html.attributes.enableOffline=data-offline] - A custom name for the attribute to be used to control offline processing.
	     * @param {object} [options.helpers.html.attributes.enableResponsive=data-responsive] - A custom name for the attribute to be used to control Responsive Images processing.
	     * @param {object|boolean} [options.caching=false] - Set this option to true to enable caching using the default cache settings.
	     * @param {number} [options.caching.maxAge=60] - Global setting for maximum age of cached items in minutes.
	     * @param {boolean} [options.caching.enabled=false] - Global setting for enabling or disabling cache.
	     * @param {object} [options.caching.typeSettings] - Specify per-content-type settings that override the global settings.
	     */
	    function Everlive(options) {
	        var _this = this;
	        _super.call(this, options);
	        this.push = this._getPush();
	        this.files = this.Files = this._getFiles(); //TODO: remove Files as they are deprecated
	        this.users = this.Users = this._getUsers(); //TODO: remove Users as its obsolete
	        this.businessLogic = this._getBusinessLogic();
	        //some fields from the options need to propagate to the initializations, e.g. the appId and apiKey
	        //since they are being set correctly when appId or apiKey is passed to the options
	        var fieldsToPropagate = _.pick(this.setup, ['appId', 'apiKey']);
	        var extendedOptions = _.extend({}, options, fieldsToPropagate);
	        _.each(initializations, function (init) {
	            init.func(extendedOptions, _this);
	        });
	        if (Everlive.$ === null) {
	            Everlive.$ = this;
	        }
	        this.registerDataQueryPreProcessor(new DataPreprocessor_1.default());
	        this.registerDataQueryPreProcessor(new OfflineQueryPreprocessor_1.default());
	        this.registerDataQueryProcessor(new BusinessLogicQueryProcessor_1.default());
	        this.registerDataQueryProcessor(new EventQueryProcessor_1.default());
	        this.registerDataQueryProcessor(new AuthenticationProcessor_1.default());
	        this.registerDataQueryProcessor(new OfflineQueryProcessor_1.default());
	        this.registerDataQueryProcessor(new OnlineQueryProcessor_1.default());
	        this.registerDataQueryProcessor(new CacheQueryProcessor_1.default());
	        this.registerDataQueryPostProcessor(new ResponseParserProcessor_1.ResponseParserProcessor());
	        this.registerDataQueryPostProcessor(new ResponseTransformProcessor_1.default());
	    }
	    Everlive.init = function (options) {
	        Everlive.$ = null;
	        return new Everlive(options);
	    };
	    Everlive.disableRequestCache = function () {
	        return utils_1.Utils.disableRequestCache();
	    };
	    /**
	     * Returns the URL to the {{site.bs}} application endpoint that the SDK uses.
	     * @memberOf Everlive.prototype
	     * @method buildUrl
	     * @returns {string} The generated URL.
	     */
	    Everlive.prototype.buildUrl = function () {
	        return utils_1.Utils.buildUrl(this.setup);
	    };
	    /**
	     * Generates the Authorization headers that are used by the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK to make requests to the {{site.bs}} servers.
	     * @memberOf Everlive
	     * @returns {Object} AuthorizationHeaders The generated Authorization headers object.
	     */
	    Everlive.prototype.buildAuthHeader = function () {
	        return utils_1.Utils.buildAuthHeader(this.setup);
	    };
	    /**
	     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
	     * @memberOf Everlive.prototype
	     * @method authInfo
	     * @name authInfo
	     * @deprecated
	     * @see [authentication.getAuthenticationStatus]{@link ../Authentication/authentication.getAuthenticationStatus}
	     * @returns {Promise} A promise to the authentication status.
	     */
	    /**
	     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
	     * @memberOf Everlive.prototype
	     * @method authInfo
	     * @name authInfo
	     * @deprecated
	     * @see [authentication.getAuthenticationStatus]{@link ../Authentication/authentication.getAuthenticationStatus}
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Everlive.prototype.authInfo = function (success, error) {
	        var _this = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            var setup = _this.setup;
	            if (setup.masterKey) {
	                return success({ status: Everlive.AuthStatus.masterKey });
	            }
	            if (!setup.token) {
	                return success({ status: Everlive.AuthStatus.unauthenticated });
	            }
	            if (_this.authentication && _this.authentication.isAuthenticationInProgress()) {
	                return success({ status: Everlive.AuthStatus.authenticating });
	            }
	            _this.users
	                .skipAuth(true)
	                .currentUser()
	                .then(function (res) {
	                return success({ status: Everlive.AuthStatus.authenticated, user: res.result });
	            }, function (err) {
	                if (_this.authentication && _this.authentication.isAuthenticationInProgress()) {
	                    return success({ status: Everlive.AuthStatus.authenticating });
	                }
	                else if (err.code === EverliveError_1.EverliveErrors.invalidRequest.code || err.code === EverliveError_1.EverliveErrors.expiredToken.code) {
	                    return success({ status: Everlive.AuthStatus.invalidAuthentication });
	                }
	                else {
	                    return error(err);
	                }
	            });
	        }, success, error);
	    };
	    /**
	     * Make a request to the current {{site.bs}} JavaScript SDK instance.
	     * @method request
	     * @memberOf Everlive.prototype
	     * @param {object} options Object used to configure the request.
	     * @param {object} options.endpoint The endpoint of the {{site.bs}} JavaScript API relative to the App ID section. (For example, options.endpoint = MyType will make a request to the MyType type.)
	     * @param {HttpMethod} [options.method] HTTP request method.
	     * @param {object} [options.data] Data to be sent with the request.
	     * @param {Function} [options.success] Success callback that will be called when the request finishes successfully.
	     * @param {Function} [options.error] Error callback to be called in case of an error.
	     * @param {object} [options.headers] Additional headers to be included in the request.
	     * @param {Query|object} [options.filter] This is either a {@link Query} or a [filter](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) expression.
	     * @param {boolean} [options.authHeaders=true] When set to false, no Authorization headers will be sent with the request.
	     * @returns {function} The request configuration object containing the `send` function that sends the request.
	     */
	    Everlive.prototype.request = function (options) {
	        return new Request_1.Request(this.setup, options);
	    };
	    /**
	     * Sets the SDK to work in offline mode. Defaults to true.
	     * @method offline
	     * @memberOf Everlive.prototype
	     * @param {boolean} [isOffline = true] Boolean parameter for setting the SDK to online or offline mode.
	     */
	    Everlive.prototype.offline = function (isOffline) {
	        if (isOffline === void 0) { isOffline = true; }
	        protectOfflineEnabled.call(this);
	        this.offlineStorage._setOffline(isOffline);
	    };
	    /**
	     * Sets the SDK to work in online mode. Defaults to true.
	     * @method online
	     * @memberOf Everlive.prototype
	     * @param {boolean} [isOnline = true] Boolean parameter for setting the SDK to online or offline mode.
	     */
	    Everlive.prototype.online = function (isOnline) {
	        if (isOnline === void 0) { isOnline = true; }
	        protectOfflineEnabled.call(this);
	        this.offlineStorage._setOffline(!isOnline);
	    };
	    /**
	     * Check if the SDK is in offline mode.
	     * @method isOffline
	     * @memberOf Everlive.prototype
	     * @returns {boolean} Returns true if the SDK is in offline mode.
	     */
	    Everlive.prototype.isOffline = function () {
	        protectOfflineEnabled.call(this);
	        return !this.isOnline();
	    };
	    /**
	     * Check if the SDK is in online mode.
	     * @method isOnline
	     * @memberOf Everlive.prototype
	     * @returns {boolean} Returns true if the SDK is in online mode.
	     */
	    Everlive.prototype.isOnline = function () {
	        return this.offlineStorage.isOnline();
	    };
	    /**
	     * Starts the synchronization procedure. Emits the 'syncStart' event when started and the 'syncEnd' event when the procedure finishes. 'syncEnd' contains information about the completed sync operation that you can use to find out how many items were synchronized.
	     * @method sync
	     * @memberOf Everlive.prototype
	     */
	    Everlive.prototype.sync = function () {
	        protectOfflineEnabled.call(this);
	        return this.offlineStorage.sync.apply(this.offlineStorage, arguments);
	    };
	    Everlive.prototype._isOfflineStorageEnabled = function () {
	        return utils_1.Utils.isOfflineStorageEnabled(this.setup);
	    };
	    /**
	     * Creates a new {@link Data} class.
	     * @memberOf Everlive.prototype
	     * @instance
	     * @param {String} collectionName The name of the collection to be used.
	     * @returns {Data}
	     */
	    Everlive.prototype._getData = function (collectionName) {
	        return new Data_1.Data(this, collectionName);
	    };
	    Everlive.prototype._getDataQueryBuilder = function () {
	        return new DataQueryBuilder_1.DataQueryBuilder();
	    };
	    Everlive.prototype._getSetup = function (options) {
	        return new Setup_1.Setup(options);
	    };
	    Everlive.prototype._getUsers = function () {
	        return new Users_1.Users(this);
	    };
	    Everlive.prototype._getAuthentication = function () {
	        return new Authentication_1.default(this);
	    };
	    Everlive.prototype._getPush = function () {
	        return new Push_1.Push(this);
	    };
	    Everlive.prototype._getFiles = function () {
	        return new Files_1.Files(this);
	    };
	    Everlive.prototype._getBusinessLogic = function () {
	        return new BusinessLogic_1.BusinessLogic(this);
	    };
	    /**
	     * Adds an event listener to the SDK.
	     * @method addListener
	     * @param {String} eventName The name of the event to which to subscribe.
	     * @param {Function} eventListener An event listener which will be called once the event is raised.
	     * @memberOf Everlive.prototype
	     */
	    /**
	     * Adds an event listener to the SDK.
	     * @method on
	     * @param {String} eventName The name of the event to which to subscribe.
	     * @param {Function} eventListener An event listener which will be called once the event is raised.
	     * @memberOf Everlive.prototype
	     */
	    /**
	     * Removes an SDK event listener.
	     * @method removeListener
	     * @param {String} eventName The name of the event for which to stop listening.
	     * @param {Function} eventListener The event listener to remove.
	     * @memberOf Everlive.prototype
	     */
	    /**
	     * Removes an SDK event listener.
	     * @method off
	     * @param {String} eventName The name of the event for which to stop listening.
	     * @param {Function} eventListener The event listener to remove.
	     * @memberOf Everlive.prototype
	     */
	    /**
	     * Adds an event listener to the SDK which will be called only the first time the event is emitted.
	     * @method once
	     * @param {String} eventName The name of the event to which to subscribe.
	     * @param {Function} eventListener An event listener which will be called once the event is raised.
	     * @memberOf Everlive.prototype
	     */
	    /**
	     * Removes all SDK event listeners.
	     * @memberOf Everlive.prototype
	     * @method removeAllListeners
	     * @param {string} eventName Removes all event listeners for the specified event.
	     * @returns {void}
	     */
	    /** Reference to the current {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
	     * @memberOf Everlive
	     * @type {Everlive}
	     * @static
	     */
	    Everlive.$ = null;
	    //Global event handlers for push notification events. Required by the cordova PushNotifications plugin that we use.
	    Everlive.PushCallbacks = {};
	    Everlive.Offline = {};
	    Everlive.Query = Query_1.Query;
	    Everlive.AggregateQuery = AggregateQuery_1.AggregateQuery;
	    Everlive.QueryBuilder = QueryBuilder_1.QueryBuilder;
	    Everlive.GeoPoint = GeoPoint_1.GeoPoint;
	    Everlive.Constants = constants_1.Constants;
	    Everlive.Request = Request_1.Request;
	    Everlive.EverliveErrors = EverliveError_1.EverliveErrors;
	    Everlive.Data = Data_1.Data;
	    Everlive._utils = utils_1.Utils;
	    Everlive._traverseAndRevive = utils_1.Utils.parseUtilities.traverseAndRevive;
	    Everlive._common = {
	        _: _,
	        rsvp: {
	            Promise: Promise,
	            all: Promise.all.bind(Promise),
	            hashSettled: utils_1.Utils.promiseHashSettled,
	            allSettled: utils_1.Utils.promisesAllSettled,
	            hash: utils_1.Utils.promiseHash
	        },
	        Promise: Promise,
	        reqwest: reqwest_everlive_1.reqwest
	    };
	    Everlive.persister = {
	        LocalStorage: offlinePersisters_1.LocalStoragePersister,
	        FileSystem: offlinePersisters_1.FileSystemPersister
	    };
	    Everlive.version = '1.8.1';
	    Everlive.commit = 'c9eb4bd0378c4638019c7a873d2e2213ea08cf42';
	    Everlive.idField = constants_1.Constants.idField;
	    /** An array of functions that are invoked during instantiation of the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
	     * @memberOf Everlive
	     * @type {Function[]}
	     * @static
	     * @private
	     */
	    Everlive.initializations = initializations;
	    Everlive.AuthStatus = constants_1.Constants.AuthStatus;
	    return Everlive;
	}(kendo_everlive_1.KendoSdk));
	exports.Everlive = Everlive;
	// var initDefault = function initDefault() {
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @deprecated
	//      * @see {@link Everlive.users}
	//      * @description An instance of the [Users]{@link Users} class for working with users.
	//      * @member {Users} Users
	//      */
	//     this.Users = users;
	//
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @description An instance of the [Users]{@link Users} class for working with users.
	//      * @member {users} users
	//      */
	//     this.users = users;
	//
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @deprecated Use everlive.files instead.
	//      * @see {@link Everlive.files}
	//      * @description An instance of the [Files]{@link Files} class for working with files.
	//      * @member {Files} Files
	//      */
	//     this.Files = files;
	//
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @description An instance of the [Files]{@link Files} class for working with files.
	//      * @member {Files} files
	//      */
	//     this.files = files;
	//
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @description An instance of the [Push]{@link Push} class for working with push notifications.
	//      * @member {Push} push
	//      */
	//     this.push = new Push(this);
	//
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @description An instance of the [BusinessLogic]{@link BusinessLogic} class for invoking cloud functions and stored procedures through the SDK
	//      * @member {businessLogic} businessLogic
	//      */
	//     this.businessLogic = new BusinessLogic(this.options);
	// };
	//
	// var initAuthentication = function initAuthentication() {
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
	//      * @member {Authentication} authentication
	//      */
	//     /**
	//      * @memberOf Everlive
	//      * @instance
	//      * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
	//      * @member {authentication} authentication
	//      */
	//     const auth = this._createAuthentication(this.options.authentication);
	//     this.authentication = this.Authentication = auth;
	// };
	var initializeHelpers = function initializeHelpers(options, sdk) {
	    sdk.helpers = {};
	    _.each(helpers_1.helpers, function (helper) {
	        var helperOptions = options.helpers ? options.helpers[helper.name] : null;
	        sdk.helpers[helper.name] = new helper.ctor(sdk, helperOptions);
	    });
	};
	initializations.push({ name: 'caching', func: caching_1.initCaching });
	initializations.push({ name: 'cacheStore', func: caching_1.initStore });
	initializations.push({ name: 'offlineStorage', func: offline_1.initOfflineStorage });
	initializations.push({ name: 'helpers', func: initializeHelpers });


/***/ },
/* 28 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @classdesc A class representing a value for the {{site.TelerikBackendServices}} GeoPoint field.
	 * @class GeoPoint
	 * @param longitude Longitude of the GeoPoint in decimal degrees (range: -180 to 180). Example: `123.3239467`
	 * @param latitude Latitude of the GeoPoint in decimal degrees (range: -90 to 90). Example: `42.6954322`
	 */
	var GeoPoint = (function () {
	    //TODO add a function for calculating the distances in geospatial queries
	    function GeoPoint(longitude, latitude) {
	        if (longitude === void 0) { longitude = 0; }
	        if (latitude === void 0) { latitude = 0; }
	        this.longitude = longitude;
	        this.latitude = latitude;
	    }
	    return GeoPoint;
	}());
	exports.GeoPoint = GeoPoint;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var constants_1 = __webpack_require__(2);
	var offlinePersisters_1 = __webpack_require__(19);
	var OfflineStorageModule_1 = __webpack_require__(63);
	var EverliveError_1 = __webpack_require__(3);
	var platform_1 = __webpack_require__(5);
	var CryptographicProvider_1 = __webpack_require__(53);
	var defaultOfflineStorageOptions = {
	    autoSync: true,
	    enabled: true,
	    conflicts: {
	        strategy: constants_1.Constants.ConflictResolutionStrategy.ClientWins,
	        implementation: null
	    },
	    offline: false,
	    storage: {
	        name: '',
	        provider: platform_1.isNativeScript ? constants_1.Constants.StorageProvider.FileSystem : constants_1.Constants.StorageProvider.LocalStorage,
	        implementation: null,
	        storagePath: constants_1.Constants.DefaultStoragePath,
	        requestedQuota: constants_1.Constants.DefaultFilesystemStorageQuota
	    },
	    typeSettings: {},
	    encryption: {
	        provider: constants_1.Constants.EncryptionProvider.Default,
	        implementation: null,
	        key: ''
	    },
	    files: {
	        storagePath: constants_1.Constants.DefaultFilesStoragePath,
	        metaPath: constants_1.Constants.DefaultFilesMetadataPath,
	        maxConcurrentDownloads: constants_1.Constants.MaxConcurrentDownloadTasks
	    }
	};
	var conflictResolutionStrategies = {};
	conflictResolutionStrategies[constants_1.Constants.ConflictResolutionStrategy.ClientWins] = function (collection, local, server) {
	    return new Promise(function (resolve) {
	        resolve(local);
	    });
	};
	conflictResolutionStrategies[constants_1.Constants.ConflictResolutionStrategy.ServerWins] = function (collection, local, server) {
	    return new Promise(function (resolve) {
	        resolve(server);
	    });
	};
	var initStoragePersister = function initStoragePersister(options, sdk) {
	    var storageKey = options.storage.name || 'everliveOfflineStorage_' + sdk.setup.appId;
	    var persister = offlinePersisters_1.getPersister(storageKey, options);
	    options.storage.implementation = persister;
	    return persister;
	};
	var initEncryptionProvider = function initEncryptionProvider(options, sdk) {
	    var encryptor;
	    var encryptionProvider = options.encryption.provider;
	    var encryptionImplementation = options.encryption.implementation;
	    if (_.isObject(encryptionImplementation) && encryptionProvider === constants_1.Constants.EncryptionProvider.Custom) {
	        encryptor = encryptionImplementation;
	    }
	    else {
	        switch (encryptionProvider) {
	            case constants_1.Constants.EncryptionProvider.Default:
	                encryptor = new CryptographicProvider_1.CryptographicProvider(options);
	                break;
	            case constants_1.Constants.EncryptionProvider.Custom:
	                throw new EverliveError_1.EverliveError({ message: 'Custom encryption provider requires an implementation object' });
	            default:
	                throw new EverliveError_1.EverliveError({ message: 'Unsupported encryption provider ' + encryptionProvider });
	        }
	    }
	    options.encryption.implementation = encryptor;
	    return encryptor;
	};
	function buildOfflineStorageOptions(sdkOptions) {
	    var storageOptions = sdkOptions.offline || sdkOptions.offlineStorage;
	    var options;
	    if (storageOptions === true) {
	        options = _.defaults({}, defaultOfflineStorageOptions);
	    }
	    else if (_.isObject(storageOptions)) {
	        options = _.defaults(storageOptions, defaultOfflineStorageOptions);
	        options.storage = _.defaults(storageOptions.storage, defaultOfflineStorageOptions.storage);
	        options.encryption = _.defaults(storageOptions.encryption, defaultOfflineStorageOptions.encryption);
	        options.conflicts = _.defaults(storageOptions.conflicts, defaultOfflineStorageOptions.conflicts);
	        options.files = _.defaults(storageOptions.files, defaultOfflineStorageOptions.files);
	    }
	    else {
	        options = _.defaults({}, defaultOfflineStorageOptions);
	        options.enabled = false;
	        if (!storageOptions) {
	            sdkOptions.offlineStorage = options;
	        }
	    }
	    options.cacheEnabled = sdkOptions.caching && sdkOptions.caching.enabled;
	    return options;
	}
	exports.buildOfflineStorageOptions = buildOfflineStorageOptions;
	var buildOfflineStorageModule = function buildOfflineStorageModule(sdkOptions, sdk) {
	    var options = buildOfflineStorageOptions(sdkOptions);
	    var persister = initStoragePersister(options, sdk);
	    var encryptionProvider = initEncryptionProvider(options, sdk);
	    return new OfflineStorageModule_1.OfflineStorageModule(sdk, options, persister, encryptionProvider);
	};
	var initOfflineStorage = function (options, sdk) {
	    sdk.offlineStorage = buildOfflineStorageModule(options, sdk);
	};
	exports.initOfflineStorage = initOfflineStorage;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(1);
	var constants_1 = __webpack_require__(2);
	var traverseAndApply = function (value, operation, additionalOptions) {
	    if (_.isArray(value)) {
	        return _.map(value, function (item) {
	            return operation(item, additionalOptions);
	        });
	    }
	    else {
	        return operation(value, additionalOptions);
	    }
	};
	var idTransformation = function (value) {
	    if (typeof value === 'object' && value._id && !value.Id) {
	        value.Id = value._id;
	        delete value._id;
	    }
	    return value;
	};
	var removeIdTransform = function (value, opts) {
	    var verifyStateCreated = opts.verifyStateCreated;
	    var shouldModifyObject = verifyStateCreated ? value[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.created : true;
	    if (typeof value === 'object' && (value._id || value.Id) && shouldModifyObject) {
	        delete value._id;
	        delete value.Id;
	    }
	    return value;
	};
	var removeMarkerTransform = function (value) {
	    delete value[constants_1.Constants.offlineItemsStateMarker];
	    return value;
	};
	exports.offlineTransformations = {
	    removeIdTransform: function (value, verifyStateCreated) {
	        return traverseAndApply(value, removeIdTransform, { verifyStateCreated: verifyStateCreated });
	    },
	    idTransform: function (value) {
	        return traverseAndApply(value, idTransformation);
	    },
	    singleFieldTransform: function (singleFieldExpression, value) {
	        if (typeof value === 'undefined' || value === null) {
	            return null;
	        }
	        else {
	            return value[singleFieldExpression];
	        }
	    },
	    traverseAndTransformFilterId: function (filterObj) {
	        if (filterObj && filterObj.Id) {
	            filterObj._id = filterObj.Id;
	            delete filterObj.Id;
	        }
	        for (var prop in filterObj) {
	            if (filterObj.hasOwnProperty(prop)) {
	                var objectMember = filterObj[prop];
	                if (typeof objectMember === 'object') {
	                    exports.offlineTransformations.traverseAndTransformFilterId(objectMember);
	                }
	            }
	        }
	    },
	    removeMarkersTransform: function (value) {
	        return traverseAndApply(value, removeMarkerTransform);
	    },
	    removeFieldsTransform: function (value, fields) {
	        _.each(fields, function (field) {
	            delete value[field];
	        });
	        return value;
	    }
	};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var jstimezonedetect_1 = __webpack_require__(127);
	var _ = __webpack_require__(1);
	var EverliveError_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(2);
	var utils_1 = __webpack_require__(4);
	var Platform = constants_1.Constants.Platform;
	var buildPromise = utils_1.Utils.buildPromise;
	/**
	 * @class CurrentDevice
	 * @deprecated
	 * @protected
	 * @param pushHandler
	 * @constructor
	 */
	var CurrentDevice = (function () {
	    function CurrentDevice(pushHandler) {
	        if (!window.cordova) {
	            throw new EverliveError_1.EverliveError({ message: 'Error: currentDevice() can only be called from within a hybrid mobile app, after \'deviceready\' event has been fired.' });
	        }
	        this._pushHandler = pushHandler;
	        this._initSuccessCallback = null;
	        this._initErrorCallback = null;
	        //Suffix for the global callback functions
	        this._globalFunctionSuffix = null;
	        this.pushSettings = null;
	        this.pushToken = null;
	        this.isInitialized = false;
	        this.isInitializing = false;
	        this.emulatorMode = false;
	    }
	    CurrentDevice.ensurePushIsAvailable = function () {
	        var isPushNotificationPluginAvailable = (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification);
	        if (!isPushNotificationPluginAvailable && !utils_1.Utils._inAppBuilderSimulator()) {
	            throw new EverliveError_1.EverliveError({ message: 'The push notification plugin is not available. Ensure that the pushNotification plugin is included ' +
	                    'and use after `deviceready` event has been fired.' });
	        }
	    };
	    /**
	     * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
	     * @method enableNotifications
	     * @name enableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
	     * @method enableNotifications
	     * @name enableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.enableNotifications = function (pushSettings, success, error) {
	        this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);
	        return buildPromise(_.bind(this._initialize, this), success, error);
	    };
	    /**
	     * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
	     * @method disableNotifications
	     * @name disableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
	     * @method disableNotifications
	     * @name disableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.disableNotifications = function (success, error) {
	        var self = this;
	        return this.unregister().then(function () {
	            return buildPromise(function (success, error) {
	                if (self.emulatorMode) {
	                    success();
	                }
	                else {
	                    var pushNotification = window.plugins.pushNotification;
	                    var unregisterOptions;
	                    var platformType = self._getPlatformType();
	                    if (platformType === Platform.WindowsPhone) {
	                        unregisterOptions = { 'channelName': self.pushSettings.wp8.channelName };
	                    }
	                    pushNotification.unregister(function () {
	                        self.isInitialized = false;
	                        success();
	                    }, error, unregisterOptions);
	                }
	            }, success, error);
	        }, error);
	    };
	    /**
	     * Returns the push registration for the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method getRegistration
	     * @name getRegistration
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Returns the push registration for the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method getRegistration
	     * @name getRegistration
	     * @param {Function} success Callback to invoke on success.
	     * @param {Function} error Callback to invoke on error.
	     */
	    CurrentDevice.prototype.getRegistration = function (success, error) {
	        var deviceId = encodeURIComponent(this._getDeviceId());
	        return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
	    };
	    /**
	     * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
	     * @memberOf CurrentDevice.prototype
	     * @method register
	     * @name register
	     * @param {Object} customParameters Custom parameters for the registration.
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
	     * @memberOf CurrentDevice.prototype
	     * @method register
	     * @name register
	     * @param {Object} customParameters Custom parameters for the registration.
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.register = function (customParameters, success, error) {
	        var self = this;
	        var deviceRegistration = {};
	        if (customParameters !== undefined) {
	            deviceRegistration.Parameters = customParameters;
	        }
	        return this._populateRegistrationObject(deviceRegistration).then(function () {
	            return self._pushHandler.devices.create(deviceRegistration, success, error);
	        }, error);
	    };
	    /**
	     * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
	     * @memberOf CurrentDevice.prototype
	     * @method unregister
	     * @name unregister
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
	     * @memberOf CurrentDevice.prototype
	     * @method unregister
	     * @name unregister
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.unregister = function (success, error) {
	        var deviceId = encodeURIComponent(device.uuid);
	        return this._pushHandler.devices.destroySingle({ Id: 'HardwareId/' + deviceId }, success, error);
	    };
	    /**
	     * Updates the registration of the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method updateRegistration
	     * @name updateRegistration
	     * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Updates the registration for the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method updateRegistration
	     * @name updateRegistration
	     * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.updateRegistration = function (customParameters, success, error) {
	        var self = this;
	        var deviceRegistration = {};
	        if (customParameters !== undefined) {
	            deviceRegistration.Parameters = customParameters;
	        }
	        return this._populateRegistrationObject(deviceRegistration).then(function () {
	            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
	            return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
	        }, error);
	    };
	    /**
	     * This method provides a different operation on each supported platform:
	     *
	     * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
	     * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
	     * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
	     * @method areNotificationsEnabled
	     * @name areNotificationsEnabled
	     * @memberOf Push.prototype
	     * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
	     * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
	     * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
	     * @method areNotificationsEnabled
	     * @name areNotificationsEnabled
	     * @memberOf Push.prototype
	     * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
	     * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
	     * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
	     */
	    CurrentDevice.prototype.areNotificationsEnabled = function (options, onSuccess, onError) {
	        options = options || {};
	        var pushNotification = window.plugins.pushNotification;
	        return buildPromise(function (successCb, errorCb) {
	            pushNotification.areNotificationsEnabled(successCb, errorCb, options);
	        }, onSuccess, onError);
	    };
	    CurrentDevice.prototype.notificationProcessed = function () {
	        var pushPlugin = window.plugins.pushNotification;
	        pushPlugin.notificationProcessed();
	    };
	    CurrentDevice.prototype._initializeInteractivePush = function (iOSSettings, success, error) {
	        var pushPlugin = window.plugins.pushNotification;
	        var interactiveSettings = iOSSettings.interactiveSettings;
	        var notificationTypes = [];
	        if (iOSSettings.alert) {
	            notificationTypes.push(pushPlugin.UserNotificationTypes.Alert);
	        }
	        if (iOSSettings.badge) {
	            notificationTypes.push(pushPlugin.UserNotificationTypes.Badge);
	        }
	        if (iOSSettings.sound) {
	            notificationTypes.push(pushPlugin.UserNotificationTypes.Sound);
	        }
	        var getAction = function (actionIdentifier) {
	            var action = _.find(interactiveSettings.actions, function (action) {
	                return action.identifier === actionIdentifier;
	            });
	            return action;
	        };
	        var categories = _.map(interactiveSettings.categories, function (category) {
	            return {
	                identifier: category.identifier,
	                actionsForDefaultContext: _.map(category.actionsForDefaultContext, getAction),
	                actionsForMinimalContext: _.map(category.actionsForMinimalContext, getAction)
	            };
	        });
	        pushPlugin.registerUserNotificationSettings(
	        // the success callback which will immediately return (APNs is not contacted for this)
	        success, 
	        // called in case the configuration is incorrect
	        error, {
	            // asking permission for these features
	            types: notificationTypes,
	            // register these categories
	            categories: categories
	        });
	    };
	    //Initializes the push functionality on the device.
	    CurrentDevice.prototype._initialize = function (success, error) {
	        var self = this;
	        if (this.isInitializing) {
	            error(new EverliveError_1.EverliveError({ message: 'Push notifications are currently initializing.' }));
	            return;
	        }
	        if (!this.emulatorMode && (!window.navigator || !window.navigator.globalization)) {
	            error(new EverliveError_1.EverliveError({ message: 'The globalization plugin is not initialized.' }));
	            return;
	        }
	        if (!this.emulatorMode && (!window.plugins || !window.plugins.pushNotification)) {
	            error(new EverliveError_1.EverliveError({ message: 'The push notifications plugin is not initialized.' }));
	            return;
	        }
	        this._initSuccessCallback = success;
	        this._initErrorCallback = error;
	        if (this.isInitialized) {
	            this._deviceRegistrationSuccess(this.pushToken);
	            return;
	        }
	        if (this.emulatorMode) {
	            setTimeout(function () {
	                self._deviceRegistrationSuccess('fake_push_token');
	            }, 1000);
	            return;
	        }
	        this.isInitializing = true;
	        var suffix = this._globalFunctionSuffix;
	        if (!suffix) {
	            suffix = Date.now().toString();
	            this._globalFunctionSuffix = suffix;
	        }
	        var pushNotification = window.plugins.pushNotification;
	        var platformType = this._getPlatformType();
	        if (platformType === Platform.iOS) {
	            //Initialize global APN callback
	            var apnCallbackName = 'apnCallback_' + suffix;
	            Everlive.PushCallbacks[apnCallbackName] = _.bind(this._onNotificationAPN, this);
	            //Construct registration options object and validate iOS settings
	            var apnRegistrationOptions = this.pushSettings.iOS;
	            apnRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + apnCallbackName;
	            //Register for APN
	            pushNotification.register(_.bind(this._successfulRegistrationAPN, this), _.bind(this._failedRegistrationAPN, this), apnRegistrationOptions);
	        }
	        else if (platformType === Platform.Android) {
	            //Initialize global GCM callback
	            var gcmCallbackName = 'gcmCallback_' + suffix;
	            Everlive.PushCallbacks[gcmCallbackName] = _.bind(this._onNotificationGCM, this);
	            //Construct registration options object and validate the Android settings
	            var gcmRegistrationOptions = this.pushSettings.android;
	            this._validateAndroidSettings(gcmRegistrationOptions);
	            gcmRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + gcmCallbackName;
	            //Register for GCM
	            pushNotification.register(_.bind(this._successSentRegistrationGCM, this), _.bind(this._errorSentRegistrationGCM, this), gcmRegistrationOptions);
	        }
	        else if (platformType === Platform.WindowsPhone) {
	            //Initialize global WP8 callbacks.
	            var wp8CallbackName = 'wp8Callback_' + suffix;
	            var wp8RegistrationSuccessCallbackName = 'wp8RegistrationSuccessCallback_' + suffix;
	            var wp8RegistrationErrorCallbackName = 'wp8RegistrationErrorCallback_' + suffix;
	            Everlive.PushCallbacks[wp8CallbackName] = _.bind(this._onNotificationWP8, this);
	            Everlive.PushCallbacks[wp8RegistrationSuccessCallbackName] = _.bind(this._deviceRegistrationSuccessWP, this);
	            Everlive.PushCallbacks[wp8RegistrationErrorCallbackName] = _.bind(this._deviceRegistrationFailed, this);
	            //Construct registration options object and validate the WP8  settings
	            var wp8RegistrationOptions = this.pushSettings.wp8;
	            this._validateWP8Settings(wp8RegistrationOptions);
	            wp8RegistrationOptions.ecb = 'Everlive.PushCallbacks.' + wp8CallbackName;
	            wp8RegistrationOptions.uccb = 'Everlive.PushCallbacks.' + wp8RegistrationSuccessCallbackName;
	            wp8RegistrationOptions.errcb = 'Everlive.PushCallbacks.' + wp8RegistrationErrorCallbackName;
	            pushNotification.register(_.bind(this._successSentRegistrationWP8, this), _.bind(this._errorSentRegistrationWP8, this), wp8RegistrationOptions);
	        }
	        else {
	            throw new EverliveError_1.EverliveError({ message: 'The current platform is not supported: ' + device.platform });
	        }
	    };
	    CurrentDevice.prototype._deviceRegistrationSuccessWP = function (result) {
	        this._deviceRegistrationSuccess(result.uri);
	    };
	    CurrentDevice.prototype._validateAndroidSettings = function (androidSettings) {
	        if (!androidSettings.senderID) {
	            throw new EverliveError_1.EverliveError({ message: 'Sender ID (project number) is not set in the android settings.' });
	        }
	    };
	    CurrentDevice.prototype._validateWP8Settings = function (settings) {
	        if (!settings.channelName) {
	            throw new EverliveError_1.EverliveError({ message: 'channelName is not set in the WP8 settings.' });
	        }
	    };
	    CurrentDevice.prototype._cleanPlatformsPushSettings = function (pushSettings) {
	        var cleanSettings = {};
	        pushSettings = pushSettings || {};
	        var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
	            if (!pushSettings[platform]) {
	                return;
	            }
	            newSettingsObject[platform] = newSettingsObject[platform] || {};
	            var newPlatformSettings = pushSettings[platform];
	            var settings = newSettingsObject[platform];
	            _.each(allowedFields, function (allowedField) {
	                if (newPlatformSettings.hasOwnProperty(allowedField)) {
	                    settings[allowedField] = newPlatformSettings[allowedField];
	                }
	            });
	        };
	        addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
	        addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
	        addSettingsForPlatform(cleanSettings, 'wp8', ['channelName']);
	        var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS', 'notificationCallbackWP8'];
	        _.each(callbackFields, function (callbackField) {
	            var callback = pushSettings[callbackField];
	            if (callback) {
	                if (typeof callback !== 'function') {
	                    throw new EverliveError_1.EverliveError({ message: 'The "' + callbackField + '" of the push settings should be a function' });
	                }
	                cleanSettings[callbackField] = pushSettings[callbackField];
	            }
	        });
	        if (pushSettings.customParameters) {
	            cleanSettings.customParameters = pushSettings.customParameters;
	        }
	        return cleanSettings;
	    };
	    CurrentDevice.prototype._populateRegistrationObject = function (deviceRegistration, success, error) {
	        var self = this;
	        return buildPromise(function (success, error) {
	            if (!self.pushToken) {
	                throw new EverliveError_1.EverliveError({ message: 'Push token is not available.' });
	            }
	            self._getLocaleName(function (locale) {
	                var deviceId = self._getDeviceId();
	                var hardwareModel = device.model;
	                var platformType = self._getPlatformType();
	                var timeZone = jstimezonedetect_1.jstz.determine().name();
	                var pushToken = self.pushToken;
	                var language = locale.value;
	                var platformVersion = device.version;
	                deviceRegistration.HardwareId = deviceId;
	                deviceRegistration.HardwareModel = hardwareModel;
	                deviceRegistration.PlatformType = platformType;
	                deviceRegistration.PlatformVersion = platformVersion;
	                deviceRegistration.TimeZone = timeZone;
	                deviceRegistration.PushToken = pushToken;
	                deviceRegistration.Locale = language;
	                success();
	            }, error);
	        }, success, error);
	    };
	    CurrentDevice.prototype._getLocaleName = function (success, error) {
	        if (this.emulatorMode) {
	            success({ value: 'en_US' });
	        }
	        else {
	            navigator.globalization.getLocaleName(function (locale) {
	                success(locale);
	            }, error);
	            navigator.globalization.getLocaleName(function (locale) {
	            }, error);
	        }
	    };
	    CurrentDevice.prototype._getDeviceId = function () {
	        return device.uuid;
	    };
	    //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
	    CurrentDevice.prototype._getPlatformType = function () {
	        var psLower = device.platform.toLowerCase();
	        switch (psLower) {
	            case 'ios':
	            case 'iphone':
	            case 'ipad':
	                return Platform.iOS;
	            case 'android':
	                return Platform.Android;
	            case 'wince':
	                return Platform.WindowsPhone;
	            case 'win32nt':
	                return Platform.WindowsPhone;
	            default:
	                return Platform.Unknown;
	        }
	    };
	    CurrentDevice.prototype._deviceRegistrationFailed = function (error) {
	        this.pushToken = null;
	        this.isInitializing = false;
	        this.isInitialized = false;
	        if (this._initErrorCallback) {
	            this._initErrorCallback({ error: error });
	        }
	    };
	    CurrentDevice.prototype._deviceRegistrationSuccess = function (token) {
	        this.pushToken = token;
	        this.isInitializing = false;
	        this.isInitialized = true;
	        if (this._initSuccessCallback) {
	            this._initSuccessCallback({ token: token });
	        }
	    };
	    //Occurs when the device registration in APN succeeds
	    CurrentDevice.prototype._successfulRegistrationAPN = function (token) {
	        var self = this;
	        if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
	            this._initializeInteractivePush(this.pushSettings.iOS, function () {
	                self._deviceRegistrationSuccess(token);
	            }, function (err) {
	                throw new EverliveError_1.EverliveError({ message: 'The interactive push configuration is incorrect: ' + err });
	            });
	        }
	        else {
	            this._deviceRegistrationSuccess(token);
	        }
	    };
	    //Occurs if the device registration in APN fails
	    CurrentDevice.prototype._failedRegistrationAPN = function (error) {
	        this._deviceRegistrationFailed(error);
	    };
	    //Occurs when device registration has been successfully sent to GCM
	    CurrentDevice.prototype._successSentRegistrationGCM = function (id) {
	        //console.log("Successfully sent request for registering with GCM.");
	    };
	    //Occurs when device registration has been successfully sent for WP8
	    CurrentDevice.prototype._successSentRegistrationWP8 = function (id) {
	        //console.log("Successfully sent request for registering WP8 .");
	    };
	    //Occurs when an error occured when sending registration request for WP8
	    CurrentDevice.prototype._errorSentRegistrationWP8 = function (error) {
	        this._deviceRegistrationFailed(error);
	    };
	    //Occurs when an error occured when sending registration request to GCM
	    CurrentDevice.prototype._errorSentRegistrationGCM = function (error) {
	        this._deviceRegistrationFailed(error);
	    };
	    //This function receives all notification events from APN
	    CurrentDevice.prototype._onNotificationAPN = function (e) {
	        this._raiseNotificationEventIOS(e);
	    };
	    //This function receives all notification events for WP8
	    CurrentDevice.prototype._onNotificationWP8 = function (e) {
	        this._raiseNotificationEventWP8(e);
	    };
	    //This function receives all notification events from GCM
	    CurrentDevice.prototype._onNotificationGCM = function (e) {
	        switch (e.event) {
	            case 'registered':
	                if (e.regid.length > 0) {
	                    this._deviceRegistrationSuccess(e.regid);
	                }
	                break;
	            case 'message':
	                this._raiseNotificationEventAndroid(e);
	                break;
	            case 'error':
	                if (!this.pushToken) {
	                    this._deviceRegistrationFailed(e);
	                }
	                else {
	                    this._raiseNotificationEventAndroid(e);
	                }
	                break;
	            default:
	                this._raiseNotificationEventAndroid(e);
	                break;
	        }
	    };
	    CurrentDevice.prototype._raiseNotificationEventAndroid = function (e) {
	        if (this.pushSettings.notificationCallbackAndroid) {
	            this.pushSettings.notificationCallbackAndroid(e);
	        }
	    };
	    CurrentDevice.prototype._raiseNotificationEventIOS = function (e) {
	        if (this.pushSettings.notificationCallbackIOS) {
	            this.pushSettings.notificationCallbackIOS(e);
	        }
	    };
	    CurrentDevice.prototype._raiseNotificationEventWP8 = function (e) {
	        if (this.pushSettings.notificationCallbackWP8) {
	            this.pushSettings.notificationCallbackWP8(e);
	        }
	    };
	    return CurrentDevice;
	}());
	module.exports = CurrentDevice;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var jstimezonedetect_1 = __webpack_require__(127);
	var EverliveError_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(2);
	var utils_1 = __webpack_require__(4);
	var tnsPlatform;
	try {
	    tnsPlatform = __webpack_require__(188);
	}
	catch (e) {
	    throw e;
	} // because of webpack external dependency declaration - this marks it as optional
	var Platform = constants_1.Constants.Platform;
	var buildPromise = utils_1.Utils.buildPromise;
	/**
	 * @class CurrentDevice
	 * @deprecated
	 * @protected
	 * @param pushHandler
	 * @constructor
	 */
	var CurrentDevice = (function () {
	    function CurrentDevice(pushHandler) {
	        this._pushHandler = pushHandler;
	        this._initSuccessCallback = null;
	        this._initErrorCallback = null;
	        //Suffix for the global callback functions
	        this._globalFunctionSuffix = null;
	        this.pushSettings = null;
	        this.pushToken = null;
	        this.isInitialized = false;
	        this.isInitializing = false;
	        this.emulatorMode = false;
	    }
	    Object.defineProperty(CurrentDevice.prototype, "pushPlugin", {
	        get: function () {
	            try {
	                return __webpack_require__(186);
	            }
	            catch (e) {
	                throw e;
	            } // because of webpack external dependency declaration - this marks it as optional
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    /**
	     * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
	     * @method enableNotifications
	     * @name enableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
	     * @method enableNotifications
	     * @name enableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.enableNotifications = function (pushSettings, success, error) {
	        this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);
	        return buildPromise(_.bind(this._initialize, this), success, error);
	    };
	    /**
	     * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
	     * @method disableNotifications
	     * @name disableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
	     * @method disableNotifications
	     * @name disableNotifications
	     * @memberOf CurrentDevice.prototype
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.disableNotifications = function (successCb, errorCb) {
	        var self = this;
	        return this.unregister().then(function () {
	            return buildPromise(function (success, error) {
	                var successCallback = function successCallback() {
	                    self.isInitialized = false;
	                    success();
	                };
	                var platformType = self._getPlatformType();
	                if (platformType === Platform.Android) {
	                    return this.pushPlugin.unregister(successCallback, error, self.pushSettings.android);
	                }
	                this.pushPlugin.unregister(successCallback, error);
	            }, successCb, errorCb);
	        }, errorCb);
	    };
	    /**
	     * Returns the push registration for the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method getRegistration
	     * @name getRegistration
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Returns the push registration for the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method getRegistration
	     * @name getRegistration
	     * @param {Function} success Callback to invoke on success.
	     * @param {Function} error Callback to invoke on error.
	     */
	    CurrentDevice.prototype.getRegistration = function (success, error) {
	        var deviceId = encodeURIComponent(this._getDeviceId());
	        return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
	    };
	    /**
	     * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
	     * @memberOf CurrentDevice.prototype
	     * @method register
	     * @name register
	     * @param {Object} customParameters Custom parameters for the registration.
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()]{@link currentDevice.enableNotifications} has completed successfully.
	     * @memberOf CurrentDevice.prototype
	     * @method register
	     * @name register
	     * @param {Object} customParameters Custom parameters for the registration.
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.register = function (customParameters, success, error) {
	        var self = this;
	        var deviceRegistration = {};
	        if (customParameters !== undefined) {
	            deviceRegistration.Parameters = customParameters;
	        }
	        return this._populateRegistrationObject(deviceRegistration).then(function () {
	            return self._pushHandler.devices.create(deviceRegistration, success, error);
	        }, error);
	    };
	    /**
	     * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
	     * @memberOf CurrentDevice.prototype
	     * @method unregister
	     * @name unregister
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
	     * @memberOf CurrentDevice.prototype
	     * @method unregister
	     * @name unregister
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.unregister = function (success, error) {
	        var deviceId = encodeURIComponent(this._getDeviceId());
	        return this._pushHandler.devices.destroySingle({ Id: 'HardwareId/' + deviceId }, success, error);
	    };
	    /**
	     * Updates the registration of the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method updateRegistration
	     * @name updateRegistration
	     * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
	     * @returns {Object} The promise for the request.
	     */
	    /**
	     * Updates the registration for the current device.
	     * @memberOf CurrentDevice.prototype
	     * @method updateRegistration
	     * @name updateRegistration
	     * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    CurrentDevice.prototype.updateRegistration = function (customParameters, success, error) {
	        var self = this;
	        var deviceRegistration = {};
	        if (customParameters !== undefined) {
	            deviceRegistration.Parameters = customParameters;
	        }
	        return this._populateRegistrationObject(deviceRegistration).then(function () {
	            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
	            return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
	        }, error);
	    };
	    /**
	     * This method provides a different operation on each supported platform:
	     *
	     * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
	     * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
	     * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
	     * @method areNotificationsEnabled
	     * @name areNotificationsEnabled
	     * @memberOf Push.prototype
	     * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
	     * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
	     * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
	     * @method areNotificationsEnabled
	     * @name areNotificationsEnabled
	     * @memberOf Push.prototype
	     * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
	     * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
	     * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
	     */
	    CurrentDevice.prototype.areNotificationsEnabled = function (options, onSuccess, onError) {
	        options = options || {};
	        return buildPromise(function (successCb, errorCb) {
	            this.pushPlugin.areNotificationsEnabled(successCb, errorCb, options);
	        }, onSuccess, onError);
	    };
	    CurrentDevice.prototype._initializeInteractivePush = function (iOSSettings, success, error) {
	        this.pushPlugin.registerUserNotificationSettings(
	        // the success callback which will immediately return (APNs is not contacted for this)
	        success, 
	        // called in case the configuration is incorrect
	        error);
	    };
	    //Initializes the push functionality on the device.
	    CurrentDevice.prototype._initialize = function (success, error) {
	        if (this.isInitializing) {
	            error(new EverliveError_1.EverliveError({ message: 'Push notifications are currently initializing.' }));
	            return;
	        }
	        this._initSuccessCallback = success;
	        this._initErrorCallback = error;
	        if (this.isInitialized) {
	            this._deviceRegistrationSuccess(this.pushToken);
	            return;
	        }
	        this.isInitializing = true;
	        var suffix = this._globalFunctionSuffix;
	        if (!suffix) {
	            suffix = Date.now().toString();
	            this._globalFunctionSuffix = suffix;
	        }
	        var platformType = this._getPlatformType();
	        if (platformType === Platform.iOS) {
	            //Construct registration options object and validate iOS settings
	            var apnRegistrationOptions = this.pushSettings.iOS;
	            apnRegistrationOptions.notificationCallbackIOS = this.pushSettings.notificationCallbackIOS;
	            //Register for APN
	            this.pushPlugin.register(apnRegistrationOptions, _.bind(this._successfulRegistrationAPN, this), _.bind(this._failedRegistrationAPN, this));
	        }
	        else if (platformType === Platform.Android) {
	            // Ensure the required fields are present in the Android Settings
	            var gcmRegistrationOptions = this.pushSettings.android;
	            this._validateAndroidSettings(gcmRegistrationOptions);
	            gcmRegistrationOptions.notificationCallbackAndroid = this.pushSettings.notificationCallbackAndroid;
	            //Register for GCM
	            this.pushPlugin.register(gcmRegistrationOptions, _.bind(this._successSentRegistrationGCM, this), _.bind(this._errorSentRegistrationGCM, this));
	        }
	        else {
	            throw new EverliveError_1.EverliveError({ message: 'The current platform is not supported: ' + tnsPlatform.device.os });
	        }
	    };
	    CurrentDevice.prototype._validateAndroidSettings = function (androidSettings) {
	        if (!androidSettings.senderID) {
	            throw new EverliveError_1.EverliveError({ message: 'Sender ID (project number) is not set in the android settings.' });
	        }
	    };
	    CurrentDevice.prototype._cleanPlatformsPushSettings = function (pushSettings) {
	        var cleanSettings = {};
	        pushSettings = pushSettings || {};
	        var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
	            if (!pushSettings[platform]) {
	                return;
	            }
	            newSettingsObject[platform] = newSettingsObject[platform] || {};
	            var newPlatformSettings = pushSettings[platform];
	            var settings = newSettingsObject[platform];
	            _.each(allowedFields, function (allowedField) {
	                if (newPlatformSettings.hasOwnProperty(allowedField)) {
	                    settings[allowedField] = newPlatformSettings[allowedField];
	                }
	            });
	        };
	        addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
	        addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
	        var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS'];
	        _.each(callbackFields, function (callbackField) {
	            var callback = pushSettings[callbackField];
	            if (callback) {
	                if (typeof callback !== 'function') {
	                    throw new EverliveError_1.EverliveError({ message: 'The "' + callbackField + '" of the push settings should be a function' });
	                }
	                cleanSettings[callbackField] = pushSettings[callbackField];
	            }
	        });
	        if (pushSettings.customParameters) {
	            cleanSettings.customParameters = pushSettings.customParameters;
	        }
	        return cleanSettings;
	    };
	    CurrentDevice.prototype._populateRegistrationObject = function (deviceRegistration, success, error) {
	        var self = this;
	        return buildPromise(function (success, error) {
	            if (!self.pushToken) {
	                throw new EverliveError_1.EverliveError({ message: 'Push token is not available.' });
	            }
	            self._getLocaleName(function (locale) {
	                var deviceId = self._getDeviceId();
	                var hardwareModel = tnsPlatform.device.model;
	                var platformType = self._getPlatformType();
	                var timeZone = jstimezonedetect_1.jstz.determine().name();
	                var pushToken = self.pushToken;
	                var language = 'en_US'; //TODO
	                var platformVersion = tnsPlatform.device.osVersion;
	                deviceRegistration.HardwareId = deviceId;
	                deviceRegistration.HardwareModel = hardwareModel;
	                deviceRegistration.PlatformType = platformType;
	                deviceRegistration.PlatformVersion = platformVersion;
	                deviceRegistration.TimeZone = timeZone;
	                deviceRegistration.PushToken = pushToken;
	                deviceRegistration.Locale = language;
	                success();
	            }, error);
	        }, success, error);
	    };
	    CurrentDevice.prototype._getLocaleName = function (success, error) {
	        return success(); // TODO
	        /* TODO: Must translate somehow to NativeScript to get the current locale
	         if (this.emulatorMode) {
	         success({value: 'en_US'});
	         } else {
	         navigator.globalization.getLocaleName(
	         function (locale) {
	         success(locale);
	         },
	         error
	         );
	         navigator.globalization.getLocaleName(
	         function (locale) {
	         },
	         error
	         );
	         }*/
	    };
	    CurrentDevice.prototype._getDeviceId = function () {
	        return tnsPlatform.device.uuid;
	    };
	    //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
	    CurrentDevice.prototype._getPlatformType = function () {
	        var psLower = tnsPlatform.device.os.toLowerCase();
	        switch (psLower) {
	            case 'ios':
	            case 'iphone':
	            case 'ipad':
	                return Platform.iOS;
	            case 'android':
	                return Platform.Android;
	            default:
	                return Platform.Unknown;
	        }
	    };
	    CurrentDevice.prototype._deviceRegistrationFailed = function (error) {
	        this.pushToken = null;
	        this.isInitializing = false;
	        this.isInitialized = false;
	        if (this._initErrorCallback) {
	            this._initErrorCallback({ error: error });
	        }
	    };
	    CurrentDevice.prototype._deviceRegistrationSuccess = function (token) {
	        this.pushToken = token;
	        this.isInitializing = false;
	        this.isInitialized = true;
	        if (this._initSuccessCallback) {
	            this._initSuccessCallback({ token: token });
	        }
	    };
	    //Occurs when the device registration in APN succeeds
	    CurrentDevice.prototype._successfulRegistrationAPN = function (token) {
	        var self = this;
	        if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
	            this._initializeInteractivePush(this.pushSettings.iOS, function () {
	                self._deviceRegistrationSuccess(token);
	            }, function (err) {
	                throw new EverliveError_1.EverliveError({ message: 'The interactive push configuration is incorrect: ' + err });
	            });
	        }
	        else {
	            this._deviceRegistrationSuccess(token);
	        }
	    };
	    //Occurs if the device registration in APN fails
	    CurrentDevice.prototype._failedRegistrationAPN = function (error) {
	        this._deviceRegistrationFailed(error);
	    };
	    //Occurs when device registration has been successfully sent to GCM
	    CurrentDevice.prototype._successSentRegistrationGCM = function (token) {
	        //console.log("Successfully sent request for registering with GCM.");
	        // set on message received.
	        this.pushPlugin.onMessageReceived(this.pushSettings.notificationCallbackAndroid);
	        this._deviceRegistrationSuccess(token);
	    };
	    //Occurs when an error occured when sending registration request to GCM
	    CurrentDevice.prototype._errorSentRegistrationGCM = function (error) {
	        this._deviceRegistrationFailed(error);
	    };
	    CurrentDevice.prototype.notificationProcessed = function () {
	        throw new Error('Not implemented');
	    };
	    //This function receives all notification events from APN
	    CurrentDevice.prototype._onNotificationAPN = function (e) {
	        this._raiseNotificationEventIOS(e);
	    };
	    //This function receives all notification events from GCM
	    CurrentDevice.prototype._onNotificationGCM = function (e) {
	        switch (e.event) {
	            case 'registered':
	                if (e.regid.length > 0) {
	                    this._deviceRegistrationSuccess(e.regid);
	                }
	                break;
	            case 'message':
	                this._raiseNotificationEventAndroid(e);
	                break;
	            case 'error':
	                if (!this.pushToken) {
	                    this._deviceRegistrationFailed(e);
	                }
	                else {
	                    this._raiseNotificationEventAndroid(e);
	                }
	                break;
	            default:
	                this._raiseNotificationEventAndroid(e);
	                break;
	        }
	    };
	    CurrentDevice.prototype._raiseNotificationEventAndroid = function (e) {
	        if (this.pushSettings.notificationCallbackAndroid) {
	            this.pushSettings.notificationCallbackAndroid(e);
	        }
	    };
	    CurrentDevice.prototype._raiseNotificationEventIOS = function (e) {
	        if (this.pushSettings.notificationCallbackIOS) {
	            this.pushSettings.notificationCallbackIOS(e);
	        }
	    };
	    CurrentDevice.ensurePushIsAvailable = function () {
	        // NativeScript will throw an error when the TNS Push Plugin cannot be required. So this is actually unreachable.
	    };
	    return CurrentDevice;
	}());
	module.exports = CurrentDevice;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var path = __webpack_require__(13);
	var Constants_1 = __webpack_require__(8);
	var Request_1 = __webpack_require__(9);
	exports.RequestOptionsBuilder = (_a = {
	        _buildEndpointUrl: function (dataQuery) {
	            var endpoint = dataQuery.collectionName;
	            var isQueryById = dataQuery.additionalOptions && dataQuery.additionalOptions.id !== undefined;
	            var queryType = typeof dataQuery.query;
	            if (isQueryById) {
	                endpoint = path.join(endpoint, dataQuery.additionalOptions.id.toString());
	            }
	            else if (queryType === 'string' || queryType === 'number') {
	                endpoint = path.join(endpoint, dataQuery.query);
	            }
	            return endpoint;
	        },
	        _buildBaseObject: function (dataQuery) {
	            var defaultObject = {
	                endpoint: exports.RequestOptionsBuilder._buildEndpointUrl(dataQuery),
	                query: dataQuery.query,
	                data: dataQuery.data,
	                headers: dataQuery.headers
	            };
	            if (dataQuery.parse) {
	                defaultObject.parse = dataQuery.parse;
	            }
	            return defaultObject;
	        },
	        _build: function (dataQuery, additionalOptions) {
	            var options = _.extend(exports.RequestOptionsBuilder._buildBaseObject(dataQuery), additionalOptions);
	            if (additionalOptions.endpointSupplement) {
	                options.endpoint = path.join(options.endpoint, additionalOptions.endpointSupplement);
	            }
	            return options;
	        }
	    },
	    _a[Constants_1.DataQueryOperation.Read] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'GET'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.ReadById] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'GET'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.Count] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'GET',
	            endpoint: dataQuery.collectionName + '/_count'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.Create] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.RawUpdate] = function (dataQuery) {
	        var query = dataQuery.query;
	        var ofilter = typeof query === 'object' ? query : null; // request options filter
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'PUT',
	            query: ofilter
	        });
	    },
	    _a[Constants_1.DataQueryOperation.Update] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'PUT'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.Delete] = function (dataQuery) {
	        return deleteOperation(dataQuery);
	    },
	    _a[Constants_1.DataQueryOperation.DeleteById] = function (dataQuery) {
	        return deleteOperation(dataQuery);
	    },
	    _a[Constants_1.DataQueryOperation.SetAcl] = function (dataQuery) {
	        var method, data;
	        if (dataQuery.additionalOptions.acl === null) {
	            method = 'DELETE';
	        }
	        else {
	            method = 'PUT';
	            data = dataQuery.additionalOptions.acl;
	        }
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: method,
	            endpointSupplement: '/_acl',
	            data: data
	        });
	    },
	    _a[Constants_1.DataQueryOperation.SetOwner] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'PUT',
	            endpointSupplement: '/_owner'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserLogin] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST',
	            endpoint: 'oauth/token',
	            authHeaders: false,
	            parse: Request_1.Request.parsers.single
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserLogout] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'GET',
	            endpoint: 'oauth/logout'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserChangePassword] = function (dataQuery) {
	        var keepTokens = dataQuery.additionalOptions.keepTokens;
	        var endpoint = 'Users/changepassword';
	        if (keepTokens) {
	            endpoint += '?keepTokens=true';
	        }
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST',
	            endpoint: endpoint,
	            parse: Request_1.Request.parsers.single
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserLoginWithProvider] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST',
	            authHeaders: false
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserLinkWithProvider] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST',
	            endpoint: exports.RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/link'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserUnlinkFromProvider] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST',
	            endpoint: exports.RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/unlink'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserResetPassword] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST',
	            endpoint: exports.RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/resetpassword'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.UserSetPassword] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'POST',
	            endpoint: exports.RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/setpassword'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.FilesUpdateContent] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'PUT',
	            endpoint: exports.RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/Content'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.FilesGetDownloadUrlById] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'GET'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.Aggregate] = function (dataQuery) {
	        return exports.RequestOptionsBuilder._build(dataQuery, {
	            method: 'GET',
	            endpoint: dataQuery.collectionName + '/_aggregate'
	        });
	    },
	    _a[Constants_1.DataQueryOperation.InvokeCloudFunction] = function (dataQuery) {
	        return businessLogic(dataQuery);
	    },
	    _a[Constants_1.DataQueryOperation.InvokeStoredProcedure] = function (dataQuery) {
	        return businessLogic(dataQuery);
	    },
	    _a
	);
	function deleteOperation(dataQuery) {
	    return _.extend(exports.RequestOptionsBuilder._buildBaseObject(dataQuery), {
	        method: 'DELETE'
	    });
	}
	function businessLogic(dataQuery) {
	    return exports.RequestOptionsBuilder._build(dataQuery, dataQuery.additionalOptions);
	}
	var _a;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var platform = __webpack_require__(5);
	var WebFileStore_1 = __webpack_require__(74);
	var NativeScriptFileStore_1 = __webpack_require__(73);
	function getFileStore(storagePath, options) {
	    if (platform.isNativeScript) {
	        return new NativeScriptFileStore_1.NativeScriptFileStore(storagePath, options);
	    }
	    else if (platform.isCordova || platform.isDesktop) {
	        return new WebFileStore_1.WebFileStore(storagePath, options);
	    }
	    else {
	        return {};
	    }
	}
	exports.getFileStore = getFileStore;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var platform = __webpack_require__(5);
	function initLocalStorage(options) {
	    if (platform.isNativeScript) {
	        var localSettings;
	        //workound for older nativescript versions
	        try {
	            localSettings = __webpack_require__(182);
	        }
	        catch (e) {
	            try {
	                localSettings = __webpack_require__(185);
	            }
	            catch (ex) {
	                throw ex;
	            } // because of webpack external dependency declaration - this marks it as optional
	        }
	        return {
	            getItem: function (key) {
	                return localSettings.getString(key);
	            },
	            removeItem: function (key) {
	                return localSettings.remove(key);
	            },
	            setItem: function (key, value) {
	                return localSettings.setString(key, value);
	            }
	        };
	    }
	    else {
	        var localStorage;
	        if (platform.isNodejs) {
	            var LocalStorage = null;
	            try {
	                LocalStorage = __webpack_require__(187).LocalStorage;
	            }
	            catch (e) {
	                throw e;
	            } // because of webpack external dependency declaration - this marks it as optional
	            localStorage = new LocalStorage(options.storage.storagePath);
	        }
	        else {
	            localStorage = window.localStorage;
	        }
	        return {
	            getItem: function (key) {
	                return localStorage.getItem(key);
	            },
	            removeItem: function (key) {
	                return localStorage.removeItem(key);
	            },
	            setItem: function (key, value) {
	                return localStorage.setItem(key, value);
	            }
	        };
	    }
	}
	var LocalStore = (function () {
	    function LocalStore(options) {
	        this.options = options;
	        this._localStorage = initLocalStorage(this.options);
	    }
	    LocalStore.prototype.getItem = function (key) {
	        return this._localStorage.getItem(key);
	    };
	    LocalStore.prototype.removeItem = function (key) {
	        return this._localStorage.removeItem(key);
	    };
	    LocalStore.prototype.setItem = function (key, value) {
	        return this._localStorage.setItem(key, value);
	    };
	    return LocalStore;
	}());
	exports.LocalStore = LocalStore;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(125)
	var ieee754 = __webpack_require__(126)
	var isArray = __webpack_require__(88)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36).Buffer, (function() { return this; }())))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(17).EventEmitter;
	var inherits = __webpack_require__(11);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(166);
	Stream.Writable = __webpack_require__(168);
	Stream.Duplex = __webpack_require__(163);
	Stream.Transform = __webpack_require__(167);
	Stream.PassThrough = __webpack_require__(165);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(7).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38).setImmediate, __webpack_require__(38).clearImmediate))

/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';
	var Constants = {};
	Constants.DefaultTakeItemsCount = 50;
	Constants.ExpandExpressionName = 'Expand';
	Constants.ReturnAsFieldName = 'ReturnAs';
	Constants.FieldsExpressionName = 'Fields';
	Constants.SingleFieldExpressionName = 'SingleField';
	Constants.SortExpressionName = 'Sort';
	Constants.FilterExpressionName = 'Filter';
	Constants.SkipExpressionName = 'Skip';
	Constants.TakeExpressionName = 'Take';
	Constants.ParentRelationFieldName = 'ParentRelationField';
	Constants.IdFieldNameClient = 'Id';
	Constants.TargetTypeNameFieldName = 'TargetTypeName';
	Constants.ReturnItemsCountFieldName = 'ReturnItemsCount';
	Constants.AggregateExpressionFieldName = 'Aggregate';
	
	module.exports = Constants;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var events_1 = __webpack_require__(17);
	var underscore_1 = __webpack_require__(1);
	var EventArgs = (function () {
	    function EventArgs() {
	        this.canceled = false;
	    }
	    EventArgs.prototype.cancel = function () {
	        this.canceled = true;
	    };
	    return EventArgs;
	}());
	/*
	Adds extended functionality to the event emitter:
	    * Cancelable event arguments - the event arguments are always passed as last argument,
	      calling cancel will stop other event listeners in the chain from being invoked
	    * prependOnceListener - Prepend a listener to the start of the chain - useful if you want
	      it to be able to cancel the event
	 */
	var EventEmitterExtended = (function (_super) {
	    __extends(EventEmitterExtended, _super);
	    function EventEmitterExtended() {
	        _super.apply(this, arguments);
	    }
	    EventEmitterExtended.prototype.emit = function (eventName) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        args.push(new EventArgs());
	        return _super.prototype.emit.apply(this, [eventName].concat(args));
	    };
	    EventEmitterExtended.prototype.addListener = function (eventName, listener) {
	        var _this = this;
	        var wrappedListener = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var ev = underscore_1.last(args);
	            if (ev.canceled) {
	                return;
	            }
	            return listener.apply(_this, args);
	        };
	        _super.prototype.addListener.call(this, eventName, wrappedListener);
	        return this;
	    };
	    EventEmitterExtended.prototype.prependOnceListener = function (eventName, listener) {
	        this.once(eventName, listener);
	        if (!Array.isArray(this._events[eventName])) {
	            return this;
	        }
	        var lastListener = underscore_1.last(this._events[eventName]);
	        var allListeners = underscore_1.without(this._events[eventName], lastListener);
	        this._events[eventName] = [lastListener].concat(allListeners);
	        return this;
	    };
	    EventEmitterExtended.prototype.once = function (eventName, listener) {
	        _super.prototype.once.call(this, eventName, listener);
	        return this;
	    };
	    EventEmitterExtended.prototype.on = function (eventName, listener) {
	        this.addListener(eventName, listener);
	        return this;
	    };
	    EventEmitterExtended.prototype.off = function (eventName, listener) {
	        this.removeListener(eventName, listener);
	        return this;
	    };
	    return EventEmitterExtended;
	}(events_1.EventEmitter));
	exports.EventEmitterExtended = EventEmitterExtended;


/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";
	var Query = (function () {
	    function Query() {
	    }
	    return Query;
	}());
	exports.Query = Query;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var platform = __webpack_require__(5);
	var Utils = (function () {
	    function Utils() {
	    }
	    Utils.guardUnset = function (value, name, message) {
	        if (!message) {
	            message = 'The ' + name + ' is required';
	        }
	        if (typeof value === 'undefined' || value === null) {
	            throw new Error(message); // TODO: use CommonError
	        }
	    };
	    ;
	    Utils.isGuid = function (str) {
	        return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str);
	    };
	    Utils.cloneDate = function (d) {
	        return new Date(d);
	    };
	    Utils.buildPromise = function (operation, success, error) {
	        var callbacks = Utils.getCallbacks(success, error);
	        operation(callbacks.success, callbacks.error);
	        return callbacks.promise;
	    };
	    Utils.getCallbacks = function (success, error) {
	        var promise;
	        var createPromise = function () {
	            return new Promise(function (resolve, reject) {
	                success = function (data) {
	                    resolve(data);
	                };
	                error = function (error) {
	                    reject(error);
	                };
	            });
	        };
	        if (platform.isNodejs) {
	            // node js style continuation
	            if (typeof success === 'function' && typeof error !== 'function') {
	                var callback = success;
	                success = function (data, response) {
	                    callback(null, data, response);
	                };
	                error = function (error) {
	                    callback(error);
	                };
	            }
	            else if (typeof success !== 'function' && typeof error !== 'function') {
	                promise = createPromise();
	            }
	        }
	        else {
	            if (typeof success !== 'function' && typeof error !== 'function') {
	                promise = createPromise();
	            }
	        }
	        return { promise: promise, success: success, error: error };
	    };
	    Utils.isDate = function (date) {
	        return date && (date instanceof Date || !_.isNaN(Date.parse(date)));
	    };
	    Utils.successfulPromise = function (data) {
	        return new Promise(function (resolve) {
	            resolve(data);
	        });
	    };
	    Utils.rejectedPromise = function (err) {
	        return new Promise(function (resolve, reject) {
	            reject(err);
	        });
	    };
	    Utils.uuid = function () {
	        //http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
	        var d = new Date().getTime();
	        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	            var r = (d + Math.random() * 16) % 16 | 0;
	            d = Math.floor(d / 16);
	            return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
	        });
	        return uuid;
	    };
	    Utils.parseUtilities = {
	        getReviver: function (parseOnlyCompleteDateTimeString) {
	            var dateParser;
	            if (parseOnlyCompleteDateTimeString) {
	                dateParser = Utils.parseUtilities.parseIsoDateString;
	            }
	            else {
	                dateParser = Utils.parseUtilities.parseOnlyCompleteDateTimeString;
	            }
	            return function (key, value) {
	                if (typeof value === 'string') {
	                    var date = dateParser(value);
	                    if (date) {
	                        value = date;
	                    }
	                }
	                return value;
	            };
	        },
	        parseIsoDateString: function (string) {
	            var match;
	            if (match = string.match(/^(\d{4})(-(\d{2})(-(\d{2})(T(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2}))))?))$/)) {
	                // DateTime
	                var secondParts = match[12];
	                if (secondParts) {
	                    if (secondParts.length > 3) {
	                        secondParts = Math.round(Number(secondParts.substr(0, 3) + '.' + secondParts.substr(3)));
	                    }
	                    else if (secondParts.length < 3) {
	                        // if the secondParts are one or two characters then two or one zeros should be appended
	                        // in order to have the correct number for milliseconds ('.67' means 670ms not 67ms)
	                        secondParts += secondParts.length === 2 ? '0' : '00';
	                    }
	                }
	                var date = new Date(Date.UTC(Number(match[1]), // year
	                (Number(match[3]) - 1) || 0, // month
	                Number(match[5]) || 0, // day
	                Number(match[7]) || 0, // hour
	                Number(match[8]) || 0, // minute
	                Number(match[10]) || 0, // second
	                Number(secondParts) || 0));
	                if (match[13] && match[13] !== "Z") {
	                    var h = Number(match[16]) || 0, m = Number(match[17]) || 0;
	                    h *= 3600000;
	                    m *= 60000;
	                    var offset = h + m;
	                    if (match[15] === "+")
	                        offset = -offset;
	                    date = new Date(date.valueOf() + offset);
	                }
	                return date;
	            }
	            else {
	                return null;
	            }
	        },
	        parseOnlyCompleteDateTimeString: function (string) {
	            if (/^\d{4}-\d{2}-\d{2}$/.test(string)) {
	                // Date
	                return null;
	            }
	            if (/^(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2})))?$/.test(string)) {
	                // Time
	                return null;
	            }
	            return Utils.parseUtilities.parseIsoDateString(string);
	        },
	        traverse: function (obj, func) {
	            var key, value, newValue;
	            for (key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    value = obj[key];
	                    newValue = func(key, value);
	                    obj[key] = newValue;
	                    if (value === newValue && typeof value === 'object') {
	                        Utils.parseUtilities.traverse(value, func);
	                    }
	                }
	            }
	            return obj;
	        },
	        traverseAndRevive: function (data, reviver) {
	            if (!reviver) {
	                reviver = Utils.parseUtilities.getReviver();
	            }
	            return Utils.parseUtilities.traverse(data, reviver);
	        },
	        parseError: function (reviver, error) {
	            if (typeof error === 'string' && error.length > 0) {
	                try {
	                    error = JSON.parse(error);
	                    return { message: error.message, code: error.errorCode };
	                }
	                catch (e) {
	                    return error;
	                }
	            }
	            else {
	                return error;
	            }
	        },
	        _parseInternal: function (reviver, data) {
	            if (typeof data === 'string' && data.length > 0) {
	                data = JSON.parse(data, reviver);
	            }
	            else if (typeof data === 'object') {
	                Utils.parseUtilities.traverseAndRevive(data, reviver);
	            }
	            return data;
	        },
	        _transformResult: function (data, additionalProperties) {
	            if (data) {
	                var result = _.extend({}, additionalProperties);
	                result.result = data.Result === undefined ? data.result : data.Result;
	                result.count = data.Count === undefined ? data.count : data.Count;
	                return result;
	            }
	            else {
	                return data;
	            }
	        },
	        parseResult: function (reviver, data) {
	            data = Utils.parseUtilities._parseInternal.apply(null, arguments);
	            return Utils.parseUtilities._transformResult(data, { count: data.Count });
	        },
	        parseSingleResult: function (reviver, data) {
	            data = Utils.parseUtilities._parseInternal.apply(null, arguments);
	            return Utils.parseUtilities._transformResult(data);
	        },
	        parseUpdateResult: function (reviver, data) {
	            data = Utils.parseUtilities._parseInternal.apply(null, arguments);
	            return Utils.parseUtilities._transformResult(data, { ModifiedAt: data.ModifiedAt });
	        },
	        parseJSON: function (json) {
	            return JSON.parse(json, Utils.parseUtilities.getReviver());
	        },
	        parseXhrResponse: function (xhrRequest) {
	            var type = xhrRequest.getResponseHeader('content-type');
	            var isJson = type && type.toLowerCase().indexOf('json') > -1;
	            var response = xhrRequest.responseText || xhrRequest.statusText;
	            return isJson ? Utils.parseUtilities.parseJSON(response) : response;
	        },
	        parseXhrError: function (reviver, xhrRequest) {
	            if (xhrRequest instanceof Error) {
	                return xhrRequest;
	            }
	            var message = xhrRequest.responseText || xhrRequest.statusText || xhrRequest;
	            return Utils.parseUtilities.parseError(reviver, message);
	        },
	        parseErrorOrResponse: function (error) {
	            if (error instanceof XMLHttpRequest) {
	                var parsedError = Utils.parseUtilities.parseXhrResponse(error);
	                //seems that parseXhrResponse is inconsistent
	                return {
	                    code: parsedError.code || parsedError.errorCode,
	                    message: parsedError.message
	                };
	            }
	            return Utils.parseUtilities.parseError(null, error);
	        }
	    };
	    return Utils;
	}());
	exports.Utils = Utils;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var EverliveError_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(2);
	var AutoQueue = (function () {
	    function AutoQueue(maxConcurrentTasks) {
	        var tasksNumber = maxConcurrentTasks || constants_1.Constants.MaxConcurrentDownloadTasks;
	        this.maxConcurrentTasks = parseInt(tasksNumber + '', 10);
	        if (_.isNaN(this.maxConcurrentTasks) || maxConcurrentTasks <= 0) {
	            throw new EverliveError_1.EverliveError({ message: 'The maxConcurrentTasks must be a number larger than 0' });
	        }
	        this.runningTasksCount = 0;
	        this.tasks = [];
	    }
	    /**
	     * @param {Function} task
	     * @param {Function} taskSuccess
	     * @param {Function} taskError
	     */
	    AutoQueue.prototype.enqueue = function (task, taskSuccess, taskError) {
	        this.tasks.push({
	            task: task,
	            args: [].splice.call(arguments, 3),
	            success: taskSuccess,
	            error: taskError
	        });
	        this.runNext();
	    };
	    AutoQueue.prototype.runNext = function () {
	        var self = this;
	        if (self.runningTasksCount === self.maxConcurrentTasks || !self.tasks.length) {
	            return;
	        }
	        self.runningTasksCount++;
	        var nextTask = this.tasks.shift();
	        var task = nextTask.task;
	        var args = nextTask.args;
	        var taskSuccess = nextTask.success;
	        var taskError = nextTask.error;
	        args.unshift(function executedCallback(err) {
	            self.runningTasksCount--;
	            if (err) {
	                taskError(err);
	            }
	            else {
	                taskSuccess.apply(null, [].splice.call(arguments, 1));
	            }
	            self.runNext();
	        });
	        task.apply(null, args);
	    };
	    return AutoQueue;
	}());
	exports.AutoQueue = AutoQueue;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Processor = __webpack_require__(179);
	var DataQuery_1 = __webpack_require__(15);
	var Query_1 = __webpack_require__(6);
	var AggregateQuery_1 = __webpack_require__(21);
	var constants_1 = __webpack_require__(2);
	exports.expandProcessor = new Processor({
	    executionNodeFunction: function (node, expandContext, done) {
	        var targetTypeName = node.targetTypeName.toLowerCase() === constants_1.Constants.FilesTypeNameLegacy ? constants_1.Constants.FilesTypeName : node.targetTypeName;
	        var query;
	        if (node.aggregate) {
	            query = new DataQuery_1.DataQuery({
	                operation: DataQuery_1.DataQuery.operations.Aggregate,
	                meta: {
	                    collectionName: targetTypeName
	                },
	                query: new AggregateQuery_1.AggregateQuery(node.filter, node.select, node.sort, node.skip, node.take, null, node.aggregate)
	            });
	        }
	        else {
	            query = new DataQuery_1.DataQuery({
	                operation: DataQuery_1.DataQuery.operations.Read,
	                meta: {
	                    collectionName: targetTypeName
	                },
	                query: new Query_1.Query(node.filter, node.select, node.sort, node.skip, node.take)
	            });
	        }
	        expandContext.offlineModule.processQuery(query).then(function (data) {
	            done(null, data.result);
	        }, done);
	    }
	});


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(4);
	var EverliveError_1 = __webpack_require__(3);
	var CurrentDevice_1 = __webpack_require__(66);
	var constants_1 = __webpack_require__(2);
	var buildPromise = utils_1.Utils.buildPromise;
	var Platform = constants_1.Constants.Platform;
	/**
	 * @class Push
	 * @classdesc A class for managing push notifications in your application. Supported are push notifications for hybrid apps on Android and iOS.
	 * @protected
	 * @param el {Everlive} Everlive Object
	 */
	var Push = (function () {
	    function Push(el) {
	        this.el = el;
	        this.notifications = el.data(constants_1.Constants.Push.NotificationsType);
	        this.devices = el.data(constants_1.Constants.Push.DevicesType);
	    }
	    /**
	     * Ensures that the Telerik Push Notifications plug-in has been loaded and is ready to use. An {EverliveError} is returned if the plug-in is not available.
	     * @method ensurePushIsAvailable
	     * @memberOf Push.prototype
	     */
	    Push.prototype.ensurePushIsAvailable = function () {
	        CurrentDevice_1.ensurePushIsAvailable();
	    };
	    /**
	      * Returns the current device for sending push notifications
	      * @deprecated since version 1.2.7
	      * @see [Push.register]{@link push.register}
	      * @memberOf Push.prototype
	      * @method currentDevice
	      * @name currentDevice
	      * @param [emulatorMode] {Boolean} If set to true, emulator mode is enabled meaning you cannot send push notifications.
	      * @returns {CurrentDevice} Returns an instance of CurrentDevice.
	      */
	    Push.prototype.currentDevice = function (emulatorMode) {
	        if (emulatorMode === void 0) { emulatorMode = false; }
	        this.ensurePushIsAvailable();
	        if (arguments.length === 0) {
	            emulatorMode = this.el.setup._emulatorMode;
	        }
	        if (!this._currentDevice) {
	            this._currentDevice = CurrentDevice_1.getCurrentDevice(this);
	        }
	        this._currentDevice.emulatorMode = emulatorMode || utils_1.Utils._inAppBuilderSimulator();
	        return this._currentDevice;
	    };
	    /**
	     * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
	     * @method register
	     * @name register
	     * @memberOf Push.prototype
	     * @param {Object} settings An object containing settings for the registration. It can include custom parameters to be stored by {{site.bs}}.
	     * @param {Object} settings.iOS=null iOS-specific settings.
	     * @param {Boolean} settings.iOS.alert=true If set to true, the push notification will display as a standard iOS alert.
	     * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
	     * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
	     * @param {Boolean} settings.iOS.sound=true If set to true, the device will play a notification sound.
	     * @param {Object} settings.android=null Android-specific settings.
	     * @param {String} settings.android.senderID=null Your Google API project number. It is required when obtaining a push token for an Android device.
	     * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
	     * @param {Object} settings.wp8=null Windows Phone specific settings.
	     * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
	     * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
	     * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
	     * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
	     * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
	     * Telerik Backend Services if it hasn't already been registered.
	     * If it was registered the registration details are updated.
	     * @method register
	     * @name register
	     * @memberOf Push.prototype
	     * @param {Object} settings Settings for the registration. Can include custom parameters to be saved in backend services.
	     * @param {Object} settings.iOS=null iOS specific settings
	     * @param {Boolean} settings.iOS.alert=true Specifies whether the device will display an alert message.
	     * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
	     * @param {Boolean} settings.iOS.clearBadge=false Specifies whether to reset the badge count to 0.
	     * @param {Boolean} settings.iOS.sound=true Specifies whether the device will play a sound.
	     * @param {Object} settings.android=null Android specific settings
	     * @param {String} settings.android.senderID=null This is your Google API project number. It is required when obtaining a push token for an Android device.
	     * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
	     * @param {Object} settings.wp8=null Windows Phone specific settings
	     * @param {String} settings.wp8.channelName=null The name of the push channel that the device is registering to.
	     * @param {Function} settings.notificationCallbackIOS Specifies a custom callback to be used when a push notification is received on iOS.
	     * @param {Function} settings.notificationCallbackAndroid Specifies a custom callback to be used when a push notification is received on Android.
	     * @param {Function} settings.notificationCallbackWP8 Specifies a custom callback to be used when a push notification is received on Windows Phone 8.
	     * @param {Object} settings.customParameters=null Specifies optional custom registration parameters that will be saved in Telerik Backend Services.
	     * @param {Function} [success] Callback to invoke on success.
	     * @param {Function} [error] Callback to invoke on error.
	     */
	    Push.prototype.register = function (settings, success, error) {
	        this.ensurePushIsAvailable();
	        var currentDevice = this.currentDevice();
	        var self = this;
	        settings = settings || {};
	        if (settings.android) {
	            settings.android.senderID = settings.android.projectNumber || settings.android.senderID;
	        }
	        var successCallback = function (token, callback) {
	            var result = new utils_1.DeviceRegistrationResult(token);
	            callback(result);
	        };
	        var errorCallback = function (err, callback) {
	            var registrationError = EverliveError_1.DeviceRegistrationError.fromEverliveError(err);
	            callback(registrationError);
	        };
	        var clearBadgeIfNeeded = function (token, successCb, errorCb) {
	            var platformType = currentDevice._getPlatformType();
	            var clearBadge = platformType === Platform.iOS;
	            if (clearBadge && settings.iOS) {
	                clearBadge = settings.iOS.clearBadge !== false;
	            }
	            if (clearBadge) {
	                self.clearBadgeNumber().then(function () {
	                    successCallback(token, successCb);
	                }, function (err) {
	                    errorCallback(err, errorCb);
	                });
	            }
	            else {
	                successCallback(token, successCb);
	            }
	        };
	        return buildPromise(function (successCb, errorCb) {
	            currentDevice.enableNotifications(settings, function (response) {
	                var token = response.token;
	                var customParameters = settings.customParameters;
	                currentDevice.getRegistration()
	                    .then(function () {
	                    currentDevice.updateRegistration(customParameters, function () {
	                        clearBadgeIfNeeded(token, successCb, errorCb);
	                    }, function (err) {
	                        errorCallback(err, errorCb);
	                    });
	                }, function (err) {
	                    if (err.code === 801) {
	                        currentDevice.register(customParameters, function () {
	                            clearBadgeIfNeeded(token, successCb, errorCb);
	                        }, errorCb);
	                    }
	                    else {
	                        errorCallback(err, errorCb);
	                    }
	                });
	            }, function (err) {
	                var deviceRegistrationError = EverliveError_1.DeviceRegistrationError.fromPluginError(err);
	                errorCb(deviceRegistrationError);
	            });
	        }, success, error);
	    };
	    /**
	     * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
	     * @method unregister
	     * @name unregister
	     * @memberOf Push.prototype
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
	     * This method invalidates any push tokens that were obtained for the device from the current application.
	     * The device will also be unregistered from Telerik Backend Services.
	     * @method unregister
	     * @name unregister
	     * @memberOf Push.prototype
	     * @param {Function} [onSuccess] Callback to invoke on success.
	     * @param {Function} [onError] Callback to invoke on error.
	     */
	    Push.prototype.unregister = function (onSuccess, onError) {
	        this.ensurePushIsAvailable();
	        var currentDevice = this.currentDevice();
	        return currentDevice.disableNotifications.apply(currentDevice, arguments);
	    };
	    /**
	     * Updates the registration of the current device.
	     * @method updateRegistration
	     * @name updateRegistration
	     * @memberOf Push.prototype
	     * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Updates the registration for the current device.
	     * @method updateRegistration
	     * @name updateRegistration
	     * @memberOf Push.prototype
	     * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
	     * @param {Function} [onSuccess] Callback to invoke on success.
	     * @param {Function} [onError] Callback to invoke on error.
	     */
	    Push.prototype.updateRegistration = function (customParameters, onSuccess, onError) {
	        this.ensurePushIsAvailable();
	        var currentDevice = this.currentDevice();
	        return currentDevice.updateRegistration.apply(currentDevice, arguments);
	    };
	    Push.prototype.setBadgeNumber = function (badge, onSuccess, onError) {
	        this.ensurePushIsAvailable();
	        badge = parseInt(badge);
	        if (isNaN(badge)) {
	            return buildPromise(function (success, error) {
	                error(new EverliveError_1.EverliveError({ message: 'The badge must have a numeric value' }));
	            }, onSuccess, onError);
	        }
	        var deviceRegistration = {};
	        var currentDevice = this.currentDevice();
	        var deviceId = currentDevice._getDeviceId();
	        deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceId);
	        deviceRegistration.BadgeCounter = badge;
	        return buildPromise(function (successCb, errorCb) {
	            currentDevice._pushHandler.devices.updateSingle(deviceRegistration).then(function () {
	                if (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification && !utils_1.Utils._inAppBuilderSimulator()) {
	                    return window.plugins.pushNotification.setApplicationIconBadgeNumber(successCb, errorCb, badge);
	                }
	                else {
	                    return successCb();
	                }
	            }, errorCb);
	        }, onSuccess, onError);
	    };
	    /**
	     * Resets the badge number on the {{site.TelerikBackendServices}} server to 0.
	     * @method clearBadgeNumber
	     * @name clearBadgeNumber
	     * @memberOf Push.prototype
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Clears the badge number on the server by setting it to 0
	     * @method clearBadgeNumber
	     * @name clearBadgeNumber
	     * @memberOf Push.prototype
	     * @param {Function} [onSuccess] Callback to invoke on success.
	     * @param {Function} [onError] Callback to invoke on error.
	     */
	    Push.prototype.clearBadgeNumber = function (onSuccess, onError) {
	        this.ensurePushIsAvailable();
	        return this.setBadgeNumber(0, onSuccess, onError);
	    };
	    /**
	     * Returns the push notifications registration for the current device.
	     * @method getRegistration
	     * @name getRegistration
	     * @memberOf Push.prototype
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Returns the push registration for the current device.
	     * @method getRegistration
	     * @name getRegistration
	     * @memberOf Push.prototype
	     * @param {Function} [onSuccess] Callback to invoke on success.
	     * @param {Function} [onError] Callback to invoke on error.
	     */
	    Push.prototype.getRegistration = function (onSuccess, onError) {
	        this.ensurePushIsAvailable();
	        var currentDevice = this.currentDevice();
	        return currentDevice.getRegistration.apply(currentDevice, arguments);
	    };
	    /**
	     * Sends a push notification.
	     * @method send
	     * @name send
	     * @memberOf Push.prototype
	     * @param {Object} notification The push notification object
	     * @returns {Promise} The promise for request.
	     */
	    /**
	     * Sends a push message
	     * @method send
	     * @name send
	     * @memberOf Push.prototype
	     * @param {Object} notification The push notification object
	     * @param {Function} [onSuccess] Callback to invoke on success.
	     * @param {Function} [onError] Callback to invoke on error.
	     */
	    Push.prototype.send = function (notification, onSuccess, onError) {
	        return this.notifications.create.apply(this.notifications, arguments);
	    };
	    /**
	     * This method provides a different operation on each supported platform:
	     *
	     * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
	     * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
	     * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
	     * @method areNotificationsEnabled
	     * @name areNotificationsEnabled
	     * @memberOf Push.prototype
	     * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
	     * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
	     * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
	     * @method areNotificationsEnabled
	     * @name areNotificationsEnabled
	     * @memberOf Push.prototype
	     * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
	     * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
	     * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
	     */
	    Push.prototype.areNotificationsEnabled = function (options, onSuccess, onError) {
	        this.ensurePushIsAvailable();
	        var currentDevice = this.currentDevice();
	        return currentDevice.areNotificationsEnabled(options, onSuccess, onError);
	    };
	    /**
	     * Currently available only for iOS
	     * Use this method in case you are working with iOS interactive push notifications in background mode, including TextInput, or iOS silent push notifications.
	     * Call it once you are done with processing your push notification in notificationCallbackIOS.
	     * @method notificationProcessed
	     * @name notificationProcessed
	     * @memberOf Push.prototype
	     */
	    Push.prototype.notificationProcessed = function () {
	        this.ensurePushIsAvailable();
	        var currentDevice = this.currentDevice();
	        currentDevice.notificationProcessed();
	    };
	    return Push;
	}());
	exports.Push = Push;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var CommonSetup_1 = __webpack_require__(133);
	var constants_1 = __webpack_require__(2);
	var AuthenticationSetup_1 = __webpack_require__(48);
	var Setup = (function (_super) {
	    __extends(Setup, _super);
	    function Setup(options) {
	        _super.call(this);
	        this._emulatorMode = false;
	        this.url = constants_1.Constants.everliveUrl;
	        this.appId = null;
	        this.masterKey = null;
	        this.token = null;
	        this.tokenType = null;
	        this.principalId = null;
	        this.scheme = 'http';
	        this.parseOnlyCompleteDateTimeObjects = false;
	        if (typeof options === 'string') {
	            this.appId = options;
	        }
	        else {
	            this._emulatorMode = options.emulatorMode;
	            _.extend(this, options);
	            if (options.apiKey) {
	                this.appId = options.apiKey; // backward compatibility
	            }
	        }
	        this.authentication = new AuthenticationSetup_1.AuthenticationSetup(this, options.authentication);
	    }
	    Setup.prototype.setAuthorizationProperties = function (token, tokenType, principalId) {
	        this.token = token;
	        this.tokenType = tokenType;
	        this.principalId = principalId;
	    };
	    Setup.prototype.getAuthorizationProperties = function () {
	        return {
	            token: this.token,
	            tokenType: this.tokenType,
	            principalId: this.principalId
	        };
	    };
	    return Setup;
	}(CommonSetup_1.CommonSetup));
	exports.Setup = Setup;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Constants_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(4);
	var constants_1 = __webpack_require__(2);
	var LocalStore_1 = __webpack_require__(35);
	var EverliveError_1 = __webpack_require__(3);
	var Data_1 = __webpack_require__(16);
	var buildPromise = utils_1.Utils.buildPromise;
	var getCallbacks = utils_1.Utils.getCallbacks;
	var Authentication = (function (_super) {
	    __extends(Authentication, _super);
	    /**
	     * @class Authentication
	     * @classdesc A class for managing authentication of a user in your application.
	     * @protected
	     * @param sdk {Everlive} Everlive Object
	     */
	    function Authentication(sdk) {
	        _super.call(this, sdk, 'Users');
	        this.authSetup = sdk.setup.authentication || {};
	        this._authenticationCallbacks = null;
	        if (this.authSetup.persist) {
	            this._localStore = new LocalStore_1.LocalStore(sdk);
	            var localStoreKey = this._getLocalStoreKey();
	            var authOptions = this._localStore.getItem(localStoreKey);
	            var authInfo = void 0;
	            if (authOptions) {
	                authInfo = JSON.parse(this._localStore.getItem(localStoreKey));
	            }
	            if (authInfo) {
	                this.sdk.setup.setAuthorizationProperties(authInfo.token, authInfo.tokenType, authInfo.principalId);
	            }
	        }
	    }
	    Authentication.prototype._getLocalStoreKey = function () {
	        return constants_1.Constants.AuthStoreKey + this.sdk.setup.appId + '$authentication';
	    };
	    /** Ensures that authentication is completed before continuing.
	     * @memberOf Authentication.prototype
	     * @private
	     * @returns {Promise} A promise that will be resolved when the authentication is complete. See {{@link Everlive.prototype.completeAuthentication}}.
	     * @throws throws an error if no onAuthenticationRequired handler is provided to the options.
	     */
	    Authentication.prototype._ensureAuthentication = function () {
	        if (!this.isAuthenticationInProgress()) {
	            throw new Error('onAuthenticationRequired option of Everlive.CommonSetup.Authentication is required.');
	        }
	        if (this.isAuthenticating()) {
	            return this._authenticationCallbacks.promise;
	        }
	        this.clearAuthorization();
	        this.authSetup.onAuthenticationRequired.call(this);
	        this._authenticationCallbacks = getCallbacks();
	        return this._authenticationCallbacks.promise;
	    };
	    Authentication.prototype._loginSuccess = function (data) {
	        var result = data.result;
	        this.setAuthorization(result.access_token, result.token_type, result.principal_id);
	    };
	    Authentication.prototype._logoutSuccess = function () {
	        this.clearAuthorization();
	    };
	    Authentication.prototype._loginWithProvider = function (identity, success, error) {
	        var _this = this;
	        var user = {
	            Identity: identity
	        };
	        var dataQuery = this.buildDataQuery(user, Constants_1.DataQueryOperation.UserLoginWithProvider);
	        return buildPromise(function (success, error) {
	            return _this.processDataQuery(dataQuery)
	                .then(function (data) {
	                _this._loginSuccess(data);
	                return success(data);
	            })
	                .catch(error);
	        }, success, error);
	    };
	    /**
	     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
	     * @memberOf Authentication.prototype
	     * @method login
	     * @name login
	     * @param {string} username The user's username.
	     * @param {string} password The user's password.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
	     * @memberOf Authentication.prototype
	     * @method login
	     * @name login
	     * @param {string} username The user's username.
	     * @param {string} password The user's password.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.login = function (username, password, success, error) {
	        var _this = this;
	        var grant_type = 'password';
	        var data = { grant_type: grant_type, username: username, password: password };
	        var dataQuery = this.buildDataQuery(data, Constants_1.DataQueryOperation.UserLogin);
	        return buildPromise(function (success, error) {
	            return _this.processDataQuery(dataQuery)
	                .then(function (data) {
	                _this._loginSuccess(data);
	                return success(data);
	            })
	                .catch(error);
	        }, success, error);
	    };
	    /**
	     * Log out the user who is currently logged in.
	     * @memberOf Authentication.prototype
	     * @method logout
	     * @name logout
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log out the user who is currently logged in.
	     * @memberOf Authentication.prototype
	     * @method logout
	     * @name logout
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.logout = function (success, error) {
	        var _this = this;
	        var dataQuery = this.buildDataQuery(null, Constants_1.DataQueryOperation.UserLogout);
	        return buildPromise(function (success, error) {
	            return _this.processDataQuery(dataQuery)
	                .then(function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i - 0] = arguments[_i];
	                }
	                _this._logoutSuccess();
	                return success.apply(void 0, args);
	            })
	                .catch(function (err) {
	                if (err.code === 301) {
	                    _this.clearAuthorization();
	                }
	                return error(err);
	            });
	        }, success, error);
	    };
	    /**
	     * Log in a user using an Facebook access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithFacebook
	     * @name loginWithFacebook
	     * @param {string} accessToken Facebook access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using an Facebook access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithFacebook
	     * @name loginWithFacebook
	     * @param {string} accessToken Facebook access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.loginWithFacebook = function (accessToken, success, error) {
	        var identity = {
	            Provider: 'Facebook',
	            Token: accessToken
	        };
	        return this._loginWithProvider(identity, success, error);
	    };
	    /**
	     * Log in a user using an ADFS access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithADFS
	     * @name loginWithADFS
	     * @param {string} accessToken ADFS access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using an ADFS access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithADFS
	     * @name loginWithADFS
	     * @param {string} accessToken ADFS access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.loginWithADFS = function (accessToken, success, error) {
	        var identity = {
	            Provider: 'ADFS',
	            Token: accessToken
	        };
	        return this._loginWithProvider(identity, success, error);
	    };
	    /**
	     * Log in a user using an SAML access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithSAML
	     * @name loginWithSAML
	     * @param {string} accessToken SAML access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using an SAML access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithSAML
	     * @name loginWithSAML
	     * @param {string} accessToken SAML access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.loginWithSAML = function (accessToken, success, error) {
	        var identity = {
	            Provider: 'SAML',
	            Token: accessToken
	        };
	        return this._loginWithProvider(identity, success, error);
	    };
	    ;
	    /**
	     * Log in a user using a LiveID access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithLiveID
	     * @name loginWithLiveID
	     * @param {string} accessToken LiveID access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using a LiveID access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithLiveID
	     * @name loginWithLiveID
	     * @param {string} accessToken LiveID access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.loginWithLiveID = function (accessToken, success, error) {
	        var identity = {
	            Provider: 'LiveID',
	            Token: accessToken
	        };
	        return this._loginWithProvider(identity, success, error);
	    };
	    /**
	     * Log in a user using a Google access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithGoogle
	     * @name loginWithGoogle
	     * @param {string} accessToken Google access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using a Google access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithGoogle
	     * @name loginWithGoogle
	     * @param {string} accessToken Google access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.loginWithGoogle = function (accessToken, success, error) {
	        var identity = {
	            Provider: 'Google',
	            Token: accessToken
	        };
	        return this._loginWithProvider(identity, success, error);
	    };
	    /**
	     * Log in a user with a Twitter token. A secret token needs to be provided.
	     * @memberOf Authentication.prototype
	     * @method loginWithTwitter
	     * @name loginWithTwitter
	     * @param {string} token Twitter token.
	     * @param {string} tokenSecret Twitter secret token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user with a Twitter token. A secret token needs to be provided.
	     * @memberOf Authentication.prototype
	     * @method loginWithTwitter
	     * @name loginWithTwitter
	     * @param {string} token Twitter token.
	     * @param {string} tokenSecret Twitter secret token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.loginWithTwitter = function (token, tokenSecret, success, error) {
	        var identity = {
	            Provider: 'Twitter',
	            Token: token,
	            TokenSecret: tokenSecret
	        };
	        return this._loginWithProvider(identity, success, error);
	    };
	    /**
	     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
	     * @memberOf Authentication.prototype
	     * @method setAuthorization
	     * @param {string} token Token that will be used for authorization.
	     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
	     * @param {string} principalId The id of the user that is logged in.
	     */
	    Authentication.prototype.setAuthorization = function (token, tokenType, principalId) {
	        this.sdk.setup.setAuthorizationProperties(token, tokenType, principalId);
	        if (this.authSetup.persist) {
	            var localStoreKey = this._getLocalStoreKey();
	            var authorizationProperties = this.sdk.setup.getAuthorizationProperties();
	            this._localStore.setItem(localStoreKey, JSON.stringify(authorizationProperties));
	        }
	        if (this._authenticationCallbacks) {
	            this._authenticationCallbacks.success();
	            this._authenticationCallbacks = null;
	        }
	    };
	    /**
	     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the authorization token that was used, will not be invalidated.
	     * @method clearAuthorization
	     * @memberOf Authentication.prototype
	     */
	    Authentication.prototype.clearAuthorization = function () {
	        this.setAuthorization(null, null, null);
	        this.clearPersistedAuthentication();
	    };
	    /**
	     * Clears the current persisted authentication from the local store for the current {{site.bs}} JavaScript SDK instance. Will not logout or modify the current authentication of the Javascript SDK.
	     * @method clearPersistedAuthentication
	     * @memberOf Authentication.prototype
	     */
	    Authentication.prototype.clearPersistedAuthentication = function () {
	        if (this._localStore) {
	            var localStoreKey = this._getLocalStoreKey();
	            this._localStore.removeItem(localStoreKey);
	            this.sdk.setup.setAuthorizationProperties(null, null, null);
	        }
	    };
	    /**
	     * @memberOf Authentication.prototype
	     * Returns whether authentication requirement is enabled for the current instance of the {{site.bs}} JavaScript SDK.
	     * @returns {boolean} whether an onAuthenticationRequired function is provided
	     */
	    Authentication.prototype.isAuthenticationInProgress = function () {
	        return typeof this.authSetup.onAuthenticationRequired === 'function';
	    };
	    /**
	     * A method that should be called with the authentication result.
	     * @memberOf Authentication.prototype
	     * @param authentication authentication object containing information about the
	     * @param authentication.access_token
	     * @param authentication.token_type
	     * @param authentication.principal_id
	     */
	    Authentication.prototype.completeAuthentication = function (authentication) {
	        this.sdk.authentication.setAuthorization(authentication.access_token, authentication.token_type, authentication.principal_id);
	    };
	    /**
	     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
	     * @memberOf Authentication.prototype
	     * @method getAuthenticationStatus
	     * @name getAuthenticationStatus
	     * @returns {Promise} A promise to the authentication status.
	     */
	    /**
	     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
	     * @memberOf Authentication.prototype
	     * @method getAuthenticationStatus
	     * @name getAuthenticationStatus
	     * @param {Everlive.Callbacks.authenticationStatusSuccess} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Authentication.prototype.getAuthenticationStatus = function (success, error) {
	        var _this = this;
	        return buildPromise(function (success, error) {
	            var setup = _this.sdk.setup;
	            if (setup.masterKey) {
	                return success({ status: constants_1.Constants.AuthStatus.masterKey });
	            }
	            if (!setup.token) {
	                return success({ status: constants_1.Constants.AuthStatus.unauthenticated });
	            }
	            if (_this.isAuthenticationInProgress()) {
	                return success({ status: constants_1.Constants.AuthStatus.authenticating });
	            }
	            return _this.sdk.users
	                .skipAuth(true)
	                .currentUser()
	                .then(function (res) {
	                return success({ status: constants_1.Constants.AuthStatus.authenticated, user: res.result });
	            }, function (err) {
	                if (_this.isAuthenticationInProgress()) {
	                    return success({ status: constants_1.Constants.AuthStatus.authenticating });
	                }
	                else if (err.code === EverliveError_1.EverliveErrors.invalidRequest.code || err.code === EverliveError_1.EverliveErrors.invalidToken.code) {
	                    return success({ status: constants_1.Constants.AuthStatus.invalidAuthentication });
	                }
	                else if (err.code === EverliveError_1.EverliveErrors.expiredToken.code) {
	                    return success({ status: constants_1.Constants.AuthStatus.expiredAuthentication });
	                }
	                else {
	                    return error(err);
	                }
	            });
	        }, success, error);
	    };
	    /** Returns whether the {{site.TelerikBackendServices}} is currently waiting for authentication to be completed. See {{@link Everlive.prototype.completeAuthentication}}.
	     * @memberOf Everlive.prototype
	     * @returns {boolean}
	     */
	    Authentication.prototype.isAuthenticating = function () {
	        return !!this._authenticationCallbacks;
	    };
	    return Authentication;
	}(Data_1.Data));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Authentication;


/***/ },
/* 48 */
/***/ function(module, exports) {

	"use strict";
	var AuthenticationSetup = (function () {
	    function AuthenticationSetup(setup, options) {
	        if (options === void 0) { options = {}; }
	        this.onAuthenticationRequired = options.onAuthenticationRequired;
	        this.persist = options.persist;
	        this.setup = setup;
	    }
	    return AuthenticationSetup;
	}());
	exports.AuthenticationSetup = AuthenticationSetup;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var path = __webpack_require__(13);
	var _ = __webpack_require__(1);
	var constants_1 = __webpack_require__(2);
	var EverliveError_1 = __webpack_require__(3);
	var Constants_1 = __webpack_require__(8);
	var utils_1 = __webpack_require__(4);
	var ProcessableObject_1 = __webpack_require__(96);
	var BusinessLogic = (function (_super) {
	    __extends(BusinessLogic, _super);
	    /**
	     * @class BusinessLogic
	     * @classdesc A class for invoking your app's Business Logic such as Cloud Functions and Stored Procedures.
	     * @protected
	     * @param sdk {Everlive} The sdk instance
	     */
	    function BusinessLogic(sdk) {
	        _super.call(this, sdk, 'BusinessLogic');
	    }
	    BusinessLogic._isValidFuncName = function (name) {
	        return _.isString(name) && name !== '';
	    };
	    /**
	     * Invokes a Cloud Function from the app's Business Logic layer.
	     * @method invokeCloudFunction
	     * @memberOf BusinessLogic.prototype
	     * @param {String} funcName The name of the function to invoke.
	     * @param {Object} params An object containing all invocation request parameters.
	     * @param {HttpMethod} [params.method=GET] HTTP request method.
	     * @param {Object} [params.queryStringParams] Parameters to be passed in the query string.
	     * @param {Object} [params.data] Data to be sent with the request.
	     * @param {Boolean} [params.authHeaders=true] Whether to send the credentials of the currently logged-in user.
	     * @param {Object} [params.headers] Additional headers to be sent with the request.
	     * @param {Object} [params.customParameters] Custom parameters to be sent with the request. They will be accessible in the Cloud Function code.
	     * @returns {Promise} A promise resolved on successful response and rejected on error response.
	     */
	    /**
	     * Invokes a Cloud Function from the app's Business Logic layer.
	     * @method invokeCloudFunction
	     * @memberOf BusinessLogic.prototype
	     * @param {String} funcName The name of the function to invoke.
	     * @param {Object} params An object containing all invocation request parameters.
	     * @param {HttpMethod} [params.method=GET] HTTP request method.
	     * @param {Object} [params.queryStringParams] Parameters to be passed in the query string.
	     * @param {Object} [params.data] Data to be sent with the request.
	     * @param {Boolean} [params.authHeaders=true] Whether to send the credentials of the currently logged-in user.
	     * @param {Object} [params.headers] Additional headers to be sent with the request.
	     * @param {Object} [params.customParameters] Custom parameters to be sent with the request. They will be accessible in the Cloud Function code.
	     * @param {Function} success Success callback function.
	     * @param {Function} error Error callback function.
	     */
	    BusinessLogic.prototype.invokeCloudFunction = function (funcName, params, success, error) {
	        if (!BusinessLogic._isValidFuncName(funcName)) {
	            var err = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.invalidOrMissingFunctionName);
	            return utils_1.Utils.callbackAndPromiseErrorResponse(err, error);
	        }
	        var parameters = _.extend({
	            method: constants_1.Constants.HttpMethod.GET,
	            success: success,
	            error: error
	        }, params);
	        if (parameters.method.toUpperCase() === constants_1.Constants.HttpMethod.GET && _.size(parameters.data)) {
	            var err = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.bodyWithGetRequestNotSupported);
	            return utils_1.Utils.callbackAndPromiseErrorResponse(err, error);
	        }
	        parameters.endpoint = path.join(constants_1.Constants.cloudFuncsEndpoint, funcName);
	        return this._invokeFunction(parameters, Constants_1.DataQueryOperation.InvokeCloudFunction);
	    };
	    /**
	     * Invokes a Stored Procedure from the app's Business Logic layer.
	     * @method invokeStoredProcedure
	     * @memberOf BusinessLogic.prototype
	     * @param {String} funcName The name of the Stored Procedure to invoke.
	     * @param {Object} funcParams Parameters to be passed to the Stored Procedure.
	     * @returns {Promise} A promise resolved on successful response and rejected on error response.
	     */
	    /**
	     * Invokes a Stored Procedure from the app's Business Logic layer.
	     * @method invokeStoredProcedure
	     * @memberOf BusinessLogic.prototype
	     * @param {String} funcName The name of the stored procedure to invoke.
	     * @param {Object} funcParams Parameters to be passed to the Stored Procedure.
	     * @param {Function} success Success callback function.
	     * @param {Function} error Error callback function.
	     */
	    BusinessLogic.prototype.invokeStoredProcedure = function (funcName, funcParams, success, error) {
	        if (!BusinessLogic._isValidFuncName(funcName)) {
	            var err = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.invalidOrMissingProcedureName);
	            return utils_1.Utils.callbackAndPromiseErrorResponse(err, error);
	        }
	        var reqParams = {
	            method: constants_1.Constants.HttpMethod.POST,
	            endpoint: path.join(constants_1.Constants.sqlProceduresEndpoint, funcName),
	            data: funcParams || {},
	            success: success,
	            error: error
	        };
	        return this._invokeFunction(reqParams, Constants_1.DataQueryOperation.InvokeStoredProcedure);
	    };
	    BusinessLogic.prototype._invokeFunction = function (params, operation) {
	        var customParameters = params.customParameters, method = params.method, endpoint = params.endpoint, success = params.success, error = params.error;
	        var additionalOptions = _.extend({
	            customParameters: customParameters,
	            method: method,
	            endpoint: endpoint,
	            authHeaders: true,
	            isCustomRequest: true
	        }, params);
	        var dataQuery = this.buildDataQuery({ additionalOptions: additionalOptions }, operation, {
	            collectionName: this.collectionName
	        });
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    return BusinessLogic;
	}(ProcessableObject_1.ProcessableObject));
	exports.BusinessLogic = BusinessLogic;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var jsonStringify = __webpack_require__(147);
	var constants_1 = __webpack_require__(2);
	var utils_1 = __webpack_require__(4);
	var RequestService_1 = __webpack_require__(10);
	var offlinePersisters_1 = __webpack_require__(19);
	var offline_1 = __webpack_require__(29);
	var EverliveError_1 = __webpack_require__(3);
	var cacheableOperations = [
	    constants_1.DataQueryOperation.Read,
	    constants_1.DataQueryOperation.ReadById,
	    constants_1.DataQueryOperation.Count
	];
	/**
	 * @class CacheModule
	 * @classDesc A class providing access to the various caching features.
	 */
	/**
	 * Represents the {@link CacheModule} class.
	 * @memberOf Everlive.prototype
	 * @member {CacheModule} cache
	 */
	var CacheModule = (function () {
	    function CacheModule(options, _everlive) {
	        this.options = options;
	        this._everlive = _everlive;
	        this.typeSettings = this.options.typeSettings;
	        this.maxAgeInMs = this.options.maxAgeInMs;
	    }
	    CacheModule.prototype._hash = function (obj) {
	        return jsonStringify(obj);
	    };
	    CacheModule.prototype._initStore = function (sdkOptions) {
	        if (!this.persister) {
	            var offlineStorageOptions = offline_1.buildOfflineStorageOptions(sdkOptions);
	            var storageKey = this.options.storage.storagePath + '_' + sdkOptions.appId;
	            this.persister = offlinePersisters_1.getPersister(storageKey, offlineStorageOptions);
	        }
	    };
	    CacheModule.prototype._getCacheData = function () {
	        var self = this;
	        if (!this.cacheData) {
	            return this._persisterGetAllDataWrap()
	                .then(function (cacheData) {
	                self.cacheData = cacheData;
	                return self.cacheData;
	            });
	        }
	        return utils_1.Utils.successfulPromise(this.cacheData);
	    };
	    CacheModule.prototype._persisterGetAllDataWrap = function () {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            return self.persister.getAllData(resolve, reject);
	        });
	    };
	    CacheModule.prototype._persisterSaveDataWrap = function (contentType, data) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            return self.persister.saveData(contentType, JSON.stringify(data), resolve, reject);
	        });
	    };
	    CacheModule.prototype._getCacheDataForContentType = function (contentType) {
	        return this._getCacheData()
	            .then(function (cacheData) {
	            if (typeof cacheData[contentType] === 'string') {
	                cacheData[contentType] = JSON.parse(cacheData[contentType]);
	            }
	            else {
	                cacheData[contentType] = cacheData[contentType] || {};
	            }
	            return _.clone(cacheData[contentType]);
	        });
	    };
	    //TODO: this method is copied from the cache query processor. It is used in Data.ts -> _applyQueryOnline.
	    //This one is not expected to be working ATM
	    CacheModule.prototype._cacheDataQuery = function (query) {
	        var shouldSkipCache = this._everlive.cache._shouldSkipCache(query);
	        if (shouldSkipCache) {
	            if (query.ignoreCache && !this._everlive.cache.isQueryUnsupportedOffline(query)) {
	                var hash = this._everlive.cache._getHashForQuery(query);
	                return this._everlive.cache._cacheQuery(query, hash, null);
	            }
	            else {
	                return RequestService_1.RequestService.handleRequestProcessing(query, null);
	            }
	        }
	        else {
	            query.useCache = false;
	            return this._everlive.cache._processCacheItem(query, null);
	        }
	    };
	    CacheModule.prototype._persistCacheData = function (contentType, cacheData) {
	        var self = this;
	        return this._getCacheDataForContentType(contentType)
	            .then(function () {
	            var dataToCache = _.extend({}, self.cacheData[contentType], cacheData);
	            self.cacheData[contentType] = _.compactObject(dataToCache);
	            return self._persisterSaveDataWrap(contentType, self.cacheData[contentType]);
	        });
	    };
	    CacheModule.prototype.isQueryUnsupportedOffline = function (dataQuery) {
	        var hasPowerfieldsExpression = !!dataQuery.getHeader(constants_1.Constants.Headers.powerFields);
	        var queryParams = dataQuery.getQueryParameters();
	        var dataQueryFilter = queryParams.filter;
	        var unsupportedDbOperators = utils_1.Utils.getUnsupportedOperators(dataQueryFilter);
	        var hasUnsupportedOperators = unsupportedDbOperators.length !== 0;
	        return hasPowerfieldsExpression || hasUnsupportedOperators;
	    };
	    CacheModule.prototype._shouldSkipCache = function (dataQuery) {
	        var operationShouldSkipCache = cacheableOperations.indexOf(dataQuery.operation) === -1;
	        var collectionName = dataQuery.collectionName;
	        var typeSettings = this.typeSettings;
	        var cacheDisabledForContentType = typeSettings && typeSettings && typeSettings[collectionName]
	            && typeSettings[collectionName].enabled === false;
	        var ignoreCacheForQuery = dataQuery.ignoreCache;
	        var isUnsupportedOffline = this.isQueryUnsupportedOffline(dataQuery);
	        var isForCurrentUser = dataQuery.additionalOptions && dataQuery.additionalOptions.id === 'me';
	        return operationShouldSkipCache || cacheDisabledForContentType || isForCurrentUser || ignoreCacheForQuery
	            || isUnsupportedOffline;
	    };
	    CacheModule.prototype._processCacheItem = function (dataQuery, data) {
	        var self = this;
	        var contentType = dataQuery.collectionName;
	        var hash = this._getHashForQuery(dataQuery);
	        return self._getCacheDataForContentType(contentType)
	            .then(function (cacheData) {
	            if (cacheData[hash]) {
	                return self._isHashExpired(contentType, hash, dataQuery.maxAge)
	                    .then(function (isExpired) {
	                    if (isExpired && !dataQuery.forceCache) {
	                        return self._purgeForHash(contentType, hash)
	                            .then(function () {
	                            return self._cacheQuery(dataQuery, hash, data);
	                        });
	                    }
	                    else {
	                        //If cache is used, change 'me' to the ID of the logged in user (only for currentUser() requests).
	                        if (dataQuery.operation === constants_1.DataQueryOperation.ReadById && dataQuery.additionalOptions.id === 'me') {
	                            dataQuery.additionalOptions.id = self._everlive.setup.principalId;
	                        }
	                        return self._everlive.offlineStorage.processQuery(dataQuery);
	                    }
	                });
	            }
	            else {
	                return self._cacheQuery(dataQuery, hash, data);
	            }
	        });
	    };
	    CacheModule.prototype._addObjectToCache = function (obj, contentType) {
	        var itemHash = obj.Id;
	        return this._cacheResultFromDataQuery(contentType, itemHash);
	    };
	    CacheModule.prototype._cacheQuery = function (dataQuery, hash, data) {
	        var self = this;
	        var contentType = dataQuery.collectionName;
	        var promise = new Promise(function (resolve, reject) {
	            var result;
	            return RequestService_1.RequestService.handleRequestProcessing(dataQuery, data)
	                .then(function (response) {
	                result = response.result || response;
	                return self._getCacheData();
	            }).then(function success() {
	                var cacheForItems = [];
	                var resultToCache = result.Result || result;
	                if (dataQuery.operation !== constants_1.DataQueryOperation.Count) {
	                    if (Array.isArray(resultToCache)) {
	                        _.each(resultToCache, function (singleResult) {
	                            var cacheItemPromise = self._addObjectToCache(singleResult, contentType);
	                            cacheForItems.push(cacheItemPromise);
	                        });
	                    }
	                    else if (_.isObject(resultToCache)) {
	                        var cacheItemPromise = self._addObjectToCache(resultToCache, contentType);
	                        cacheForItems.push(cacheItemPromise);
	                    }
	                }
	                return Promise.all(cacheForItems);
	            }).then(function success() {
	                if (dataQuery.operation !== constants_1.DataQueryOperation.Count) {
	                    return self._cacheResultFromDataQuery(contentType, hash);
	                }
	            }).then(function success() {
	                resolve(result);
	            }).catch(function (err) {
	                reject(err);
	            });
	        });
	        return promise;
	    };
	    CacheModule.prototype._cacheResultFromDataQuery = function (contentType, hash) {
	        var cacheData = {};
	        cacheData[hash] = {
	            cachedAt: Date.now()
	        };
	        return this._persistCacheData(contentType, cacheData);
	    };
	    CacheModule.prototype._getExpirationForHash = function (contentType, hash) {
	        return this._getCacheDataForContentType(contentType)
	            .then(function (cacheData) {
	            return cacheData[hash].cachedAt;
	        });
	    };
	    CacheModule.prototype._isHashExpired = function (contentType, hash, maxAge) {
	        var self = this;
	        return this._getExpirationForHash(contentType, hash)
	            .then(function (cachedAt) {
	            var maxAgeForContentType = self.typeSettings && self.typeSettings[contentType] ?
	                self.typeSettings[contentType].maxAge * 60 * 1000 : null;
	            var cacheAge;
	            if (maxAge || maxAge === 0) {
	                cacheAge = maxAge;
	            }
	            else if (maxAgeForContentType || maxAgeForContentType === 0) {
	                cacheAge = maxAgeForContentType;
	            }
	            else {
	                cacheAge = self.maxAgeInMs;
	            }
	            return (cachedAt + cacheAge) < Date.now();
	        });
	    };
	    CacheModule.prototype._purgeForHash = function (contentType, hash) {
	        var cacheData = {};
	        cacheData[hash] = null;
	        return this._persistCacheData(contentType, cacheData);
	    };
	    CacheModule.prototype._getHashForQuery = function (dataQuery) {
	        if (dataQuery.operation === constants_1.DataQueryOperation.ReadById) {
	            return dataQuery.additionalOptions.id;
	        }
	        var queryParams = dataQuery.getQueryParameters();
	        return this._hash(queryParams);
	    };
	    /**
	     * Clears the cached data for a specified content type.
	     * @method clear
	     * @name clear
	     * @param {string} contentType The content type to clear.
	     * @memberOf CacheModule.prototype
	     * @returns {Promise}
	     */
	    /**
	     * Clears the cached data for a specified content type.
	     * @method clear
	     * @name clear
	     * @param {string} contentType The content type to clear.
	     * @memberOf CacheModule.prototype
	     * @param {function} [success] A success callback.
	     * @param {function} [error] An error callback.
	     */
	    CacheModule.prototype.clear = function (contentType, success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            if (!self.options.enabled) {
	                var errorMessage = EverliveError_1.EverliveErrorHelper.buildCacheDisabledErrorMessage('clear');
	                return error(new EverliveError_1.EverliveError({ message: errorMessage, code: EverliveError_1.EverliveErrors.cacheDisabled.code }));
	            }
	            return self.persister.purge(contentType, function () {
	                if (self.cacheData && self.cacheData[contentType]) {
	                    delete self.cacheData[contentType];
	                }
	                if (self._everlive.offlineStorage.options.enabled) {
	                    success();
	                }
	                else {
	                    self._everlive.offlineStorage.queryProcessor.persister.purge(contentType, success, error);
	                }
	            }, error);
	        }, success, error);
	    };
	    /**
	     * Clears all data from the cache.
	     * @method clearAll
	     * @name clearAll
	     * @memberOf CacheModule.prototype
	     * @returns {Promise}
	     */
	    /**
	     * Clears all data from the cache.
	     * @method clearAll
	     * @name clearAll
	     * @memberOf CacheModule.prototype
	     * @param {function} [success] A success callback.
	     * @param {function} [error] An error callback.
	     */
	    CacheModule.prototype.clearAll = function (success, error) {
	        var self = this;
	        self.cacheData = null;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            if (self.options.enabled === false) {
	                var errorMessage = EverliveError_1.EverliveErrorHelper.buildCacheDisabledErrorMessage('clearAll');
	                return error(new EverliveError_1.EverliveError({ message: errorMessage, code: EverliveError_1.EverliveErrors.cacheDisabled.code }));
	            }
	            return self.persister.purgeAll(function () {
	                if (self._everlive.offlineStorage.options.enabled) {
	                    success();
	                }
	                else {
	                    self._everlive.offlineStorage.queryProcessor.persister.purgeAll(success, error);
	                }
	            }, error);
	        }, success, error);
	    };
	    return CacheModule;
	}());
	exports.CacheModule = CacheModule;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(1);
	var CacheModule_1 = __webpack_require__(50);
	var getDefaultOptions = function () {
	    return {
	        maxAge: 60,
	        enabled: false,
	        storage: {
	            storagePath: 'el_cache'
	        }
	    };
	};
	function initCaching(options, sdk) {
	    var cachingOptions;
	    var defaultOptions = getDefaultOptions();
	    if (options.caching === true) {
	        cachingOptions = _.deepExtend({}, defaultOptions);
	        cachingOptions.enabled = true;
	    }
	    else {
	        cachingOptions = _.deepExtend(defaultOptions, options.caching);
	    }
	    if (options.caching !== false) {
	        sdk.setup.caching = cachingOptions;
	    }
	    sdk.cache = new CacheModule_1.CacheModule(cachingOptions, sdk);
	}
	exports.initCaching = initCaching;
	function initStore(options, sdk) {
	    sdk.cache._initStore(options);
	}
	exports.initStore = initStore;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var underscore_1 = __webpack_require__(1);
	var DataQueryBuilder_1 = __webpack_require__(98);
	var Constants_1 = __webpack_require__(8);
	var DataQuery_1 = __webpack_require__(15);
	var Query_1 = __webpack_require__(6);
	var constants_1 = __webpack_require__(2);
	var Headers = constants_1.Constants.Headers;
	var DataQueryBuilder = (function (_super) {
	    __extends(DataQueryBuilder, _super);
	    function DataQueryBuilder() {
	        _super.apply(this, arguments);
	    }
	    DataQueryBuilder.prototype._getInitialDataQuery = function (operation, meta) {
	        return new DataQuery_1.DataQuery({ meta: meta, operation: operation });
	    };
	    DataQueryBuilder.prototype._isOperationAllowed = function (operations, operation) {
	        return underscore_1.contains(operations, operation);
	    };
	    DataQueryBuilder.prototype._buildQuery = function (filterOrQuery) {
	        if (!filterOrQuery) {
	            return null;
	        }
	        if (filterOrQuery instanceof Query_1.Query) {
	            return filterOrQuery;
	        }
	        else {
	            return new Query_1.Query(filterOrQuery);
	        }
	    };
	    DataQueryBuilder.prototype._tryBuildQuery = function (op, data) {
	        var operations = DataQueryBuilder._tryBuildQueryAllowedOperations;
	        if (!this._isOperationAllowed(operations, op)) {
	            return null;
	        }
	        var query = underscore_1.has(data, 'query') ? data.query : data;
	        return this._buildQuery(query);
	    };
	    DataQueryBuilder.prototype._tryGetData = function (op, data) {
	        var operations = DataQueryBuilder._tryGetDataAllowedOperations;
	        if (!this._isOperationAllowed(operations, op)) {
	            return null;
	        }
	        //TODO: this will not quite work if the user wants to create an item with a "data" field for example.
	        var fields = DataQueryBuilder._tryGetDataFields;
	        var field = underscore_1.find(fields, function (field) { return underscore_1.has(data, field); });
	        if (field) {
	            return data[field];
	        }
	        return data;
	    };
	    DataQueryBuilder.prototype._isAuthenticationOperation = function (op) {
	        return op === Constants_1.DataQueryOperation.UserLogin ||
	            op === Constants_1.DataQueryOperation.UserLogout ||
	            op === Constants_1.DataQueryOperation.UserLoginWithProvider ||
	            op === Constants_1.DataQueryOperation.UserLinkWithProvider ||
	            op === Constants_1.DataQueryOperation.UserUnlinkFromProvider;
	    };
	    DataQueryBuilder.prototype._isCloudCodeOperation = function (op) {
	        return op === Constants_1.DataQueryOperation.InvokeCloudFunction ||
	            op === Constants_1.DataQueryOperation.InvokeStoredProcedure;
	    };
	    DataQueryBuilder.prototype._applyOperationSpecificProperties = function (op, query) {
	        if (op === Constants_1.DataQueryOperation.UserLoginWithProvider) {
	            query.authHeaders = false;
	        }
	        else if (this._isCloudCodeOperation(op)) {
	            var _a = query.additionalOptions, customParameters = _a.customParameters, authHeaders = _a.authHeaders;
	            query.authHeaders = authHeaders;
	            if (customParameters) {
	                query.headers = underscore_1.extend(query.headers, (_b = {},
	                    _b[Headers.customParameters] = JSON.stringify(customParameters),
	                    _b
	                ));
	            }
	        }
	        if (this._isAuthenticationOperation(op)) {
	            query.skipAuth = true;
	        }
	        return query;
	        var _b;
	    };
	    DataQueryBuilder.prototype.buildDataQuery = function (data, op, meta) {
	        var dataQuery = _super.prototype.buildDataQuery.call(this, data, op, meta);
	        if (dataQuery.query) {
	            return dataQuery;
	        }
	        //null causes invalid request body
	        dataQuery.query = this._tryBuildQuery(op, data) || undefined;
	        dataQuery.data = this._tryGetData(op, data) || undefined;
	        this._applyOperationSpecificProperties(op, dataQuery);
	        return dataQuery;
	    };
	    DataQueryBuilder._tryBuildQueryAllowedOperations = [
	        Constants_1.DataQueryOperation.Read,
	        Constants_1.DataQueryOperation.ReadById,
	        Constants_1.DataQueryOperation.Count,
	        Constants_1.DataQueryOperation.Aggregate,
	        Constants_1.DataQueryOperation.SetAcl,
	        Constants_1.DataQueryOperation.Update,
	        Constants_1.DataQueryOperation.SetOwner,
	        Constants_1.DataQueryOperation.Delete,
	        Constants_1.DataQueryOperation.DeleteById,
	        Constants_1.DataQueryOperation.RawUpdate
	    ];
	    DataQueryBuilder._tryGetDataAllowedOperations = [
	        Constants_1.DataQueryOperation.Create,
	        Constants_1.DataQueryOperation.RawUpdate,
	        Constants_1.DataQueryOperation.Update,
	        Constants_1.DataQueryOperation.SetOwner,
	        Constants_1.DataQueryOperation.UserLogin,
	        Constants_1.DataQueryOperation.UserLoginWithProvider,
	        Constants_1.DataQueryOperation.FilesUpdateContent,
	        Constants_1.DataQueryOperation.UserResetPassword,
	        Constants_1.DataQueryOperation.UserSetPassword,
	        Constants_1.DataQueryOperation.UserChangePassword,
	        Constants_1.DataQueryOperation.UserLinkWithProvider,
	        Constants_1.DataQueryOperation.UserUnlinkFromProvider
	    ];
	    DataQueryBuilder._tryGetDataFields = [
	        'updateObject',
	        'data'
	    ];
	    return DataQueryBuilder;
	}(DataQueryBuilder_1.DataQueryBuilder));
	exports.DataQueryBuilder = DataQueryBuilder;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var node_cryptojs_aes_1 = __webpack_require__(128);
	var AES = node_cryptojs_aes_1.CryptoJS.AES;
	var CryptographicProvider = (function () {
	    function CryptographicProvider(options) {
	        if (options === void 0) { options = {}; }
	        this.options = options;
	    }
	    CryptographicProvider.prototype._getKey = function () {
	        return this.options.encryption.key;
	    };
	    CryptographicProvider.prototype._canEncryptDecrypt = function (content) {
	        return this._getKey() && content !== null && content !== undefined;
	    };
	    CryptographicProvider.prototype.encrypt = function (content) {
	        if (!this._canEncryptDecrypt(content)) {
	            return content;
	        }
	        return AES.encrypt(content, this._getKey()).toString();
	    };
	    CryptographicProvider.prototype.decrypt = function (content) {
	        if (!this._canEncryptDecrypt(content)) {
	            return content;
	        }
	        return AES.decrypt(content, this._getKey()).toString(node_cryptojs_aes_1.CryptoJS.enc.Utf8);
	    };
	    return CryptographicProvider;
	}());
	exports.CryptographicProvider = CryptographicProvider;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @class Helpers
	 * @classdesc Everlive helper classes
	 */
	"use strict";
	var platform = __webpack_require__(5);
	var htmlHelper_1 = __webpack_require__(55);
	exports.helpers = [];
	if (platform.isCordova || platform.isDesktop) {
	    exports.helpers.push({
	        name: 'html',
	        ctor: htmlHelper_1.HtmlHelper
	    });
	}


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var EventEmitterExtended_1 = __webpack_require__(40);
	var utils_1 = __webpack_require__(4);
	var htmlHelperResponsiveModule_1 = __webpack_require__(57);
	var htmlHelperOfflineModule_1 = __webpack_require__(56);
	var constants_1 = __webpack_require__(2);
	var EverliveError_1 = __webpack_require__(3);
	var defaults = {
	    processOnLoad: false,
	    processOnResize: false,
	    loadingImageUrl: '',
	    errorImageUrl: '',
	    attributes: {
	        loadingImage: 'data-loading-image',
	        errorImage: 'data-error-image',
	        dpi: 'data-dpi',
	        imageSource: 'data-src',
	        fileSource: 'data-href',
	        enableOffline: 'data-offline',
	        enableResponsive: 'data-responsive'
	    },
	    responsiveParams: {}
	};
	/**
	 * @typedef Helpers.html
	 * @description Everlive helper for html related operations, such as processing html elements with specific tags.
	 */
	var HtmlHelper = (function (_super) {
	    __extends(HtmlHelper, _super);
	    function HtmlHelper(sdk, config) {
	        _super.call(this);
	        this.sdk = sdk;
	        this.settings = {
	            urlTemplate: '[protocol][hostname][appid]/[operations][url]',
	            server: 'bs1.cdn.telerik.com/image/v1/'
	        };
	        config = config || {};
	        this.options = _.extend({}, defaults, config);
	        this.options.attributes = _.extend({}, defaults.attributes, config.attributes);
	        this.options.responsiveParams = _.extend({}, defaults.responsiveParams, config.responsiveParams);
	        this.responsive = new htmlHelperResponsiveModule_1.HtmlHelperResponsiveModule(this);
	        this.offline = new htmlHelperOfflineModule_1.HtmlHelperOfflineModule(this);
	        this._init();
	    }
	    HtmlHelper.prototype._init = function () {
	        var self = this;
	        if (self.options.processOnLoad) {
	            window.addEventListener('load', this.processAll.bind(this), false);
	        }
	        if (this.options.processOnResize) {
	            window.addEventListener('resize', _.debounce(this.processAll.bind(this), 300), false);
	        }
	    };
	    HtmlHelper.prototype._triggerOnProcessed = function (args) {
	        this.emit(constants_1.Constants.Events.Processed, args);
	    };
	    HtmlHelper.prototype._defaultProcessSettings = function (settings) {
	        return _.defaults({}, settings, {
	            responsive: true,
	            offline: true
	        });
	    };
	    HtmlHelper.prototype._setLoadingUrl = function (element) {
	        var loadingImageUri = element.getAttribute(this.options.attributes.loadingImage) || this.options.loadingImageUrl;
	        if (!loadingImageUri || utils_1.Utils.isElement.anchor(element)) {
	            return utils_1.Utils.successfulPromise();
	        }
	        return this._setUrl(element, loadingImageUri, true);
	    };
	    HtmlHelper.prototype._getBackgroundSrc = function (el) {
	        var elStyle = window.getComputedStyle(el, null);
	        var backgrImage = elStyle.getPropertyValue('background-image');
	        var img = backgrImage !== 'none' ? backgrImage : false;
	        if (img) {
	            img = img.replace(/url\(('?"?)(.*?)\1\)/gi, '$2');
	        }
	        return img;
	    };
	    HtmlHelper.prototype._setErrorUrl = function (element) {
	        var errorImageUrl = element.getAttribute(this.options.attributes.errorImage) || this.options.errorImageUrl;
	        if (!errorImageUrl || utils_1.Utils.isElement.anchor(element)) {
	            return utils_1.Utils.successfulPromise();
	        }
	        return this._setUrl(element, errorImageUrl, true);
	    };
	    HtmlHelper.prototype._setUrl = function (element, url, apply) {
	        if (apply === void 0) { apply = false; }
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            var elAttr = self._getAttr(element);
	            if (utils_1.Utils.isElement.image(element) && elAttr === self.options.attributes.imageSource) {
	                if (apply) {
	                    element.src = url;
	                    element.style.visibility = 'visible';
	                }
	                else {
	                    var img = new Image();
	                    img.onerror = function () {
	                        img = null;
	                        reject(new EverliveError_1.EverliveError({ message: "Can't be loaded: " + url }));
	                    };
	                    img.onload = function () {
	                        img = null;
	                        self._setUrl(element, url, true)
	                            .then(resolve)
	                            .catch(reject);
	                    };
	                    img.src = url;
	                }
	            }
	            else {
	                apply = true;
	                if (elAttr) {
	                    var attr;
	                    if (elAttr === self.options.attributes.imageSource) {
	                        attr = 'src';
	                    }
	                    else if (elAttr === self.options.attributes.fileSource) {
	                        attr = 'href';
	                    }
	                    else {
	                        attr = _.last(elAttr.split('-'));
	                    }
	                    element.setAttribute(attr, url);
	                }
	                else {
	                    element.style.backgroundImage = 'url(' + url + ')';
	                }
	            }
	            if (apply) {
	                resolve();
	            }
	        });
	    };
	    HtmlHelper.prototype._getAttr = function (element) {
	        if (element.getAttribute(this.options.attributes.imageSource)) {
	            return this.options.attributes.imageSource;
	        }
	        if (element.getAttribute(this.options.attributes.fileSource)) {
	            return this.options.attributes.fileSource;
	        }
	    };
	    HtmlHelper.prototype._getUrl = function (element) {
	        var url = element.getAttribute(this.options.attributes.imageSource)
	            || element.getAttribute(this.options.attributes.fileSource)
	            || this._getBackgroundSrc(element);
	        return url;
	    };
	    HtmlHelper.prototype._wrapElements = function (elements) {
	        var self = this;
	        var results = _.map(elements, function (element) {
	            var tag = element.tagName.toLowerCase();
	            var evaluateDataAttr = function evaluateDataAttr(attr) {
	                // data-a - true
	                // data-a="" - true
	                // data-a="true" - true
	                // data-a="anything" - true
	                // data-a="false" - false
	                // missing - false
	                var val;
	                var dataVal = (element.attributes[attr] || { value: null }).value;
	                if (dataVal === '') {
	                    val = true;
	                }
	                else if (!dataVal) {
	                    val = false;
	                }
	                else {
	                    try {
	                        val = JSON.parse(dataVal);
	                    }
	                    catch (e) {
	                        val = true;
	                    }
	                }
	                return val;
	            };
	            var canResponsive = evaluateDataAttr(self.options.attributes.enableResponsive);
	            var canOffline = evaluateDataAttr(self.options.attributes.enableOffline);
	            return {
	                item: element,
	                tag: tag,
	                operations: {
	                    responsive: canResponsive,
	                    offline: canOffline
	                }
	            };
	        });
	        return results;
	    };
	    /**
	     * @method process
	     * @memberOf Helpers.html
	     * @param {HtmlElement|HtmlElement[]} elements
	     * @param {Object} settings A settings specifying custom behavior.
	     * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
	     * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    /**
	     * @method process
	     * @memberOf Helpers.html
	     * @param {HtmlElement|HtmlElement[]} elements
	     * @param {Object} settings A settings specifying custom behavior.
	     * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
	     * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
	     * @returns {Promise} A promise to the process state.
	     */
	    HtmlHelper.prototype.process = function (elements, settings, success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (resolve) {
	            settings = self._defaultProcessSettings(settings);
	            if (_.isArray(elements) || elements instanceof NodeList || elements.length) {
	                elements = _.flatten(elements);
	            }
	            else {
	                elements = [elements];
	            }
	            var wrappedElements = self._wrapElements(elements);
	            var promises = [];
	            _.each(wrappedElements, function (element) {
	                var result = {
	                    element: element.item,
	                    responsive: false,
	                    offline: false
	                };
	                var dataUrl = self._getUrl(result.element);
	                if (!dataUrl) {
	                    return promises.push(utils_1.Utils.successfulPromise(result));
	                }
	                var canResponsive = settings.responsive ? element.operations.responsive : false;
	                var canOffline = settings.offline ? element.operations.offline : false;
	                if (!canResponsive && !canOffline) {
	                    return promises.push(self._setUrl(result.element, dataUrl, true)
	                        .then(function () {
	                        return result;
	                    }));
	                }
	                var promise = self._setLoadingUrl(result.element);
	                var handleOperation = function handleOperation(operation, url) {
	                    if (url) {
	                        result[operation] = true;
	                        return url;
	                    }
	                };
	                if (canResponsive) {
	                    promise = promise.then(function () {
	                        return self.responsive.responsiveImage(element, dataUrl)
	                            .then(handleOperation.bind(this, 'responsive'));
	                    });
	                }
	                if (canOffline) {
	                    promise = promise.then(function (responsiveSrc) {
	                        return self.offline.processOffline(responsiveSrc || dataUrl)
	                            .then(handleOperation.bind(this, 'offline'));
	                    });
	                }
	                promise = promise.then(function (finalUrl) {
	                    return self._setUrl(result.element, finalUrl)
	                        .then(function () {
	                        return result;
	                    });
	                }).catch(function (err) {
	                    return self._setErrorUrl(result.element)
	                        .then(function () {
	                        throw {
	                            element: result.element,
	                            error: err
	                        };
	                    });
	                });
	                promises.push(promise);
	            });
	            utils_1.Utils.promisesAllSettled(promises)
	                .then(function (results) {
	                var processed = [];
	                var failed = [];
	                _.each(results, function (result) {
	                    if (result.state === 'fulfilled') {
	                        processed.push(result.value);
	                    }
	                    else {
	                        failed.push(result.reason);
	                    }
	                });
	                var result = {
	                    processed: processed,
	                    failed: failed
	                };
	                self._triggerOnProcessed(result);
	                resolve(result);
	            });
	        }, success, error);
	    };
	    /**
	     * @method processAll
	     * @memberOf Helpers.html
	     * @param {Object} settings A settings specifying custom behavior.
	     * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
	     * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    /**
	     * @method processAll
	     * @memberOf Helpers.html
	     * @param {Object} settings A settings specifying custom behavior.
	     * @param {boolean} [settings.responsive] Whether to process the data-responsive attributes that help implement Responsive Images.
	     * @param {boolean} [settings.offline] Whether to process the data-offline attributes that help implement offline files.
	     * @returns {Promise} A promise to the process state.
	     */
	    HtmlHelper.prototype.processAll = function (settings, success, error) {
	        settings = this._defaultProcessSettings(settings);
	        var responsiveSelector = '[' + this.options.attributes.enableResponsive + ']';
	        var offlineSelector = '[' + this.options.attributes.enableOffline + ']';
	        var responsiveElements = [];
	        if (settings.responsive) {
	            responsiveElements = document.querySelectorAll(responsiveSelector);
	        }
	        var offlineElements = [];
	        if (settings.offline) {
	            offlineElements = document.querySelectorAll(offlineSelector);
	        }
	        var slice = [].slice;
	        var elements = _.unique(slice.call(responsiveElements).concat(slice.call(offlineElements)));
	        return this.process(elements, settings, success, error);
	    };
	    return HtmlHelper;
	}(EventEmitterExtended_1.EventEmitterExtended));
	exports.HtmlHelper = HtmlHelper;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var path = __webpack_require__(13);
	var _ = __webpack_require__(1);
	var utils_1 = __webpack_require__(4);
	var EverliveError_1 = __webpack_require__(3);
	var HtmlHelperOfflineModule = (function () {
	    function HtmlHelperOfflineModule(htmlHelper) {
	        this.htmlHelper = htmlHelper;
	    }
	    HtmlHelperOfflineModule.prototype.processOffline = function (url) {
	        var self = this;
	        if (!self.htmlHelper.sdk.offlineStorage.files) {
	            return utils_1.Utils.rejectedPromise(new EverliveError_1.EverliveError({ message: 'Offline storage must be enabled in order to use the offline features of the images component.' }));
	        }
	        return self.htmlHelper.sdk.offlineStorage.files.downloadOffline(url)
	            .then(function (localUrl) {
	            return localUrl;
	        })
	            .catch(function (err) {
	            if (err.code !== EverliveError_1.EverliveErrors.cannotDownloadOffline.code) {
	                throw err;
	            }
	            return self.htmlHelper.sdk.offlineStorage.offlineFilesProcessor
	                .getOfflineFilesData()
	                .then(function (offlineFilesData) {
	                var basename = path.basename(url);
	                var oldFile = _.find(offlineFilesData, function (entry) {
	                    if (entry.onlineLocation && entry.offlineLocation) {
	                        var onlineLocation = entry.onlineLocation;
	                        var basenameIndex = onlineLocation.lastIndexOf(basename);
	                        return basenameIndex !== -1;
	                    }
	                });
	                if (oldFile) {
	                    return oldFile.offlineLocation;
	                }
	                throw new EverliveError_1.EverliveError({ message: "Cannot find offline image " + url, code: EverliveError_1.EverliveErrors.missingOrInvalidFileContent.code });
	            });
	        });
	    };
	    return HtmlHelperOfflineModule;
	}());
	exports.HtmlHelperOfflineModule = HtmlHelperOfflineModule;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var utils_1 = __webpack_require__(4);
	var DEFAULT_RESPONSIVE_OPERATIONS = {
	    params: {
	        resize: {}
	    },
	    isUserResize: false
	};
	var HtmlHelperResponsiveModule = (function () {
	    function HtmlHelperResponsiveModule(htmlHelper) {
	        this.htmlHelper = htmlHelper;
	    }
	    HtmlHelperResponsiveModule.prototype.getBackgroundWidth = function (el) {
	        return Math.ceil(el.offsetWidth);
	    };
	    HtmlHelperResponsiveModule.prototype.getBackgroundHeight = function (el) {
	        return Math.ceil(el.offsetHeight);
	    };
	    HtmlHelperResponsiveModule.prototype.parseParamsString = function (str) {
	        if (!str || typeof str === 'undefined' || str.length <= 1) {
	            return DEFAULT_RESPONSIVE_OPERATIONS;
	        }
	        var params = str.split('/');
	        var result = {};
	        var isUserResize = false;
	        //TODO: Perhaps the conversion from query string to object and vice versa could go in utils, since it may be useful in other places?
	        _.chain(params)
	            .filter(function (param) {
	            return !!param;
	        }) //TODO: I think there's a function in lodash called "compact", which does this.
	            .each(function (param) {
	            var paramPair = param.split('=');
	            var paramName = paramPair[0];
	            var paramValues = paramPair[1];
	            paramValues = unescape(paramValues.replace(/\+/g, ' '));
	            result[paramName] = paramValues;
	            if (paramName === 'resize') {
	                isUserResize = true;
	            }
	        });
	        return {
	            params: result,
	            isUserResize: isUserResize
	        };
	    };
	    HtmlHelperResponsiveModule.prototype.getImgParams = function (src, el) {
	        var self = this;
	        var operations;
	        var imgUrl = src.replace(/.*?resize=[^//]*\//gi, '');
	        var protocolRe = new RegExp('https?://', 'gi');
	        var serverRe = new RegExp(this.htmlHelper.settings.server, 'gi');
	        var apiIdRe = new RegExp(this.htmlHelper.sdk.appId + '/', 'gi');
	        var operationsRaw = src.replace(imgUrl, '').replace(protocolRe, '').replace(serverRe, '').replace(apiIdRe, '').toLowerCase();
	        if (operationsRaw !== '') {
	            var operationsToParse = operationsRaw.indexOf('/') ? operationsRaw.substring(0, operationsRaw.length - 1) : operationsRaw;
	            //TODO: I'm hazy on the context, but... If operationsToParse starts with "/", we parse it "as is",
	            //if not, I guess it's expected to have it in the end and it's truncated? Is it
	            //impossible to not have a "/" at all and cut the last symbol when maybe it shouldn't be cut?
	            operations = this.parseParamsString(operationsToParse);
	        }
	        else if (el.dataset.responsiveParams) {
	            operations = DEFAULT_RESPONSIVE_OPERATIONS;
	            _.each(el.dataset.responsiveParams.split(','), function (key) {
	                var pair = key.split(':');
	                var param = pair[0];
	                var value = pair[1];
	                operations.params.resize[param] = value;
	            });
	        }
	        else {
	            operations = DEFAULT_RESPONSIVE_OPERATIONS;
	        }
	        _.chain(this.htmlHelper.options.responsiveParams).keys().each(function (key) {
	            var value = self.htmlHelper.options.responsiveParams[key];
	            operations.params.resize[key] = value;
	        });
	        // If it's a user resize operation, use the passed url in the data-src property
	        if (operations.isUserResize) {
	            imgUrl = src;
	        }
	        return {
	            imgUrl: imgUrl,
	            operations: operations.params,
	            isUserResize: operations.isUserResize
	        };
	    };
	    HtmlHelperResponsiveModule.prototype.hasClass = function (el, cl) {
	        var regex = new RegExp('(?:\\s|^)' + cl + '(?:\\s|$)');
	        return !!el.className.match(regex);
	    };
	    HtmlHelperResponsiveModule.prototype.getImageWidth = function (el) {
	        var parentEl = el.parentNode;
	        if (parentEl) {
	            var parentWidth = parentEl.offsetWidth;
	            var itemStyle = window.getComputedStyle(parentEl, null);
	            var pl = parseFloat(itemStyle.getPropertyValue('padding-left'));
	            var pr = parseFloat(itemStyle.getPropertyValue('padding-right'));
	            var bl = parseFloat(itemStyle.getPropertyValue('border-left-width'));
	            var br = parseFloat(itemStyle.getPropertyValue('border-right-width'));
	            return Math.abs(parentWidth - Math.ceil(pl + pr + bl + br));
	        }
	        return 0;
	    };
	    HtmlHelperResponsiveModule.prototype.getImageHeight = function (el) {
	        var parentEl = el.parentNode;
	        if (parentEl) {
	            var parentHeight = parentEl.offsetHeight;
	            var itemStyle = window.getComputedStyle(parentEl, null);
	            var pt = parseFloat(itemStyle.getPropertyValue('padding-top'));
	            var pb = parseFloat(itemStyle.getPropertyValue('padding-bottom'));
	            var bt = parseFloat(itemStyle.getPropertyValue('border-top-width'));
	            var bb = parseFloat(itemStyle.getPropertyValue('border-bottom-width'));
	            return Math.abs(parentHeight - Math.ceil(pt + pb + bt + bb));
	        }
	        return 0;
	    };
	    HtmlHelperResponsiveModule.prototype.getDevicePixelRatio = function () {
	        return window.devicePixelRatio ? window.devicePixelRatio : 1;
	    };
	    HtmlHelperResponsiveModule.prototype.getPixelRatio = function (el) {
	        var pixelDensity = el.getAttribute(this.htmlHelper.options.attributes.dpi) || '';
	        return pixelDensity !== '' ? _.isNumber(pixelDensity) ? parseFloat(pixelDensity) : false : this.getDevicePixelRatio();
	    };
	    HtmlHelperResponsiveModule.prototype.getImgParamsString = function (params) {
	        var paramsStr = 'resize=';
	        _.chain(params.resize).keys().each(function (paramName, index, arr) {
	            paramsStr += (paramName + ':' + params.resize[paramName]);
	            if (index < arr.length - 1) {
	                paramsStr += ',';
	            }
	            else {
	                paramsStr += '/';
	            }
	        });
	        return paramsStr;
	    };
	    HtmlHelperResponsiveModule.prototype.responsiveImage = function (item, dataSrc) {
	        var self = this;
	        var image = _.extend({}, item);
	        var element = image.item;
	        var tag = image.tag;
	        var isImage = utils_1.Utils.isElement.image(tag);
	        var imgWidth;
	        image = _.extend({}, image, self.getImgParams(dataSrc, item.item));
	        if (!image.isUserResize) {
	            imgWidth = isImage ? self.getImageWidth(element) : self.getBackgroundWidth(element);
	        }
	        imgWidth = imgWidth ? imgWidth : false;
	        var src = image.isUserResize ? image.imgUrl : self.getImgSrc(image, imgWidth);
	        return new Promise(function (resolve) {
	            if (!imgWidth && !image.isUserResize) {
	                // if this element is not visible, we don't have to process it.
	                return resolve();
	            }
	            return resolve(src);
	        });
	    };
	    HtmlHelperResponsiveModule.prototype.getImgSrc = function (image, imgWidth) {
	        var protocol = this.htmlHelper.sdk.setup.scheme + '://';
	        var appId = this.htmlHelper.sdk.setup.appId;
	        var server = this.htmlHelper.settings.server;
	        var url = this.htmlHelper.settings.urlTemplate;
	        var pixelDensity = this.getPixelRatio(image.item);
	        url = url.replace('[protocol]', protocol);
	        url = url.replace('[appid]', appId || '');
	        url = url.replace('[hostname]', server);
	        var params = image.operations || false;
	        var paramsString;
	        if (params) {
	            var operations = '';
	            params.resize = params.resize || {};
	            params.resize.w = imgWidth;
	            params.resize.pd = pixelDensity;
	            var fill = params.resize.fill;
	            if (fill === 'cover' || fill === 'contain') {
	                //for fill:cover, we need both the width and height of the image
	                params.resize.h = this.getImageHeight(image.item) || this.getBackgroundHeight(image.item);
	            }
	            paramsString = this.getImgParamsString(params);
	        }
	        else {
	            var defaultParams = {
	                resize: {
	                    w: imgWidth,
	                    pd: pixelDensity
	                }
	            };
	            paramsString = this.getImgParamsString(defaultParams);
	        }
	        url = url.replace('[operations]', paramsString);
	        url = url.replace('[url]', image.imgUrl);
	        return url;
	    };
	    return HtmlHelperResponsiveModule;
	}());
	exports.HtmlHelperResponsiveModule = HtmlHelperResponsiveModule;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	//kendo.everlive adds some kendo methods to the Everlive prototype, if they are not used they cause no harm
	var Everlive_1 = __webpack_require__(27);
	exports.Everlive = Everlive_1.Everlive;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var utils_1 = __webpack_require__(4);
	var _ = __webpack_require__(1);
	var QueryBuilder_1 = __webpack_require__(22);
	var Query_1 = __webpack_require__(6);
	var AggregateQuery_1 = __webpack_require__(21);
	var constants_1 = __webpack_require__(2);
	var Everlive_1 = __webpack_require__(27);
	var Sdk_1 = __webpack_require__(135);
	var operations = {
	    read: 'read',
	    update: 'update',
	    destroy: 'destroy',
	    create: 'create'
	};
	var $;
	var kendo;
	var extend;
	var aggrSeparator;
	var everliveTransport;
	(function () {
	    if (typeof window === 'undefined' || typeof window.jQuery === 'undefined' || typeof window.kendo === 'undefined' || _.isEmpty(window.kendo.data)) {
	        return;
	    }
	    $ = window.jQuery;
	    kendo = window.kendo;
	    extend = $.extend;
	    aggrSeparator = '_';
	    everliveTransport = kendo.data.RemoteTransport.extend({
	        init: function (options) {
	            this.everlive$ = options.dataProvider || Everlive_1.Everlive.$;
	            this._subscribeToSdkEvents(options);
	            if (!this.everlive$) {
	                throw new Error('An instance of the Backend services sdk must be provided.');
	            }
	            if (!options.typeName) {
	                throw new Error('A type name must be provided.');
	            }
	            this.headers = options.headers;
	            this.dataCollection = this.everlive$.data(options.typeName);
	            kendo.data.RemoteTransport.fn.init.call(this, options);
	        },
	        read: function (options) {
	            var methodOption = this.options['read'];
	            var self = this;
	            if (methodOption && methodOption.url) {
	                return kendo.data.RemoteTransport.fn.read.call(this, options);
	            }
	            var methodHeaders;
	            if (methodOption && methodOption.headers) {
	                methodHeaders = methodOption.headers;
	            }
	            var query = translateKendoQuery(options.data);
	            var everliveQuery = new Query_1.Query(query.$where, null, query.$sort, query.$skip, query.$take);
	            var id = options.data.Id;
	            if (id) {
	                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).getById(id).then(options.success, options.error);
	            }
	            else {
	                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).get(everliveQuery)
	                    .then(function (getResult) {
	                    return self._readServAggregates(getResult, query, options, methodHeaders);
	                })
	                    .then(options.success).catch(options.error);
	            }
	        },
	        update: function (options) {
	            var methodOption = this.options['update'];
	            if (methodOption && methodOption.url) {
	                return kendo.data.RemoteTransport.fn.read.call(this, options);
	            }
	            var methodHeaders;
	            if (methodOption && methodOption.headers) {
	                methodHeaders = methodOption.headers;
	            }
	            var isMultiple = _.isArray(options.data.models);
	            if (isMultiple) {
	                throw new Error('Batch update is not supported.');
	            }
	            else {
	                var itemForUpdate = options.data;
	                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).updateSingle(itemForUpdate)
	                    .then(options.success.bind(this, itemForUpdate), options.error).catch(options.error);
	            }
	        },
	        create: function (options) {
	            var methodOption = this.options['create'];
	            if (methodOption && methodOption.url) {
	                return kendo.data.RemoteTransport.fn.read.call(this, options);
	            }
	            var methodHeaders;
	            if (methodOption && methodOption.headers) {
	                methodHeaders = methodOption.headers;
	            }
	            var isMultiple = _.isArray(options.data.models);
	            var createData = isMultiple ? options.data.models : options.data;
	            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).create(createData)
	                .then(options.success.bind(this, createData), options.error).catch(options.error);
	        },
	        destroy: function (options) {
	            var methodOption = this.options['destroy'];
	            if (methodOption && methodOption.url) {
	                return kendo.data.RemoteTransport.fn.read.call(this, options);
	            }
	            var methodHeaders;
	            if (methodOption && methodOption.headers) {
	                methodHeaders = methodOption.headers;
	            }
	            var isMultiple = _.isArray(options.data.models);
	            if (isMultiple) {
	                throw new Error('Batch destroy is not supported.');
	            }
	            var removeFilter = {
	                Id: options.data.Id
	            };
	            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).destroySingle(removeFilter)
	                .then(options.success, options.error).catch(options.error);
	        },
	        _subscribeToSdkEvents: function (options) {
	            var self = this;
	            _.map(operations, function (op) {
	                if (options && options[op] && typeof options[op].beforeSend === 'function') {
	                    var listener = options[op].beforeSend;
	                    self.everlive$.on(constants_1.Constants.Events.BeforeExecute, listener);
	                }
	            });
	        },
	        _readServAggregates: function (result, query, options, methodHeaders) {
	            if (options.data.aggregate) {
	                if (!options.data.hasOwnProperty('filter') && !query.$where) {
	                    throw new Error("The serverFiltering option must be enabled, when using serverAggregates.");
	                }
	                var aggregateQuery = new AggregateQuery_1.AggregateQuery(query.$where, null, query.$sort, query.$skip, query.$take);
	                _transformAggregatesKendoToEverlive(options.data.aggregate, aggregateQuery);
	                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).aggregate(aggregateQuery)
	                    .then(function (data) {
	                    var aggrResult = _transformAggregatesEverliveToKendo(options.data.aggregate, data.result[0]); // only 1 result is expected from server for aggregates, as KendoAggregates are actually totals
	                    $.extend(true, result, { aggregates: aggrResult });
	                    return result;
	                })
	                    .catch(options.error);
	            }
	            else {
	                return result;
	            }
	        }
	    });
	    $.extend(true, kendo.data, {
	        transports: {
	            everlive: everliveTransport
	        },
	        schemas: {
	            everlive: {
	                type: 'json',
	                total: function (data) {
	                    return data.hasOwnProperty('count') ? data.count : data.Count;
	                },
	                data: function (data) {
	                    return data.result || utils_1.Utils.parseUtilities.traverseAndRevive(data.Result) || data;
	                },
	                model: {
	                    id: constants_1.Constants.idField
	                },
	                aggregates: 'aggregates'
	            }
	        }
	    });
	})();
	function translateKendoQuery(data) {
	    var result = {};
	    if (data) {
	        if (data.skip) {
	            result.$skip = data.skip;
	            delete data.skip;
	        }
	        if (data.take) {
	            result.$take = data.take;
	            delete data.take;
	        }
	        if (data.sort) {
	            var sortExpressions = data.sort;
	            var sort = {};
	            if (!$.isArray(sortExpressions)) {
	                sortExpressions = [sortExpressions];
	            }
	            $.each(sortExpressions, function (idx, value) {
	                sort[value.field] = value.dir === 'asc' ? 1 : -1;
	            });
	            result.$sort = sort;
	            delete data.sort;
	        }
	        if (data.filter) {
	            result.$where = filterBuilder.build(data.filter);
	            delete data.filter;
	        }
	    }
	    return result;
	}
	var regexOperations = ['startswith', 'startsWith', 'endswith', 'endsWith', 'contains'];
	var filterBuilder = {
	    build: function (filter) {
	        return filterBuilder._build(filter);
	    },
	    _build: function (filter) {
	        if (filterBuilder._isRaw(filter)) {
	            return filterBuilder._raw(filter);
	        }
	        else if (filterBuilder._isSimple(filter)) {
	            return filterBuilder._simple(filter);
	        }
	        else if (filterBuilder._isRegex(filter)) {
	            return filterBuilder._regex(filter);
	        }
	        else if (filterBuilder._isAnd(filter)) {
	            return filterBuilder._and(filter);
	        }
	        else if (filterBuilder._isOr(filter)) {
	            return filterBuilder._or(filter);
	        }
	    },
	    _isRaw: function (filter) {
	        return filter.operator === '_raw';
	    },
	    _raw: function (filter) {
	        var fieldTerm = {};
	        fieldTerm[filter.field] = filter.value;
	        return fieldTerm;
	    },
	    _isSimple: function (filter) {
	        return typeof filter.logic === 'undefined' && !filterBuilder._isRegex(filter);
	    },
	    _simple: function (filter) {
	        var term = {}, fieldTerm = {};
	        var operator = filterBuilder._translateoperator(filter.operator);
	        if (operator) {
	            term[operator] = filter.value;
	        }
	        else {
	            term = filter.value;
	        }
	        fieldTerm[filter.field] = term;
	        return fieldTerm;
	    },
	    _isRegex: function (filter) {
	        return $.inArray(filter.operator, regexOperations) !== -1;
	    },
	    _regex: function (filter) {
	        var fieldTerm = {};
	        var regex = filterBuilder._getRegex(filter);
	        fieldTerm[filter.field] = filterBuilder._getRegexValue(regex);
	        return fieldTerm;
	    },
	    _getRegex: function (filter) {
	        var pattern = filter.value;
	        var filterOperator = filter.operator;
	        switch (filterOperator) {
	            case 'contains':
	                return new RegExp(".*" + pattern + ".*", "i");
	            case 'startsWith': // removing the camel case operators will be a breaking change
	            case 'startswith':
	                return new RegExp("^" + pattern, "i");
	            case 'endsWith':
	            case 'endswith':
	                return new RegExp(pattern + '$', 'i');
	        }
	        throw new Error('Unknown operator type.');
	    },
	    _getRegexValue: function (regex) {
	        return QueryBuilder_1.QueryBuilder.prototype._getRegexValue.call(this, regex);
	    },
	    _isAnd: function (filter) {
	        return filter.logic === 'and';
	    },
	    _and: function (filter) {
	        var i, l, term, result = { $and: [] };
	        var operands = filter.filters;
	        for (i = 0, l = operands.length; i < l; i++) {
	            term = filterBuilder._build(operands[i]);
	            result.$and.push(term);
	        }
	        return result;
	    },
	    _isOr: function (filter) {
	        return filter.logic === 'or';
	    },
	    _or: function (filter) {
	        var i, l, term, result = [];
	        var operands = filter.filters;
	        for (i = 0, l = operands.length; i < l; i++) {
	            term = filterBuilder._build(operands[i]);
	            result.push(term);
	        }
	        return { $or: result };
	    },
	    _translateoperator: function (operator) {
	        switch (operator) {
	            case 'eq':
	                return null;
	            case 'neq':
	                return '$ne';
	            case 'gt':
	                return '$gt';
	            case 'lt':
	                return '$lt';
	            case 'gte':
	                return '$gte';
	            case 'lte':
	                return '$lte';
	        }
	        throw new Error('Unknown operator type.');
	    }
	};
	/**
	 * Creates a new Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) that manages a certain Backend Services content type.
	 * Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) is used in conjunction with other Kendo UI widgets (such as [ListView](http://docs.telerik.com/kendo-ui/web/listview/overview) and [Grid](http://docs.telerik.com/kendo-ui/web/grid/overview)) to provide an easy way to render data from Backend Services.
	 * *including Kendo UI scripts is required*.
	 * @param options data source options. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
	 * @param options.transport.typeName The content type name in Backend Services that will be managed.
	 * @returns {DataSource} A new instance of Kendo UI DataSource. See the Kendo UI documentation for [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more information.
	 * @example ```js
	 * var booksDataSource = Everlive.createDataSource({
	     *   transport: {
	     *     typeName: 'Books'
	     *   }
	     * });
	 * ```
	 */
	var createDataSource = function (options) {
	    if (options === void 0) { options = {}; }
	    return Everlive_1.Everlive.$.getKendoDataSource(options.typeName, options);
	};
	exports.createDataSource = createDataSource;
	/**
	 * Creates a new Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) that manages a certain Backend Services content type and can expand a chain of relations.
	 * Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) is used in conjunction with other Kendo UI widgets (such as [TreeView](http://docs.telerik.com/kendo-ui/web/treeview/overview)) to render data from Backend Services in a structured way.
	 * The chain of relations is defined by specifying the field names that contain the relation on each level. For example a generic hierarchy chain is a content type 'Continents' with relation to 'Countries', which in turn contains a relation to 'Towns'.
	 * *including Kendo UI scripts is required*.
	 * @param options data source Options for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
	 * @param options.typeName Name of the main content type for the data source.
	 * @param {ExpandDefinition[]} options.expand An array of expand definitions. It defines the levels of hierarchy by specifying the relation fields. An expand definition can either be the field name as a **string**, or an **object** that allows additional options.
	 * @param {string} ExpandDefinition - The field name of the relation that will be expanded. Only supported in online mode.
	 * @param {string} ExpandDefinition.relation - *Required*. The field name of the relation that will be expanded.
	 * @param {string} ExpandDefinition.typeName - *Required in offline mode*. The type name of the relation that will be expanded.
	 * @param {object} ExpandDefinition.filter - An object specifying the filter expression.
	 * @param {object} ExpandDefinition.sort - An object specifying the sort expression.
	 * @param {object} ExpandDefinition.skip - A number specifying the skip value.
	 * @param {object} ExpandDefinition.take - A number specifying the take value.
	 * @param {object} ExpandDefinition.fields - An object specifying the fields expression.
	 * @returns {HierarchicalDataSource} A new instance of Kendo UI HierarchicalDataSource. See the Kendo UI documentation for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
	 * @example ```js
	 * var el = new Everlive('your-api-key-here');
	 * var continents = Everlive.createHierarchicalDataSource({
	 *   'typeName': 'Continents',
	 *   'expand': ['Countries', 'Towns']
	 * });
	 *
	 * ...
	 * ('#treeview').kendoTreeView({
	 *   dataSource: continents,
	 *   dataTextField: ['ContinentName', 'CountryName', 'TownName']
	 * });
	 * ```
	 */
	var createHierarchicalDataSource = function (options) {
	    if (options === void 0) { options = {}; }
	    var typeName = options.typeName;
	    var everlive$ = options.dataProvider || Everlive_1.Everlive.$;
	    if (!everlive$) {
	        throw new Error('You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.');
	    }
	    if (!typeName) {
	        throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
	    }
	    return everlive$.getHierarchicalDataSource(typeName, options);
	};
	exports.createHierarchicalDataSource = createHierarchicalDataSource;
	var KendoSdk = (function (_super) {
	    __extends(KendoSdk, _super);
	    function KendoSdk() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Get a Kendo UI DataSource that is attached to the current instance of the SDK with default options.
	     * @method getKendoDataSource
	     * @memberOf Everlive.prototype
	     * @param {String} typeName The corresponding type name for the DataSource.
	     * @param {Object} [options] Additional DataSource options.
	     * @returns {DataSource}
	     */
	    KendoSdk.prototype.getKendoDataSource = function (typeName, options) {
	        if (options === void 0) { options = {}; }
	        var everlive$ = options.dataProvider || Everlive_1.Everlive.$;
	        if (!everlive$) {
	            throw new Error('You need to instantiate an Everlive instance in order to create a Kendo UI DataSource.');
	        }
	        if (!typeName) {
	            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI DataSource.");
	        }
	        if (options.serverGrouping) {
	            throw new Error("serverGrouping is not supported.");
	        }
	        if (options.serverAggregates && !options.serverFiltering) {
	            throw new Error("The serverFiltering option must be enabled, when using serverAggregates.");
	        }
	        var defaultEverliveOptions = {
	            type: 'everlive',
	            transport: {
	                typeName: typeName,
	                dataProvider: this
	            }
	        };
	        var options = _.defaults(defaultEverliveOptions, options);
	        return new kendo.data.DataSource(options);
	    };
	    /**
	     * Get a Kendo UI HierarchicalDataSource that is attached to the current instance of the SDK with default options.
	     * @method getHierarchicalDataSource
	     * @memberOf Everlive.prototype
	     * @param {String} typeName The corresponding type name for the DataSource.
	     * @param {Object} [dataSourceOptions] Additional DataSource options that describe the hierarchical structure.
	     * @returns {HierarchicalDataSource}
	     */
	    KendoSdk.prototype.getHierarchicalDataSource = function (typeName, dataSourceOptions) {
	        if (dataSourceOptions === void 0) { dataSourceOptions = {}; }
	        var expand = dataSourceOptions.expand || dataSourceOptions;
	        delete dataSourceOptions.expand;
	        if (!typeName) {
	            throw new Error("You need to specify a 'typeName' in order to create a Kendo UI HierarchicalDataSource.");
	        }
	        if (!$.isArray(expand)) {
	            throw new Error("You need to set 'expand' array option in order to create a Kendo UI HierarchicalDataSource");
	        }
	        var baseUrl = utils_1.Utils.buildUrl(this.setup) + typeName;
	        var expandSchema;
	        var isOfflineStorageEnabled = utils_1.Utils.isOfflineStorageEnabled(this.setup);
	        for (var i = expand.length - 1; i >= 0; i--) {
	            var expandNode = expand[i];
	            if (isOfflineStorageEnabled) {
	                if (!$.isPlainObject(expandNode)) {
	                    throw new Error('When offline is enabled, each member of the expand array option must be an object. (Expand node index: ' + i + ')');
	                }
	                if (!expandNode.relation) {
	                    throw new Error('When offline is enabled, each member of the expand array option must have a `relation` option set.  (Expand node index: ' + i + ')');
	                }
	                if (!expandNode.typeName) {
	                    throw new Error('When offline is enabled, each member of the expand array option must have a `typeName` option set.  (Expand node index: ' + i + ')');
	                }
	                var headers;
	                var expandExpression = {};
	                expandExpression[expandNode.relation] = {
	                    TargetTypeName: expandNode.typeName,
	                    Filter: expandNode.filter,
	                    Sort: expandNode.sort,
	                    Take: expandNode.take,
	                    Skip: expandNode.skip,
	                    Fields: expandNode.fields,
	                    SingleField: expandNode.singleField
	                };
	                headers = {
	                    'X-Everlive-Expand': JSON.stringify(expandExpression),
	                    'X-Everlive-Single-Field': expandNode.relation
	                };
	                var parentType;
	                if (i === 0) {
	                    parentType = typeName;
	                }
	                else {
	                    parentType = expand[i - 1].typeName;
	                }
	                expandSchema = {
	                    model: {
	                        hasChildren: expandNode.relation,
	                        children: {
	                            type: 'everlive',
	                            transport: {
	                                typeName: parentType,
	                                read: {
	                                    headers: headers
	                                }
	                            },
	                            schema: expandSchema
	                        }
	                    }
	                };
	            }
	            else {
	                expandSchema = {
	                    model: {
	                        hasChildren: getRelationFieldForExpandNode(expandNode),
	                        children: {
	                            type: 'everlive',
	                            transport: {
	                                read: {
	                                    url: getUrlGeneratorForNode(baseUrl, expand.slice(0, i + 1)),
	                                    headers: getHeadersForExpandNode(expandNode)
	                                }
	                            },
	                            schema: expandSchema
	                        }
	                    }
	                };
	            }
	        }
	        var options = {};
	        options.type = 'everlive';
	        options.transport = {
	            typeName: typeName,
	            dataProvider: this
	        };
	        options.schema = expandSchema;
	        if ($.isPlainObject(dataSourceOptions)) {
	            extend(true, options, dataSourceOptions);
	        }
	        return new kendo.data.HierarchicalDataSource(options);
	    };
	    KendoSdk.prototype.createDataSource = function (options) {
	        if (options === void 0) { options = {}; }
	        return createDataSource(options);
	    };
	    KendoSdk.prototype.createHierarchicalDataSource = function (options) {
	        if (options === void 0) { options = {}; }
	        return createHierarchicalDataSource(options);
	    };
	    return KendoSdk;
	}(Sdk_1.Sdk));
	exports.KendoSdk = KendoSdk;
	function getUrlGeneratorForNode(baseUrl, expandArray) {
	    var expandField = getRelationFieldForExpandNode(expandArray[expandArray.length - 1]);
	    var pathArray = expandArray.slice(0, expandArray.length - 1);
	    var pathUrl = '/_expand';
	    for (var i = 0; i < pathArray.length; i++) {
	        pathUrl += '/' + getRelationFieldForExpandNode(pathArray[i]);
	    }
	    return (function (pathUrl, expandField) {
	        return function (options) {
	            var url = baseUrl + '';
	            if (options.Id && expandField) {
	                url += pathUrl + '/' + options.Id + '/' + expandField;
	            }
	            return url;
	        };
	    }(pathUrl, expandField));
	}
	function getHeadersForExpandNode(expandNode) {
	    if (typeof expandNode === 'string') {
	        return {};
	    }
	    else {
	        return {
	            'X-Everlive-Filter': JSON.stringify(expandNode.filter),
	            'X-Everlive-Sort': JSON.stringify(expandNode.sort),
	            'X-Everlive-Single-Field': expandNode.singleField,
	            'X-Everlive-Skip': expandNode.skip,
	            'X-Everlive-Take': expandNode.take,
	            'X-Everlive-Fields': JSON.stringify(expandNode.fields)
	        };
	    }
	}
	function getRelationFieldForExpandNode(expandNode) {
	    if (typeof expandNode === 'string') {
	        return expandNode;
	    }
	    else {
	        if (expandNode.relation) {
	            return expandNode.relation;
	        }
	        else {
	            throw new Error("You need to specify a 'relation' for an expand node when using the object notation");
	        }
	    }
	}
	/** * passes Kendo-format aggregations to JS SDK */
	function _transformAggregatesKendoToEverlive(kendoAggregates, aggregateQuery) {
	    _.each(kendoAggregates, function (element) {
	        if (element.aggregate === 'count') {
	            aggregateQuery[element.aggregate](element.aggregate + aggrSeparator + element.field);
	        }
	        else {
	            aggregateQuery[element.aggregate](element.field, element.aggregate + aggrSeparator + element.field);
	        }
	    });
	}
	/** * reformat server-response aggregations from Everlive API format to Kendo*/
	function _transformAggregatesEverliveToKendo(kendoAggregates, data) {
	    var aggrData = {};
	    _.each(kendoAggregates, function (element) {
	        if (!aggrData[element.field]) {
	            aggrData[element.field] = {};
	        }
	        aggrData[element.field][element.aggregate] = data[element.aggregate + aggrSeparator + element.field];
	    });
	    return _.isEmpty(aggrData) ? null : aggrData;
	}


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var path = __webpack_require__(13); //TODO: not sure that this is correct, the typings just seem off
	var node_cryptojs_aes_1 = __webpack_require__(128);
	var utils_1 = __webpack_require__(4);
	var reqwest_everlive_1 = __webpack_require__(23);
	var EverliveError_1 = __webpack_require__(3);
	var AutoQueue_1 = __webpack_require__(43);
	/**
	 * @class OfflineFilesModule
	 * @classdesc A class that provides the means to operate with files in offline mode.
	 * @protected
	 */
	var OfflineFilesModule = (function () {
	    function OfflineFilesModule(_offlineFilesProcessor, _everlive, downloadsConcurrency) {
	        this._offlineFilesProcessor = _offlineFilesProcessor;
	        this._everlive = _everlive;
	        this._downloadsQueue = new AutoQueue_1.AutoQueue(downloadsConcurrency);
	    }
	    OfflineFilesModule.prototype._getFilenameMetadata = function (location, offlineFileInfo) {
	        return new Promise(function (resolve, reject) {
	            reqwest_everlive_1.reqwest({
	                url: location,
	                method: 'HEAD',
	                async: true,
	                crossDomain: true
	            }).then(function (xmlResponse) {
	                var contentDispositionHeader = xmlResponse.getResponseHeader('Content-Disposition');
	                if (contentDispositionHeader) {
	                    var matches = /filename="?([^"\\]*(?:\\.[^"\\]*)*)"?/i.exec(contentDispositionHeader);
	                    if (_.isArray(matches)) {
	                        offlineFileInfo.filename = matches[1];
	                    }
	                }
	                else {
	                    offlineFileInfo.filename = path.basename(xmlResponse.responseURL);
	                }
	                resolve(xmlResponse.responseURL);
	            }).catch(function (err) {
	                return reject(err);
	            });
	        });
	    };
	    /**
	     * Updates a file's content.
	     * @memberof OfflineFilesModule.prototype
	     * @method downloadOffline
	     * @param {string} location A file location or the id of a file stored in Backend Services.
	     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
	     * @returns {Promise} The promise for the request
	     */
	    /**
	     * Updates a file's content.
	     * @memberof OfflineFilesModule.prototype
	     * @method downloadOffline
	     * @param {string} location A file location or the id of a file stored in Backend Services.
	     * @param {boolean} overwrite Boolean option that indicates whether the file should be overwritten if it already exists offline.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    OfflineFilesModule.prototype.downloadOffline = function (location, overwrite, success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            self._downloadsQueue.enqueue(function (cb) {
	                var offlineFileInfo;
	                return self._getOfflineFileInfo(location)
	                    .then(function (_offlineFileInfo) {
	                    offlineFileInfo = _offlineFileInfo;
	                    if (overwrite) {
	                        return false;
	                    }
	                    return self.existsOffline(location);
	                })
	                    .then(function (exists) {
	                    if (!exists) {
	                        if (self._everlive.isOnline()) {
	                            return utils_1.Utils.successfulPromise()
	                                .then(function () {
	                                if (!offlineFileInfo.filename) {
	                                    return self._getFilenameMetadata(location, offlineFileInfo);
	                                }
	                            })
	                                .then(function (locationAfterRedirect) {
	                                var location = locationAfterRedirect || offlineFileInfo.location;
	                                return self._saveFile(location, offlineFileInfo.filename, null, offlineFileInfo.location);
	                            });
	                        }
	                        error(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.cannotDownloadOffline));
	                    }
	                    else {
	                        return self._getOfflineFileInfo(location)
	                            .then(function (fileInfo) {
	                            return self._getOfflineLocation(fileInfo);
	                        });
	                    }
	                })
	                    .then(function (result) {
	                    cb(null, result);
	                })
	                    .catch(cb);
	            }, success, error);
	        }, success, error);
	    };
	    OfflineFilesModule.prototype._saveFile = function (location, filename, id, cacheKey) {
	        var self = this;
	        var actualLocation;
	        return self._downloadFile(location, filename)
	            .then(function (_actualLocation) {
	            actualLocation = _actualLocation;
	            return self._offlineFilesProcessor.getOfflineFilesData();
	        })
	            .then(function (offlineFilesData) {
	            offlineFilesData.push({
	                offlineLocation: actualLocation,
	                onlineLocation: cacheKey || location,
	                id: id
	            });
	            return self._offlineFilesProcessor.saveOfflineFilesData();
	        })
	            .then(function () {
	            return actualLocation;
	        });
	    };
	    /**
	     * Physically deletes the offline copies of all files.
	     * @memberof OfflineFilesModule.prototype
	     * @method purgeAll
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Physically deletes the offline copies of all files.
	     * @memberof OfflineFilesModule.prototype
	     * @method purgeAll
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    OfflineFilesModule.prototype.purgeAll = function (success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            self._offlineFilesProcessor.fileStore.removeFilesDirectory()
	                .then(function () {
	                return self._offlineFilesProcessor.filesMetaStore.removeFilesDirectory();
	            })
	                .then(function () {
	                self._offlineFilesProcessor._offlineFilesData = null;
	            })
	                .then(success)
	                .catch(error);
	        }, success, error);
	    };
	    OfflineFilesModule.prototype._getOfflineLocation = function (fileInfo) {
	        var self = this;
	        var url = fileInfo.location;
	        var filename = fileInfo.filename;
	        var id = fileInfo.Id;
	        return self._offlineFilesProcessor.getOfflineLocation(url, id)
	            .then(function (offlineUrl) {
	            if (offlineUrl) {
	                return offlineUrl;
	            }
	            // if no url is provided this means that the file exists only offline
	            // the Uri field has not been populated by the server
	            if (id && !url) {
	                return self._getFileUrlForId(id, filename);
	            }
	            return null;
	        });
	    };
	    OfflineFilesModule.prototype._downloadFile = function (url, name) {
	        var self = this;
	        // TODO: [offline] this will not work in NativeScript at the moment
	        return new Promise(function (resolve, reject) {
	            var fileTransfer = new FileTransfer();
	            var sanitizedUrl = self._sanitizeUrl(url);
	            var fileId = path.basename(sanitizedUrl);
	            var extension = path.extname(name);
	            var filename = fileId;
	            if (path.extname(sanitizedUrl) !== extension) {
	                filename += extension;
	            }
	            var fileParentDirectory = '';
	            if (!utils_1.Utils.isGuid(url)) {
	                var fileIdIndex = url.lastIndexOf(fileId);
	                var baseUrl = url.substr(0, fileIdIndex);
	                fileParentDirectory = node_cryptojs_aes_1.CryptoJS.MD5(baseUrl).toString();
	            }
	            return self._offlineFilesProcessor.fileStore.getDataDirectory()
	                .then(function (dataDir) {
	                return utils_1.Utils.joinPath(dataDir.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath, fileParentDirectory, filename);
	            })
	                .then(function (location) {
	                fileTransfer.download(url, location, function () {
	                    resolve(location);
	                }, reject, true, {
	                    headers: self._everlive.buildAuthHeader()
	                });
	            })
	                .catch(reject);
	        });
	    };
	    OfflineFilesModule.prototype._sanitizeUrl = function (url) {
	        if (!url) {
	            return url;
	        }
	        var sanitizedUrl = encodeURI(url);
	        var questionMarkIndex = sanitizedUrl.lastIndexOf('?');
	        if (questionMarkIndex !== -1) {
	            sanitizedUrl = sanitizedUrl.substr(0, questionMarkIndex); //linux does not allow question marks in its filenames
	        }
	        return sanitizedUrl;
	    };
	    OfflineFilesModule.prototype._getFileUrlForId = function (fileId, filename) {
	        var self = this;
	        return this._offlineFilesProcessor.fileStore.getDataDirectory()
	            .then(function (dataDirectory) {
	            var fileExtension = path.extname(filename);
	            return utils_1.Utils.joinPath(dataDirectory.nativeURL, self._offlineFilesProcessor.fileStore.filesDirectoryPath, fileId + fileExtension);
	        });
	    };
	    /**
	     * Checks if a file exists offline.
	     * @memberof OfflineFilesModule.prototype
	     * @method exists
	     * @param {String} location The location or file id to check.
	     * @returns {Promise} The promise for the request
	     */
	    /**
	     * Checks if a file exists offline.
	     * @memberof OfflineFilesModule.prototype
	     * @method exists
	     * @param {String} location The location or file id to check.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    OfflineFilesModule.prototype.existsOffline = function (location, success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            self._getOfflineFileInfo(location)
	                .then(function (fileInfo) {
	                return self._getOfflineLocation(fileInfo);
	            })
	                .then(function (offlineUrl) {
	                if (offlineUrl) {
	                    return self._offlineFilesProcessor.fileStore.getFileByAbsolutePath(offlineUrl);
	                }
	            })
	                .then(function (offlineFile) {
	                return !!offlineFile;
	            })
	                .then(success)
	                .catch(function (err) {
	                if (err.code === EverliveError_1.EverliveErrors.itemNotFound.code) {
	                    return success(false);
	                }
	                return error.apply(this, arguments);
	            });
	        }, success, error);
	    };
	    /**
	     * Physically deletes the offline copy of a file.
	     * @memberof OfflineFilesModule.prototype
	     * @method purge
	     * @param {String} location The location or file id to remove.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Physically deletes the offline copy of a file.
	     * @memberof OfflineFilesModule.prototype
	     * @method purge
	     * @param {String} location The location or file id to check.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    OfflineFilesModule.prototype.purge = function (location, success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            self._getOfflineFileInfo(location)
	                .then(function (fileInfo) {
	                return self._getOfflineLocation(fileInfo);
	            })
	                .then(function (location) {
	                if (location) {
	                    return self._offlineFilesProcessor.purge(location);
	                }
	            })
	                .then(success)
	                .catch(error);
	        }, success, error);
	    };
	    /**
	     * Gets the native URL for a file that is stored offline.
	     * @memberof OfflineFilesModule.prototype
	     * @method getOfflineLocation
	     * @param {String} location The location or file id to process.
	     * @returns {Promise} The promise for the request
	     */
	    /**
	     * Gets the native URL for a file that is stored offline.
	     * @memberof OfflineFilesModule.prototype
	     * @method getOfflineLocation
	     * @param {String} location The location or file id to process.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    OfflineFilesModule.prototype.getOfflineLocation = function (location, success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            self._getOfflineFileInfo(location)
	                .then(self._getOfflineLocation.bind(self))
	                .then(function (offlineLocation) {
	                if (offlineLocation) {
	                    return self.existsOffline(offlineLocation)
	                        .then(function (exists) {
	                        if (exists) {
	                            return offlineLocation;
	                        }
	                        return null;
	                    });
	                }
	                return null;
	            })
	                .then(success)
	                .catch(error);
	        }, success, error);
	    };
	    OfflineFilesModule.prototype._getOfflineFileInfo = function (location) {
	        var self = this;
	        var sanitizedUrl = this._sanitizeUrl(location);
	        return new Promise(function (resolve, reject) {
	            self._everlive.files
	                .isSync(true)
	                .useOffline(true)
	                .getById(sanitizedUrl)
	                .then(function (response) {
	                var file = response.result;
	                resolve({
	                    location: file.Uri,
	                    filename: file.Filename,
	                    Id: sanitizedUrl
	                });
	            })
	                .catch(function (err) {
	                if (err && err.code === EverliveError_1.EverliveErrors.itemNotFound.code) {
	                    resolve({
	                        location: location
	                    });
	                }
	                else {
	                    reject(err);
	                }
	            });
	        });
	    };
	    OfflineFilesModule.prototype.changeFileExtensionById = function (id, extension) {
	        var self = this;
	        if (typeof extension !== 'string') {
	            return new Promise(function (resolve) {
	                resolve();
	            });
	        }
	        return self._changeExtension(id, extension);
	    };
	    OfflineFilesModule.prototype._changeExtension = function (id, newExtension) {
	        var self = this;
	        var dataDir;
	        var fileStore = self._offlineFilesProcessor.fileStore;
	        var fileName = id + newExtension;
	        return fileStore.getFilesDirectory()
	            .then(function (directoryEntry) {
	            dataDir = directoryEntry;
	            return self.getOfflineLocation(id);
	        })
	            .then(function (localPath) {
	            var existingFileName = path.basename(localPath);
	            if (existingFileName !== fileName) {
	                return fileStore.getFileByAbsolutePath(localPath)
	                    .then(function (fileEntry) {
	                    return fileStore.renameFile(dataDir, fileEntry, fileName);
	                })
	                    .then(function () {
	                    return self._offlineFilesProcessor.getOfflineFilesData();
	                })
	                    .then(function (offlineFilesData) {
	                    var mappedEntry = _.findWhere(offlineFilesData, { offlineLocation: localPath });
	                    if (!mappedEntry) {
	                        throw new EverliveError_1.EverliveError({ message: 'Could not find a cached location for the specified file.' });
	                    }
	                    var previousLocation = mappedEntry.offlineLocation;
	                    var previousExtension = path.extname(previousLocation);
	                    var actualLocation = previousLocation.slice(0, previousLocation.length - previousExtension.length) + newExtension;
	                    mappedEntry.offlineLocation = actualLocation;
	                    return self._offlineFilesProcessor.saveOfflineFilesData();
	                });
	            }
	        });
	    };
	    return OfflineFilesModule;
	}());
	exports.OfflineFilesModule = OfflineFilesModule;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var path = __webpack_require__(13); //TODO: not sure that this is correct, the typings just seem off
	var EverliveError_1 = __webpack_require__(3);
	var FileStore_1 = __webpack_require__(34);
	var platform = __webpack_require__(5);
	var utils_1 = __webpack_require__(4);
	var FILES_METADATA_FILE_NAME = 'filesMetadataMap';
	var OfflineFilesProcessor = (function () {
	    function OfflineFilesProcessor(setup, _everlive) {
	        this.setup = setup;
	        this._everlive = _everlive;
	        this.fileStore = FileStore_1.getFileStore(setup.files.storagePath, setup);
	        this.filesMetaStore = FileStore_1.getFileStore(setup.files.metaPath, setup);
	    }
	    OfflineFilesProcessor.prototype.validateFileCreateObject = function (obj, isSync) {
	        return new Promise(function (resolve, reject) {
	            if (!obj.base64 && !isSync) {
	                return reject(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.missingOrInvalidFileContent));
	            }
	            else if (!obj.ContentType) {
	                return reject(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.missingContentType));
	            }
	            else if (!obj.Filename) {
	                //TODO: [offline] add an appropriate error
	                return reject(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.invalidRequest));
	            }
	            resolve();
	        });
	    };
	    OfflineFilesProcessor.prototype.getOfflineFilesData = function () {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            if (!self._offlineFilesData) {
	                return self.filesMetaStore.getFile(FILES_METADATA_FILE_NAME)
	                    .then(function (metadataFileHandle) {
	                    return self.filesMetaStore.readFileAsText(metadataFileHandle);
	                })
	                    .then(function (metadataText) {
	                    if (!metadataText) {
	                        metadataText = '[]';
	                    }
	                    self._offlineFilesData = JSON.parse(metadataText);
	                    resolve(self._offlineFilesData);
	                }).catch(reject);
	            }
	            else {
	                resolve(self._offlineFilesData);
	            }
	        });
	    };
	    OfflineFilesProcessor.prototype.saveOfflineFilesData = function () {
	        var self = this;
	        return self.getOfflineFilesData()
	            .then(function (offlineFilesData) {
	            return self.filesMetaStore.writeText(FILES_METADATA_FILE_NAME, JSON.stringify(offlineFilesData));
	        });
	    };
	    OfflineFilesProcessor.prototype.upsertFileFromObject = function (obj, isCreate, isSync) {
	        //TODO: make separate offline files processors when we start supporting nativescript
	        if (platform.isDesktop || platform.isNativeScript) {
	            //we will not support files in desktop and nativescript, only their metadata
	            return utils_1.Utils.successfulPromise();
	        }
	        var self = this;
	        if (!isSync) {
	            if (isCreate) {
	                if (!obj.base64) {
	                    return utils_1.Utils.rejectedPromise(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.missingOrInvalidFileContent));
	                }
	                if (!obj.ContentType) {
	                    return utils_1.Utils.rejectedPromise(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.missingContentType));
	                }
	            }
	            else {
	                if (!obj.base64) {
	                    return utils_1.Utils.successfulPromise();
	                }
	            }
	        }
	        if (!obj.base64) {
	            var id = utils_1.Utils.getId(obj);
	            var uri;
	            var downloadFilePromise = obj.Uri ? utils_1.Utils.successfulPromise(obj.Uri) :
	                self._everlive.files
	                    .isSync(isSync)
	                    .applyOffline(false)
	                    .getDownloadUrlById(id);
	            return downloadFilePromise.then(function (_uri) {
	                uri = _uri;
	                return self._everlive.offlineStorage.files.existsOffline(id);
	            }).then(function (exists) {
	                if (!exists) {
	                    return self._everlive.offlineStorage.files._saveFile(uri, obj.Filename);
	                }
	            });
	        }
	        obj.Storage = 'internal';
	        return utils_1.Utils.successfulPromise().then(function () {
	            if (!isSync) {
	                return self.validateFileCreateObject(obj, isSync);
	            }
	        }).then(function () {
	            var onlineLocation = obj.Uri;
	            var filename = self.getFilenameForObject(obj);
	            var offlineFileInfo;
	            var base64Contents = obj.base64;
	            delete obj.base64;
	            var contents = utils_1.Utils.b64toBlob(base64Contents, obj.ContentType);
	            return self.writeFile(filename, contents)
	                .then(function (fileInfo) {
	                offlineFileInfo = fileInfo;
	                return self.getOfflineFilesData();
	            })
	                .then(function (offlineFilesData) {
	                offlineFilesData.push({
	                    offlineLocation: offlineFileInfo.offlineLocation,
	                    onlineLocation: onlineLocation,
	                    id: obj._id
	                });
	                obj.Length = offlineFileInfo.size;
	                return self.saveOfflineFilesData();
	            });
	        });
	    };
	    OfflineFilesProcessor.prototype.purge = function (localLocation) {
	        var self = this;
	        return this.getOfflineFilesData()
	            .then(function (offlineFilesData) {
	            var offlineFile = _.where(offlineFilesData, { offlineLocation: localLocation });
	            // TODO: [offline] check if the length of offlineFile === 0
	            var offlineInfoIndex = offlineFilesData.indexOf(offlineFile[0]);
	            if (offlineInfoIndex !== -1) {
	                offlineFilesData.splice(offlineInfoIndex, 1);
	            }
	            return self.saveOfflineFilesData();
	        })
	            .then(function () {
	            return self.fileStore.getFileByAbsolutePath(localLocation);
	        }).then(function (file) {
	            if (file) {
	                return self.fileStore.removeFile(file);
	            }
	        });
	    };
	    OfflineFilesProcessor.prototype.writeFile = function (filename, contents, folder) {
	        var self = this;
	        var offlineLocation;
	        return self.fileStore.writeText(filename, contents, folder)
	            .then(function (locationOnDisk) {
	            offlineLocation = locationOnDisk;
	            return self.saveOfflineFilesData();
	        })
	            .then(function () {
	            return self.fileStore.getFileSize(filename, folder);
	        })
	            .then(function (size) {
	            return {
	                size: size,
	                offlineLocation: offlineLocation
	            };
	        });
	    };
	    OfflineFilesProcessor.prototype.getFilenameForObject = function (obj) {
	        var extension = path.extname(obj.Filename);
	        return obj._id + extension;
	    };
	    OfflineFilesProcessor.prototype.getOfflineLocation = function (url, id) {
	        return this.getOfflineFilesData()
	            .then(function (offlineFilesData) {
	            if (!url && !id) {
	                return;
	            }
	            for (var i = 0; i < offlineFilesData.length; i++) {
	                var fileEntry = offlineFilesData[i];
	                var urlMatches = (url && (fileEntry.offlineLocation === url || fileEntry.onlineLocation === url));
	                var idMatches = (id && fileEntry.id === id);
	                if (urlMatches || idMatches) {
	                    return fileEntry.offlineLocation;
	                }
	            }
	        });
	    };
	    return OfflineFilesProcessor;
	}());
	exports.OfflineFilesProcessor = OfflineFilesProcessor;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var path = __webpack_require__(13);
	var ExpandProcessor_1 = __webpack_require__(44);
	var utils_1 = __webpack_require__(4);
	var offlineTransformations_1 = __webpack_require__(30);
	var platform = __webpack_require__(5);
	var EverliveError_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(2);
	var mingo = __webpack_require__(151);
	var mongoQuery = __webpack_require__(153);
	var aggregationTranslator = __webpack_require__(177);
	var unsupportedOfflineHeaders = [constants_1.Constants.Headers.powerFields];
	var unsupportedUsersOperations = (_a = {},
	    _a[constants_1.DataQueryOperation.Create] = true,
	    _a[constants_1.DataQueryOperation.Update] = true,
	    _a[constants_1.DataQueryOperation.Delete] = true,
	    _a[constants_1.DataQueryOperation.DeleteById] = true,
	    _a[constants_1.DataQueryOperation.RawUpdate] = true,
	    _a[constants_1.DataQueryOperation.SetAcl] = true,
	    _a[constants_1.DataQueryOperation.SetOwner] = true,
	    _a[constants_1.DataQueryOperation.UserLoginWithProvider] = true,
	    _a[constants_1.DataQueryOperation.UserLinkWithProvider] = true,
	    _a[constants_1.DataQueryOperation.UserUnlinkFromProvider] = true,
	    _a[constants_1.DataQueryOperation.UserLogin] = true,
	    _a[constants_1.DataQueryOperation.UserLogout] = true,
	    _a[constants_1.DataQueryOperation.UserChangePassword] = true,
	    _a[constants_1.DataQueryOperation.UserResetPassword] = true,
	    _a
	);
	function buildUsersErrorMessage(dataQuery) {
	    var unsupportedUserSocialProviderOperations = [
	        constants_1.DataQueryOperation.UserLoginWithProvider,
	        constants_1.DataQueryOperation.UserLinkWithProvider,
	        constants_1.DataQueryOperation.UserUnlinkFromProvider
	    ];
	    var operation = dataQuery.operation;
	    var operationStr = constants_1.DataQueryOperation[dataQuery.operation];
	    if (unsupportedUserSocialProviderOperations.indexOf(operation) !== -1) {
	        var providerPrefix = operationStr.substring(0, operationStr.indexOf('Provider'));
	        operationStr = providerPrefix + (dataQuery.data.Provider || dataQuery.data.Identity.Provider);
	    }
	    return { message: 'The Users operation ' + operationStr + ' is not supported in offline mode', code: 0 };
	}
	function buildFilesErrorMessage(dataOperation) {
	    var operationStr = constants_1.DataQueryOperation[dataOperation];
	    return { message: "The Files operation " + operationStr + " is not supported in offline mode", code: 0 };
	}
	var OfflineQueryProcessor = (function () {
	    function OfflineQueryProcessor(persister, _encryptionProvider, offlineFilesProcessor, everlive, setup) {
	        this.persister = persister;
	        this._encryptionProvider = _encryptionProvider;
	        this.offlineFilesProcessor = offlineFilesProcessor;
	        this.everlive = everlive;
	        this.setup = setup;
	        this._collectionCache = {};
	    }
	    OfflineQueryProcessor.prototype.processQuery = function (dataQuery) {
	        var collectionName = dataQuery.collectionName;
	        if (utils_1.Utils.isContentType.pushDevices(collectionName) || utils_1.Utils.isContentType.pushNotifications(collectionName)) {
	            if (this.everlive.isOnline()) {
	                return utils_1.Utils.successfulPromise();
	            }
	            else {
	                return utils_1.Utils.rejectedPromise(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.pushNotSupportedOffline));
	            }
	        }
	        var queryNotSupportedError = this.checkSupportedQuery(dataQuery);
	        if (queryNotSupportedError && !dataQuery.isSync) {
	            return new Promise(function (resolve, reject) {
	                reject(new EverliveError_1.EverliveError(queryNotSupportedError));
	            });
	        }
	        var queryParams = dataQuery.getQueryParameters();
	        var unsupportedOperators = utils_1.Utils.getUnsupportedOperators(queryParams.filter);
	        var unsupportedOperatorCount = unsupportedOperators.length;
	        if (unsupportedOperatorCount) {
	            return new Promise(function (resolve, reject) {
	                var errorMessage;
	                if (unsupportedOperatorCount === 1) {
	                    errorMessage = 'The operator ' + unsupportedOperators[0] + ' is not supported in offline mode.';
	                }
	                else {
	                    errorMessage = 'The operators ' + unsupportedOperators.join(',') + 'are not supported in offline mode.';
	                }
	                reject(new EverliveError_1.EverliveError({
	                    message: errorMessage,
	                    code: EverliveError_1.EverliveErrors.operationNotSupportedOffline.code
	                }));
	            });
	        }
	        offlineTransformations_1.offlineTransformations.traverseAndTransformFilterId(queryParams.filter);
	        switch (dataQuery.operation) {
	            case constants_1.DataQueryOperation.Read:
	                return this.read(dataQuery, queryParams.filter, queryParams.sort, queryParams.skip, queryParams.limit, queryParams.select, queryParams.expand);
	            case constants_1.DataQueryOperation.ReadById:
	                return this.readById(dataQuery, queryParams.expand);
	            case constants_1.DataQueryOperation.FilesGetDownloadUrlById:
	                return this.getDownloadUrlById(dataQuery);
	            case constants_1.DataQueryOperation.Count:
	                return this.count(dataQuery, queryParams.filter);
	            case constants_1.DataQueryOperation.Create:
	                return this.create(dataQuery);
	            case constants_1.DataQueryOperation.RawUpdate:
	            case constants_1.DataQueryOperation.Update:
	                return this.update(dataQuery, queryParams.filter);
	            case constants_1.DataQueryOperation.FilesUpdateContent:
	                return this.updateFileContent(dataQuery);
	            case constants_1.DataQueryOperation.Delete:
	                return this.remove(dataQuery, queryParams.filter);
	            case constants_1.DataQueryOperation.DeleteById:
	                return this.remove(dataQuery, {
	                    _id: dataQuery.additionalOptions.id
	                });
	            case constants_1.DataQueryOperation.Aggregate:
	                return this.aggregate(dataQuery, queryParams);
	            default:
	                return new Promise(function (resolve, reject) {
	                    if (dataQuery.isSync) {
	                        resolve();
	                    }
	                    else {
	                        var operationStr = constants_1.DataQueryOperation[dataQuery.operation];
	                        reject(new EverliveError_1.EverliveError({ message: operationStr + ' is not supported in offline mode.' }));
	                    }
	                });
	        }
	    };
	    OfflineQueryProcessor.prototype.getDownloadUrlById = function (dataQuery) {
	        var self = this;
	        var id = dataQuery.additionalOptions.id;
	        var offlineFilePath;
	        var fileDirectUri;
	        return self.everlive
	            .files
	            .useOffline(true)
	            .isSync(dataQuery.isSync)
	            .getById(id)
	            .then(function (res) {
	            var file = res.result;
	            fileDirectUri = file.Uri;
	            return self.everlive.offlineStorage.files._getFileUrlForId(file.Id, file.Filename);
	        })
	            .then(function (filePath) {
	            offlineFilePath = filePath;
	            return self.everlive.offlineStorage.offlineFilesProcessor.fileStore.getFileByAbsolutePath(filePath);
	        })
	            .then(function (fileEntry) {
	            return {
	                result: {
	                    Uri: fileEntry ? offlineFilePath : fileDirectUri
	                }
	            };
	        });
	    };
	    OfflineQueryProcessor.prototype.checkSupportedQuery = function (dataQuery) {
	        for (var i = 0; i < unsupportedOfflineHeaders.length; i++) {
	            var header = unsupportedOfflineHeaders[i];
	            if (dataQuery.getHeader(header)) {
	                return { message: 'The header ' + header + ' is not supported in offline mode', code: 0 };
	            }
	        }
	        if (utils_1.Utils.isContentType.users(dataQuery.collectionName) && unsupportedUsersOperations[dataQuery.operation]) {
	            return buildUsersErrorMessage(dataQuery);
	        }
	        var isSingle = dataQuery.additionalOptions && dataQuery.additionalOptions.id;
	        var isUpdateByFilter = dataQuery.operation === constants_1.DataQueryOperation.Update && !isSingle;
	        var isRawUpdate = dataQuery.operation === constants_1.DataQueryOperation.RawUpdate;
	        var creatingMultiple = dataQuery.operation === constants_1.DataQueryOperation.Create && Array.isArray(dataQuery.data);
	        if (utils_1.Utils.isContentType.files(dataQuery.collectionName)) {
	            if (creatingMultiple) {
	                return EverliveError_1.EverliveErrors.invalidRequest;
	            }
	            else if (isRawUpdate || isUpdateByFilter) {
	                return buildFilesErrorMessage(dataQuery.operation);
	            }
	        }
	    };
	    OfflineQueryProcessor.prototype._getCreateResult = function (createdItems, returnFullItem) {
	        if (createdItems.length === 1) {
	            var result;
	            if (returnFullItem) {
	                var item = _.extend({}, createdItems[0]);
	                result = offlineTransformations_1.offlineTransformations.idTransform(item);
	            }
	            else {
	                result = {
	                    CreatedAt: utils_1.Utils.cloneDate(createdItems[0].CreatedAt),
	                    Id: createdItems[0]._id
	                };
	            }
	            return {
	                result: result
	            };
	        }
	        else {
	            var multipleCreateResult = [];
	            _.each(createdItems, function (createdItem) {
	                var item;
	                if (returnFullItem) {
	                    var itemCopy = _.extend({}, createdItem);
	                    item = offlineTransformations_1.offlineTransformations.idTransform(itemCopy);
	                }
	                else {
	                    item = {
	                        CreatedAt: utils_1.Utils.cloneDate(createdItem.CreatedAt),
	                        Id: createdItem._id
	                    };
	                }
	                multipleCreateResult.push(item);
	            });
	            return {
	                result: multipleCreateResult
	            };
	        }
	    };
	    OfflineQueryProcessor.prototype.create = function (dataQuery) {
	        var self = this;
	        return self._createItems(dataQuery.collectionName, dataQuery.data, dataQuery.isSync, dataQuery.preserveState)
	            .then(function (createdItems) {
	            var isFilesQuery = utils_1.Utils.isContentType.files(dataQuery.collectionName);
	            return self._getCreateResult(createdItems, isFilesQuery);
	        });
	    };
	    OfflineQueryProcessor.prototype.read = function (dataQuery, filter, sort, skip, limit, select, expand) {
	        var self = this;
	        var expandResult;
	        return new Promise(function (resolve, reject) {
	            var collectionLength;
	            self._prepareExpand(expand, dataQuery, true)
	                .then(function (prepareExpandResult) {
	                expandResult = prepareExpandResult;
	                if (prepareExpandResult) {
	                    select = prepareExpandResult.mainQueryFieldsExpression;
	                }
	                return self._getCollection(dataQuery.collectionName);
	            })
	                .then(function (collection) {
	                var result = self._readInternal(collection, filter, sort, skip, limit, select);
	                if (skip || limit) {
	                    var all = self._readInternal(collection);
	                    collectionLength = all.length;
	                }
	                if (!self._shouldAutogenerateIdForContentType(dataQuery.collectionName)) {
	                    result = offlineTransformations_1.offlineTransformations.removeIdTransform(result, true);
	                }
	                else {
	                    result = offlineTransformations_1.offlineTransformations.idTransform(result);
	                }
	                return self._expandResult(expandResult, result);
	            })
	                .then(function (result) {
	                var response = self._transformOfflineResult(result, collectionLength, dataQuery);
	                resolve(response);
	            })
	                .catch(reject);
	        });
	    };
	    OfflineQueryProcessor.prototype._readInternal = function (collection, filter, sort, skip, limit, select) {
	        var filterCopy = _.extend({}, filter);
	        var actualFilter = this._getWithoutDeletedFilter(filterCopy);
	        offlineTransformations_1.offlineTransformations.traverseAndTransformFilterId(actualFilter);
	        var query = mingo.Query(actualFilter);
	        var cursor = mingo.Cursor(collection, query, select);
	        if (sort) {
	            cursor = cursor.sort(sort);
	        }
	        if (skip) {
	            cursor.skip(skip);
	        }
	        if (limit) {
	            cursor.limit(limit);
	        }
	        return _.map(cursor.all(), function (item) {
	            return _.extend({}, item);
	        });
	    };
	    OfflineQueryProcessor.prototype.readById = function (dataQuery, expand) {
	        var self = this;
	        var expandResult;
	        return self._prepareExpand(expand, dataQuery, false)
	            .then(function (prepareExpandResult) {
	            expandResult = prepareExpandResult;
	            return self._getCollection(dataQuery.collectionName);
	        })
	            .then(function (collection) {
	            return new Promise(function (resolve, reject) {
	                var item = self._getById(collection, dataQuery.additionalOptions.id);
	                if (!item) {
	                    return reject(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.itemNotFound));
	                }
	                item = offlineTransformations_1.offlineTransformations.idTransform(item);
	                return self._expandResult(expandResult, item).then(resolve).catch(reject);
	            });
	        })
	            .then(function (result) {
	            return self._transformOfflineResult(result, null, dataQuery);
	        });
	    };
	    OfflineQueryProcessor.prototype._getById = function (collection, id) {
	        if (!id) {
	            throw new EverliveError_1.EverliveError({ message: 'Id field is mandatory when using offline storage' });
	        }
	        if (collection[id]) {
	            var item = _.extend({}, collection[id]);
	            var isDeleted = item && item[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.deleted;
	            return isDeleted ? undefined : item;
	        }
	    };
	    OfflineQueryProcessor.prototype._prepareExpand = function (expand, dataQuery, isArray) {
	        return new Promise(function (resolve, reject) {
	            if (expand) {
	                ExpandProcessor_1.expandProcessor.prepare(expand, dataQuery.collectionName, isArray, dataQuery.fields, null, null, function (err, prepareResult) {
	                    if (err) {
	                        if (err.name === 'ExpandError') {
	                            err.code = EverliveError_1.EverliveErrors.invalidExpandExpression.code;
	                        }
	                        return reject(err);
	                    }
	                    resolve(prepareResult);
	                });
	            }
	            else {
	                resolve();
	            }
	        });
	    };
	    OfflineQueryProcessor.prototype._expandResult = function (prepareExpandResult, result) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            if (prepareExpandResult) {
	                ExpandProcessor_1.expandProcessor.expand(prepareExpandResult.relationsTree, result, {
	                    offlineModule: self
	                }, function (err, result) {
	                    if (err) {
	                        if (err.name === 'ExpandError') {
	                            err.code = EverliveError_1.EverliveErrors.invalidExpandExpression.code;
	                        }
	                        return reject(err);
	                    }
	                    resolve(result);
	                });
	            }
	            else {
	                resolve(result);
	            }
	        });
	    };
	    OfflineQueryProcessor.prototype._getWithoutDeletedFilter = function (filter) {
	        var withoutDeletedFilter = {
	            $and: []
	        };
	        withoutDeletedFilter.$and.push(filter);
	        var deleteOfflineFilter = {};
	        deleteOfflineFilter[constants_1.Constants.offlineItemsStateMarker] = { $ne: constants_1.Constants.offlineItemStates.deleted };
	        withoutDeletedFilter.$and.push(deleteOfflineFilter);
	        return withoutDeletedFilter;
	    };
	    OfflineQueryProcessor.prototype._getUpdateItemsResult = function (updateItems) {
	        var updatedItemCount = updateItems.length;
	        var modifiedAtResult = updatedItemCount ? updateItems[0].ModifiedAt : new Date();
	        return {
	            ModifiedAt: modifiedAtResult,
	            result: updatedItemCount
	        };
	    };
	    OfflineQueryProcessor.prototype.update = function (dataQuery, filter) {
	        var self = this;
	        return this._updateItems(dataQuery, dataQuery.data, filter, dataQuery.isSync).then(function (updateItems) {
	            return self._getUpdateItemsResult(updateItems);
	        });
	    };
	    OfflineQueryProcessor.prototype.remove = function (dataQuery, filter) {
	        return this._removeItems(dataQuery, filter, dataQuery.isSync);
	    };
	    OfflineQueryProcessor.prototype.count = function (dataQuery, filter) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            self._getCollection(dataQuery.collectionName)
	                .then(function (collection) {
	                var filterResult = self._readInternal(collection, filter);
	                resolve({ result: filterResult.length });
	            }).catch(reject);
	        });
	    };
	    OfflineQueryProcessor.prototype._setItemDates = function (currentItem, itemToCreate, contentType) {
	        // we need to manually clone the dates in order to dereference them from the original object as
	        // _.extends will pass a reference to the original date instead of creating a new instance
	        if (utils_1.Utils.isDate(currentItem.CreatedAt)) {
	            itemToCreate.CreatedAt = utils_1.Utils.cloneDate(currentItem.CreatedAt);
	        }
	        else {
	            itemToCreate.CreatedAt = new Date();
	        }
	        if (utils_1.Utils.isDate(currentItem.ModifiedAt)) {
	            itemToCreate.ModifiedAt = utils_1.Utils.cloneDate(currentItem.ModifiedAt);
	        }
	        else {
	            itemToCreate.ModifiedAt = utils_1.Utils.cloneDate(itemToCreate.CreatedAt);
	        }
	        itemToCreate.CreatedBy = itemToCreate.CreatedBy || this.everlive.setup.principalId || constants_1.Constants.guidEmpty;
	        itemToCreate.ModifiedBy = itemToCreate.ModifiedBy || itemToCreate.CreatedBy;
	        if (contentType === 'Users') {
	            itemToCreate.Owner = itemToCreate._id;
	        }
	        else {
	            itemToCreate.Owner = itemToCreate.CreatedBy || constants_1.Constants.guidEmpty;
	        }
	    };
	    OfflineQueryProcessor.prototype._mapCreateItem = function (currentItem, collection, isSync, preserveState, contentType) {
	        var self = this;
	        var itemToCreate = _.extend({}, currentItem);
	        itemToCreate._id = itemToCreate.Id || utils_1.Utils.uuid();
	        delete itemToCreate.Id;
	        var existingItem = self._getById(collection, itemToCreate._id);
	        var itemExists = !!existingItem;
	        var state;
	        if (itemExists && (!isSync && !preserveState)) {
	            // TODO: [offline] return the same error as the server does
	            throw new EverliveError_1.EverliveError({ message: 'An item with the specified id already exists' });
	        }
	        else {
	            if (isSync && preserveState && itemExists) {
	                state = existingItem[constants_1.Constants.offlineItemsStateMarker];
	            }
	            else {
	                state = isSync ? undefined : constants_1.Constants.offlineItemStates.created; // set the state to created only if not syncing
	            }
	        }
	        function processItemResult() {
	            self._setItemDates(currentItem, itemToCreate, contentType);
	            self._setItem(collection, _.extend({}, itemToCreate), state);
	            return itemToCreate;
	        }
	        if (utils_1.Utils.isContentType.files(contentType)) {
	            return self.offlineFilesProcessor.upsertFileFromObject(itemToCreate, true, isSync).then(processItemResult);
	        }
	        else {
	            return processItemResult();
	        }
	    };
	    OfflineQueryProcessor.prototype._createItems = function (contentType, items, isSync, preserveState) {
	        var self = this;
	        return this._getCollection(contentType)
	            .then(function (collection) {
	            var itemsForCreate = _.isArray(items) ? items : [items];
	            var createdItems = _.map(itemsForCreate, function (currentItem) {
	                return self._mapCreateItem(currentItem, collection, isSync, preserveState, contentType);
	            });
	            return Promise.all(createdItems)
	                .then(function (items) {
	                return self._persistData(contentType)
	                    .then(function () {
	                    // Ids are generated regardless of the autoGenerateId option. However the Id's are omitted when returning
	                    // the items to the client if autoGenerateId is false
	                    if (!self._shouldAutogenerateIdForContentType(contentType) && !isSync) {
	                        createdItems = offlineTransformations_1.offlineTransformations.removeIdTransform(items);
	                    }
	                    return items;
	                });
	            });
	        });
	    };
	    OfflineQueryProcessor.prototype._applyUpdateOperation = function (originalUpdateExpression, itemToUpdate, collection, isSync, modifiedAt) {
	        var dbOperators = utils_1.Utils.getDbOperators(originalUpdateExpression, true);
	        var hasDbOperator = dbOperators.length !== 0;
	        var updateExpression;
	        if (hasDbOperator) {
	            updateExpression = originalUpdateExpression;
	        }
	        else {
	            updateExpression = {
	                $set: originalUpdateExpression
	            };
	        }
	        var updateExpressionForUser = {
	            ModifiedBy: this.everlive.setup.principalId || constants_1.Constants.guidEmpty
	        };
	        updateExpression.$set = _.extend(updateExpressionForUser, updateExpression.$set);
	        if (isSync) {
	            updateExpression.$set.ModifiedAt = utils_1.Utils.cloneDate(originalUpdateExpression.ModifiedAt || modifiedAt);
	        }
	        mongoQuery(itemToUpdate, {}, updateExpression, { strict: true }); // Setting strict to true so only exact matches would be updated
	        itemToUpdate._id = itemToUpdate._id || updateExpression._id || updateExpression.Id;
	        delete itemToUpdate.Id;
	        var newState;
	        if (isSync) {
	            newState = undefined;
	        }
	        else if (itemToUpdate[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.created) {
	            newState = constants_1.Constants.offlineItemStates.created;
	        }
	        else {
	            newState = constants_1.Constants.offlineItemStates.modified;
	        }
	        this._setItem(collection, itemToUpdate, newState);
	    };
	    OfflineQueryProcessor.prototype.updateFileContent = function (dataQuery) {
	        if (platform.isDesktop) {
	            return utils_1.Utils.successfulPromise();
	        }
	        var isSync = dataQuery.isSync;
	        var updateExpression = dataQuery.data;
	        var self = this;
	        var itemId = dataQuery.additionalOptions.id;
	        var updateItems;
	        var typeName = dataQuery.collectionName;
	        return this._getCollection(typeName)
	            .then(function (collection) {
	            var singleItemForUpdate = self._getById(collection, itemId);
	            updateItems = [singleItemForUpdate];
	            singleItemForUpdate.base64 = updateExpression.base64;
	            singleItemForUpdate.Filename = updateExpression.Filename;
	            singleItemForUpdate.ContentType = updateExpression.ContentType;
	            delete singleItemForUpdate.Uri;
	            return self._overwriteFile(itemId, singleItemForUpdate, isSync)
	                .then(function () {
	                self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection);
	                self._setItem(collection, singleItemForUpdate, constants_1.Constants.offlineItemStates.modified);
	                return self._persistData(typeName);
	            })
	                .then(function () {
	                return self._getUpdateItemsResult(updateItems);
	            });
	        });
	    };
	    OfflineQueryProcessor.prototype._overwriteFile = function (itemId, itemForUpdate, isSync) {
	        var self = this;
	        return self.everlive.offlineStorage.files.purge(itemId)
	            .then(function () {
	            return self.offlineFilesProcessor.upsertFileFromObject(itemForUpdate, true, isSync);
	        });
	    };
	    OfflineQueryProcessor.prototype._updateItems = function (dataQuery, updateExpression, filter, isSync) {
	        var self = this;
	        var collectionName = dataQuery.collectionName;
	        return self._getCollection(collectionName)
	            .then(function (collection) {
	            var updateItems;
	            if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
	                var itemId = dataQuery.additionalOptions.id;
	                var singleItemForUpdate = self._getById(collection, itemId);
	                if (!singleItemForUpdate) {
	                    throw new EverliveError_1.EverliveError({
	                        message: 'Item with id :' + itemId + ' does not exist offline in the collection :' + collectionName,
	                        code: EverliveError_1.EverliveErrors.itemNotFound.code
	                    });
	                }
	                updateItems = [singleItemForUpdate];
	                if (utils_1.Utils.isContentType.files(collectionName) && updateExpression.$set && updateExpression.$set.Filename || updateExpression.Filename) {
	                    var filename = updateExpression.Filename || updateExpression.$set.Filename;
	                    var extension = path.extname(filename);
	                    return self.everlive.offlineStorage.files.changeFileExtensionById(itemId, extension)
	                        .then(function () {
	                        self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
	                        return self._persistData(collectionName);
	                    })
	                        .then(function () {
	                        return updateItems;
	                    });
	                }
	                else {
	                    self._applyUpdateOperation(updateExpression, singleItemForUpdate, collection, isSync, dataQuery.ModifiedAt);
	                }
	            }
	            else {
	                updateItems = self._readInternal(collection, filter);
	                for (var i = 0; i < updateItems.length; i++) {
	                    var itemToUpdate = updateItems[i];
	                    var itemExists = !!self._getById(collection, itemToUpdate._id.toString());
	                    if (!itemExists && !isSync) {
	                        // TODO: [offline] return the correct error
	                        throw new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.itemNotFound);
	                    }
	                    self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync, dataQuery.ModifiedAt);
	                }
	            }
	            return self._persistData(collectionName)
	                .then(function () {
	                return updateItems;
	            });
	        });
	    };
	    OfflineQueryProcessor.prototype._getAllCollections = function () {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            self.persister.getAllData(function (allData) {
	                _.each(allData, function (value, key) {
	                    var decryptedData = self._encryptionProvider.decrypt(value);
	                    allData[key] = JSON.parse(decryptedData || '{}', utils_1.Utils.parseUtilities.getReviver());
	                });
	                resolve(allData);
	            }, reject);
	        });
	    };
	    OfflineQueryProcessor.prototype._getCollection = function (contentType) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            // check the persister if there is no data in the collection cache for this content type
	            if (!self._collectionCache[contentType]) {
	                self.persister.getData(contentType, function (data) {
	                    var decryptedDataRaw = self._encryptionProvider.decrypt(data);
	                    var decryptedData = JSON.parse(decryptedDataRaw || '{}', utils_1.Utils.parseUtilities.getReviver());
	                    self._collectionCache[contentType] = decryptedData;
	                    resolve(self._collectionCache[contentType]);
	                }, reject);
	            }
	            else {
	                resolve(self._collectionCache[contentType]);
	            }
	        });
	    };
	    OfflineQueryProcessor.prototype._setItem = function (collection, item, state) {
	        if (!state) {
	            delete item[constants_1.Constants.offlineItemsStateMarker];
	        }
	        else {
	            item[constants_1.Constants.offlineItemsStateMarker] = state;
	        }
	        collection[item._id] = item;
	    };
	    OfflineQueryProcessor.prototype._getDirtyItems = function (collection) {
	        var filter = {};
	        filter[constants_1.Constants.offlineItemsStateMarker] = { $exists: true };
	        var query = mingo.Query(filter);
	        var cursor = mingo.Cursor(collection, query);
	        return cursor.all();
	    };
	    OfflineQueryProcessor.prototype._persistData = function (contentType) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            var contentTypeData = self._collectionCache[contentType] || {};
	            self._transformPersistedData(contentType, contentTypeData);
	            var contentTypeDataRaw = JSON.stringify(contentTypeData);
	            var contentTypeDataRawEncrypted = self._encryptionProvider.encrypt(contentTypeDataRaw);
	            self.persister.saveData(contentType, contentTypeDataRawEncrypted, resolve, reject);
	        });
	    };
	    OfflineQueryProcessor.prototype._shouldAutogenerateIdForContentType = function (contentType) {
	        return !(this.setup && this.setup.typeSettings && this.setup.typeSettings[contentType] && this.setup.typeSettings[contentType].autoGenerateId === false);
	    };
	    OfflineQueryProcessor.prototype._clearItem = function (collection, item) {
	        delete collection[item._id];
	    };
	    OfflineQueryProcessor.prototype._mapRemoveItem = function (itemToRemove, collection, isSync, collectionName) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            //we cannot remove files while in desktop mode
	            if (utils_1.Utils.isContentType.files(collectionName) && !platform.isDesktop) {
	                return self.everlive.offlineStorage.files.purge(itemToRemove._id).then(resolve, reject);
	            }
	            else {
	                return resolve();
	            }
	        }).then(function () {
	            itemToRemove._id = itemToRemove._id || itemToRemove.Id;
	            var itemExists = !!self._getById(collection, itemToRemove._id.toString());
	            if (!itemExists && !isSync) {
	                throw new EverliveError_1.EverliveError({ message: 'Cannot delete item - item with id ' + itemToRemove._id + ' does not exist.' });
	            }
	            // if the item has existed only offline or the data is syncing
	            // and the item was deleted by the conflict resolution strategy
	            var removeFromMemory = itemToRemove[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.created || isSync;
	            if (removeFromMemory) {
	                self._clearItem(collection, itemToRemove);
	            }
	            else {
	                self._setItem(collection, itemToRemove, constants_1.Constants.offlineItemStates.deleted);
	            }
	        });
	    };
	    OfflineQueryProcessor.prototype._removeItems = function (dataQuery, filter, isSync) {
	        var self = this;
	        var collectionName = dataQuery.collectionName;
	        return self._getCollection(collectionName)
	            .then(function (collection) {
	            var itemsToRemove = self._readInternal(collection, filter);
	            var removedItemsPromises = _.map(itemsToRemove, function (itemToRemove) {
	                return self._mapRemoveItem(itemToRemove, collection, isSync, collectionName);
	            });
	            return Promise.all(removedItemsPromises);
	        })
	            .then(function (itemsToRemove) {
	            return self._persistData(collectionName)
	                .then(function () {
	                return itemsToRemove;
	            });
	        })
	            .then(function (itemsToRemove) {
	            return self._transformOfflineResult(itemsToRemove.length);
	        });
	    };
	    OfflineQueryProcessor.prototype._applyTransformations = function (transformedResult, transformations) {
	        if (Array.isArray(transformedResult.result)) {
	            _.each(transformations, function (transformation) {
	                transformedResult.result.map(function (value, key) {
	                    transformedResult.result[key] = transformation(value);
	                });
	            });
	        }
	        else {
	            _.each(transformations, function (transformation) {
	                transformedResult.result = transformation(transformedResult.result);
	            });
	        }
	    };
	    OfflineQueryProcessor.prototype._transformOfflineResult = function (resultSet, count, dataQuery, additionalTransformations) {
	        var transformedResult = {
	            result: resultSet,
	            count: count || (resultSet || []).length
	        };
	        if ((count !== undefined && count !== null) || Array.isArray(resultSet)) {
	            transformedResult.count = count || resultSet.length;
	        }
	        var transformations = [];
	        transformations.push(offlineTransformations_1.offlineTransformations.idTransform);
	        transformations.push(offlineTransformations_1.offlineTransformations.removeMarkersTransform);
	        if (dataQuery) {
	            var includeCount = dataQuery.getHeader(constants_1.Constants.Headers.includeCount);
	            if (includeCount === false) {
	                delete transformedResult.count;
	            }
	            var singleFieldExpression = dataQuery.getHeader(constants_1.Constants.Headers.singleField);
	            if (typeof singleFieldExpression === 'string') {
	                transformations.push(offlineTransformations_1.offlineTransformations.singleFieldTransform.bind(this, singleFieldExpression));
	            }
	        }
	        if (additionalTransformations) {
	            transformations = transformations.concat(additionalTransformations);
	        }
	        this._applyTransformations(transformedResult, transformations);
	        if (transformedResult.count === undefined) {
	            delete transformedResult.count;
	        }
	        return transformedResult;
	    };
	    OfflineQueryProcessor.prototype._transformPersistedData = function (contentType, contentTypeData) {
	        var transformFields = [];
	        if (contentType === 'Users') {
	            transformFields = transformFields.concat(['Password', 'SecretQuestionId', 'SecretAnswer']);
	        }
	        if (transformFields.length) {
	            _.each(contentTypeData, function (contentTypeObject) {
	                offlineTransformations_1.offlineTransformations.removeFieldsTransform(contentTypeObject, transformFields);
	            });
	        }
	    };
	    OfflineQueryProcessor.prototype.aggregate = function (dataQuery, queryParams) {
	        var self = this;
	        return this._getCollection(dataQuery.collectionName).then(function (collection) {
	            if (!queryParams || !queryParams.aggregate || _.isEmpty(queryParams.aggregate)) {
	                throw new EverliveError_1.EverliveError({ message: 'You must specify a valid aggregation definition. Either GroupBy or Aggregate is required.' });
	            }
	            var aggregationQuery = _.extend({}, queryParams.aggregate);
	            aggregationQuery.Filter = queryParams.filter;
	            var translatedPipeline = aggregationTranslator.translate(aggregationQuery, {
	                maxDocumentsCount: constants_1.Constants.Aggregation.MaxDocumentsCount
	            });
	            var collectionWithoutDeleted = _.filter(collection, function (item) {
	                return item[constants_1.Constants.offlineItemsStateMarker] !== constants_1.Constants.offlineItemStates.deleted;
	            });
	            var result = mingo.aggregate(collectionWithoutDeleted, translatedPipeline);
	            return self._transformOfflineResult(result, null, dataQuery);
	        });
	    };
	    OfflineQueryProcessor.prototype.purgeAll = function (success, error) {
	        var self = this;
	        this._collectionCache = {};
	        return utils_1.Utils.buildPromise(function (success, error) {
	            self._collectionCache = {};
	            self.persister.purgeAll(function () {
	                var cachingIsEnabled = self.everlive.setup.caching && self.everlive.setup.caching.enabled === true;
	                if (cachingIsEnabled) {
	                    self.everlive.cache.clearAll(success, error);
	                }
	                else {
	                    success();
	                }
	            }, error);
	        }, success, error);
	    };
	    OfflineQueryProcessor.prototype.purge = function (contentType, success, error) {
	        var self = this;
	        return utils_1.Utils.buildPromise(function (success, error) {
	            delete self._collectionCache[contentType];
	            self.persister.purge(contentType, function () {
	                var cachingIsEnabled = self.everlive.setup.caching && self.everlive.setup.caching.enabled === true;
	                if (cachingIsEnabled) {
	                    self.everlive.cache.clear(contentType, success, error);
	                }
	                else {
	                    success();
	                }
	            }, error);
	        }, success, error);
	    };
	    return OfflineQueryProcessor;
	}());
	exports.OfflineQueryProcessor = OfflineQueryProcessor;
	var _a;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var DataQuery_1 = __webpack_require__(15);
	var EverliveError_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(2);
	var RequestOptionsBuilder_1 = __webpack_require__(33);
	var utils_1 = __webpack_require__(4);
	var Request_1 = __webpack_require__(9);
	var offlineTransformations_1 = __webpack_require__(30);
	var OfflineQueryProcessor_1 = __webpack_require__(62);
	var OfflineFilesProcessor_1 = __webpack_require__(61);
	var OfflineFilesModule_1 = __webpack_require__(60);
	var Query_1 = __webpack_require__(6);
	var RequestService_1 = __webpack_require__(10);
	var syncLocation = {
	    server: 'server',
	    client: 'client'
	};
	function getSyncFilterForItem(item) {
	    var filter = getSyncFilterNoModifiedAt(item);
	    filter.ModifiedAt = item.ModifiedAt;
	    return filter;
	}
	function getSyncFilterNoModifiedAt(item) {
	    return {
	        Id: item.Id
	    };
	}
	/**
	 * @class OfflineModule
	 * @classDesc A class providing access to the various offline storage features.
	 */
	/**
	 * Represents the {@link OfflineModule} class.
	 * @memberOf Everlive.prototype
	 * @member {OfflineModule} offlineStorage
	 */
	var OfflineStorageModule = (function () {
	    function OfflineStorageModule(_everlive, options, persister, _encryptionProvider) {
	        this._everlive = _everlive;
	        this.options = options;
	        this._encryptionProvider = _encryptionProvider;
	        this._isSynchronizing = false;
	        this.offlineFilesProcessor = new OfflineFilesProcessor_1.OfflineFilesProcessor(this.options, this._everlive);
	        this.queryProcessor = new OfflineQueryProcessor_1.OfflineQueryProcessor(persister, _encryptionProvider, this.offlineFilesProcessor, this._everlive, this.options);
	        this.files = new OfflineFilesModule_1.OfflineFilesModule(this.offlineFilesProcessor, this._everlive, this.options.files.maxConcurrentDownloads);
	    }
	    /**
	     * Removes all data from the offline storage. If caching is enabled clears the entire cache as well.
	     * @method purgeAll
	     * @name purgeAll
	     * @memberOf OfflineModule.prototype
	     * @param {function} [success] A success callback.
	     * @param {function} [error] An error callback.
	     */
	    /**
	     * Removes all data from the offline storage. If caching is enabled clears the entire cache as well.
	     * @method purgeAll
	     * @name purgeAll
	     * @memberOf OfflineModule.prototype
	     * @returns {Promise}
	     */
	    OfflineStorageModule.prototype.purgeAll = function (success, error) {
	        return this.queryProcessor.purgeAll(success, error);
	    };
	    /**
	     * Removes all data for a specific content type from the offline storage. If caching is enabled clears the cache
	     * for the specified content type as well.
	     * @method purge
	     * @name purge
	     * @memberOf OfflineModule.prototype
	     * @param {string} contentType The content type to purge.
	     * @param {function} [success] A success callback.
	     * @param {function} [error] An error callback.
	     */
	    /**
	     * Removes all data for a specific content type from the offline storage. If caching is enabled clears the cache
	     * for the specified content type as well.
	     * @method purge
	     * @name purge
	     * @memberOf OfflineModule.prototype
	     * @param {string} contentType The content type to purge.
	     * @returns {Promise}
	     */
	    OfflineStorageModule.prototype.purge = function (contentType, success, error) {
	        return this.queryProcessor.purge(contentType, success, error);
	    };
	    OfflineStorageModule.prototype.processQuery = function (query) {
	        return this.queryProcessor.processQuery(query);
	    };
	    OfflineStorageModule.prototype._setOffline = function (offline) {
	        this.options.offline = offline;
	    };
	    OfflineStorageModule.prototype.isOnline = function () {
	        return !this.options.offline;
	    };
	    OfflineStorageModule.prototype._prepareSyncData = function (contentTypesForSync) {
	        var self = this;
	        var contentTypesSyncData = {};
	        var conflicts = [];
	        _.each(contentTypesForSync, function (contentType, typeName) {
	            var syncItems = offlineTransformations_1.offlineTransformations.idTransform(contentType.offlineItemsToSync);
	            var syncData = self._getSyncItemStates(typeName, syncItems, contentType.serverItems);
	            conflicts.push(syncData.conflicts);
	            contentTypesSyncData[typeName] = syncData.itemsForSync;
	        });
	        return {
	            conflicts: conflicts,
	            contentTypesSyncData: contentTypesSyncData
	        };
	    };
	    OfflineStorageModule.prototype._resolveConflicts = function (syncData) {
	        var self = this;
	        return this._applyResolutionStrategy(syncData.conflicts)
	            .then(function () {
	            return self._mergeResolvedConflicts(syncData.conflicts, syncData.contentTypesSyncData);
	        })
	            .then(function () {
	            return syncData.contentTypesSyncData;
	        });
	    };
	    OfflineStorageModule.prototype.isSynchronizing = function () {
	        return this._isSynchronizing;
	    };
	    OfflineStorageModule.prototype._fireSyncStart = function () {
	        var self = this;
	        return new Promise(function (resolve) {
	            if (!self._isSynchronizing) {
	                self._isSynchronizing = true;
	                self._everlive.emit(constants_1.Constants.Events.SyncStart);
	                resolve();
	            }
	            else {
	                resolve();
	            }
	        });
	    };
	    OfflineStorageModule.prototype._fireSyncEnd = function () {
	        this._isSynchronizing = false;
	        this._everlive.emit(constants_1.Constants.Events.SyncEnd, this._syncResultInfo);
	        this._syncResultInfo = null;
	    };
	    OfflineStorageModule.prototype._eachSyncItem = function (items, getFilterFunction, contentTypeName, operation) {
	        var self = this;
	        _.each(items, function (item) {
	            var itemFilter = getFilterFunction(item.remoteItem);
	            // if we already have an error for this item we do not want to try and sync it again
	            var resultItem = item.resultingItem;
	            var isCustom = item.isCustom;
	            var resolutionType = item.resolutionType;
	            if (_.some(self._syncResultInfo.failedItems[contentTypeName], {
	                itemId: resultItem.Id
	            })) {
	                return;
	            }
	            operation(resultItem, itemFilter, isCustom, resolutionType);
	        });
	    };
	    OfflineStorageModule.prototype._shouldAutogenerateIdForContentType = function (collectionName) {
	        return this.queryProcessor._shouldAutogenerateIdForContentType(collectionName);
	    };
	    OfflineStorageModule.prototype._addCreatedFileToSyncPromises = function (resultingItemsForCreate, syncPromises, collectionName) {
	        var self = this;
	        _.each(resultingItemsForCreate, function (item) {
	            var filesCollection = self._everlive.files;
	            syncPromises[item.Id] = new Promise(function (resolve, reject) {
	                self.files.getOfflineLocation(item.Id)
	                    .then(function (location) {
	                    if (location) {
	                        return self._transferFile(false, item, location);
	                    }
	                }, function (err) {
	                    reject({
	                        type: constants_1.Constants.offlineItemStates.created,
	                        items: item,
	                        contentType: collectionName,
	                        error: err,
	                        storage: syncLocation.server
	                    });
	                })
	                    .then(function (res) {
	                    var mergedWithServerResponseItem = _.extend({}, item, res.result);
	                    self._onItemProcessed(mergedWithServerResponseItem, collectionName, syncLocation.server, constants_1.Constants.offlineItemStates.created);
	                    return filesCollection
	                        .isSync(true)
	                        .useOffline(true)
	                        .updateSingle(mergedWithServerResponseItem);
	                }, function (err) {
	                    reject({
	                        type: constants_1.Constants.offlineItemStates.created,
	                        items: item,
	                        contentType: collectionName,
	                        error: err,
	                        storage: syncLocation.server
	                    });
	                })
	                    .then(resolve, function (err) {
	                    reject({
	                        type: constants_1.Constants.offlineItemStates.modified,
	                        items: item,
	                        contentType: collectionName,
	                        error: err,
	                        storage: syncLocation.client
	                    });
	                });
	            });
	        });
	    };
	    OfflineStorageModule.prototype._transferFile = function (isUpdate, item, location) {
	        var sdk = this._everlive;
	        return new Promise(function (resolve, reject) {
	            var self = this;
	            var uploadUrl = sdk.files.getUploadUrl();
	            var fileExistsPromise = utils_1.Utils.successfulPromise();
	            if (isUpdate) {
	                fileExistsPromise = new Promise(function (resolve) {
	                    sdk.files
	                        .isSync(true)
	                        .applyOffline(false)
	                        .getById(item.Id)
	                        .then(function () {
	                        resolve(true);
	                    })
	                        .catch(function () {
	                        resolve(false);
	                    });
	                });
	            }
	            fileExistsPromise.then(function (fileExistsOnServer) {
	                var canUpdate = isUpdate && fileExistsOnServer;
	                if (canUpdate) {
	                    uploadUrl += '/' + item.Id + '/Content';
	                }
	                var fileTransfer = new FileTransfer();
	                var fileKey = constants_1.Constants.fileUploadKey;
	                var options = {
	                    fileKey: fileKey,
	                    httpMethod: canUpdate ? 'PUT' : 'POST',
	                    mimeType: item.ContentType,
	                    fileName: item.Filename,
	                    headers: sdk.buildAuthHeader(),
	                    params: {}
	                };
	                _.each(item, function (value, key) {
	                    if (key.toLowerCase() !== 'base64') {
	                        var prefixedKey = constants_1.Constants.fileUploadKey + constants_1.Constants.fileUploadDelimiter + key;
	                        options.params[prefixedKey] = value;
	                    }
	                });
	                fileTransfer.upload(location, uploadUrl, function (result) {
	                    var parsedResult = utils_1.Utils.parseUtilities.parseJSON(result.response);
	                    if (parsedResult.Result === false) {
	                        reject.apply(self, arguments);
	                    }
	                    else if (_.isArray(parsedResult.Result)) {
	                        resolve({
	                            result: parsedResult.Result[0]
	                        });
	                    }
	                    else {
	                        resolve(parsedResult);
	                    }
	                }, reject, options, true);
	            });
	        });
	    };
	    OfflineStorageModule.prototype._addCreatedObjectToSyncPromises = function (syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids) {
	        var self = this;
	        var promise = new Promise(function (resolve, reject) {
	            dataCollection
	                .isSync(true)
	                .applyOffline(false)
	                .create(resultingItemsForCreate)
	                .then(function (res) {
	                resultingItemsForCreate = _.map(resultingItemsForCreate, function (item, index) {
	                    item.Id = res.result[index].Id;
	                    item.CreatedAt = item.ModifiedAt = res.result[index].CreatedAt;
	                    var resultingItem = _.find(contentTypeData.createdItems, function (createdItem) {
	                        return createdItem.resultingItem.Id === item.Id;
	                    });
	                    if (resultingItem.isCustom) {
	                        self._onItemProcessed(item, collectionName, syncLocation.client, constants_1.Constants.offlineItemStates.modified);
	                    }
	                    return item;
	                });
	            }, function (err) {
	                var error = err.error || err;
	                throw {
	                    type: constants_1.Constants.offlineItemStates.created,
	                    items: resultingItemsForCreate,
	                    contentType: collectionName,
	                    error: error,
	                    storage: syncLocation.server
	                };
	            })
	                .then(function () {
	                return dataCollection
	                    .isSync(true)
	                    .useOffline(true)
	                    .create(resultingItemsForCreate)
	                    .then(function () {
	                    _.each(resultingItemsForCreate, function (createdItem) {
	                        self._onItemProcessed(createdItem, collectionName, syncLocation.server, constants_1.Constants.offlineItemStates.created);
	                    });
	                }, function (err) {
	                    throw {
	                        type: constants_1.Constants.offlineItemStates.created,
	                        items: resultingItemsForCreate,
	                        contentType: collectionName,
	                        error: err,
	                        storage: syncLocation.client
	                    };
	                });
	            })
	                .then(function () {
	                if (ids && ids.length) {
	                    var filter = {
	                        Id: {
	                            $in: ids
	                        }
	                    };
	                    return dataCollection
	                        .isSync(true)
	                        .useOffline(true)
	                        .destroy(filter)
	                        .catch(function (err) {
	                        throw {
	                            type: constants_1.Constants.offlineItemStates.created,
	                            items: resultingItemsForCreate,
	                            contentType: collectionName,
	                            error: err,
	                            storage: syncLocation.client
	                        };
	                    });
	                }
	            })
	                .then(resolve)
	                .catch(function (err) {
	                reject(err);
	            });
	        });
	        _.each(resultingItemsForCreate, function (item) {
	            syncPromises[item.Id] = promise;
	        });
	        return resultingItemsForCreate;
	    };
	    OfflineStorageModule.prototype._addCreatedItemsForSync = function (contentTypeData, syncPromises, dataCollection) {
	        var collectionName = dataCollection.collectionName;
	        var resultingItemsForCreate = _.pluck(contentTypeData.createdItems, 'resultingItem');
	        var ids;
	        if (!this._shouldAutogenerateIdForContentType(collectionName)) {
	            ids = _.pluck(resultingItemsForCreate, 'Id');
	            resultingItemsForCreate = offlineTransformations_1.offlineTransformations.removeIdTransform(resultingItemsForCreate);
	        }
	        if (utils_1.Utils.isContentType.files(collectionName)) {
	            return this._addCreatedFileToSyncPromises(resultingItemsForCreate, syncPromises, collectionName);
	        }
	        else {
	            return this._addCreatedObjectToSyncPromises(syncPromises, dataCollection, resultingItemsForCreate, contentTypeData, collectionName, ids);
	        }
	    };
	    OfflineStorageModule.prototype._addUpdatedItemsForSync = function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemUpdateOperation) {
	        var self = this;
	        var collectionName = dataCollection.collectionName;
	        self._eachSyncItem(contentTypeData.modifiedItems, getFilterOperation, collectionName, itemUpdateOperation);
	    };
	    OfflineStorageModule.prototype._addDeletedItemsForSync = function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemDeleteOperation) {
	        var self = this;
	        var collectionName = dataCollection.collectionName;
	        self._eachSyncItem(contentTypeData.deletedItems, getFilterOperation, collectionName, itemDeleteOperation);
	    };
	    OfflineStorageModule.prototype._onSyncResponse = function (res, item, collectionName, operation, isCustomItem) {
	        var self = this;
	        if (res.result !== 1) {
	            return new Promise(function (resolve, reject) {
	                reject(_.extend({}, EverliveError_1.EverliveErrors.syncConflict, {
	                    contentType: collectionName
	                }));
	            });
	        }
	        else {
	            if (operation === DataQuery_1.DataQuery.operations.Update) {
	                self._onItemProcessed(item, collectionName, syncLocation.server, constants_1.Constants.offlineItemStates.modified);
	                var updatedItem = _.extend({}, item, {
	                    ModifiedAt: res.ModifiedAt
	                });
	                //TODO: use the new way of building DataQueries
	                var updateQuery = new DataQuery_1.DataQuery({
	                    operation: operation,
	                    data: updatedItem,
	                    additionalOptions: {
	                        id: item.Id
	                    },
	                    meta: {
	                        collectionName: collectionName,
	                    },
	                    isSync: true
	                });
	                return this.processQuery(updateQuery)
	                    .then(function () {
	                    if (isCustomItem) {
	                        var existingItem = _.find(self._syncResultInfo.syncedItems[collectionName], function (syncedItem) {
	                            return syncedItem.itemId === item.Id;
	                        });
	                        if (!existingItem) {
	                            self._onItemProcessed(item, collectionName, syncLocation.client, constants_1.Constants.offlineItemStates.modified);
	                        }
	                    }
	                });
	            }
	            else if (operation === DataQuery_1.DataQuery.operations.Delete) {
	                self._onItemProcessed(item, collectionName, syncLocation.server, constants_1.Constants.offlineItemStates.deleted);
	                return this._purgeById(collectionName, item.Id)
	                    .then(function () {
	                    if (isCustomItem) {
	                        self._onItemProcessed(item, collectionName, syncLocation.client, constants_1.Constants.offlineItemStates.deleted);
	                    }
	                });
	            }
	        }
	    };
	    OfflineStorageModule.prototype._purgeById = function (contentType, itemId) {
	        var self = this;
	        return this.queryProcessor._getCollection(contentType)
	            .then(function (collection) {
	            delete collection[itemId];
	            return self.queryProcessor._persistData(contentType);
	        });
	    };
	    OfflineStorageModule.prototype.sync = function () {
	        var self = this;
	        self._syncResultInfo = self._syncResultInfo || {
	            syncedItems: {},
	            syncedToServer: 0,
	            syncedToClient: 0,
	            failedItems: {},
	            error: undefined // added for visibility
	        };
	        if (!this.isOnline()) {
	            throw new EverliveError_1.EverliveError({ message: 'Cannot synchronize while offline' });
	        }
	        self._fireSyncStart()
	            .then(function () {
	            return self._applySync();
	        })
	            .then(function (syncResults) {
	            var conflictsWhileSync = [];
	            _.each(syncResults, function (syncResult, itemId) {
	                if (syncResult && syncResult.state === 'rejected') {
	                    if (syncResult.reason && syncResult.reason.code === EverliveError_1.EverliveErrors.syncConflict.code) {
	                        conflictsWhileSync.push(syncResult);
	                    }
	                    else {
	                        // to save time and traffic we are using a single create request for all items
	                        // this is why if there is an error we need to split the items we tried to create
	                        // and set the same error for all items.
	                        self._onItemFailed(syncResult, itemId);
	                    }
	                }
	            });
	            if (conflictsWhileSync.length) {
	                return self.sync();
	            }
	            else {
	                self._fireSyncEnd();
	            }
	        })
	            .catch(function (err) {
	            if (!err) {
	                err = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.syncErrorUnknown);
	            }
	            self._syncResultInfo.error = err;
	            self._fireSyncEnd();
	        });
	    };
	    OfflineStorageModule.prototype._handleKeepServer = function (typeName, conflictingItem, offlineSyncOperations, contentTypeSyncData) {
	        var self = this;
	        var serverItem = conflictingItem.serverItem;
	        var clientItem = conflictingItem.clientItem;
	        var syncQuery;
	        if (serverItem && clientItem) {
	            // update the item offline
	            syncQuery = new DataQuery_1.DataQuery({
	                meta: {
	                    collectionName: typeName,
	                },
	                operation: DataQuery_1.DataQuery.operations.Update,
	                additionalOptions: {
	                    id: serverItem.Id
	                },
	                data: serverItem
	            });
	        }
	        else if (serverItem && !clientItem) {
	            // create item offline
	            syncQuery = new DataQuery_1.DataQuery({
	                meta: {
	                    collectionName: typeName,
	                },
	                operation: DataQuery_1.DataQuery.operations.Create,
	                data: serverItem
	            });
	        }
	        else if (!serverItem && clientItem) {
	            // delete item offline
	            syncQuery = new DataQuery_1.DataQuery({
	                meta: {
	                    collectionName: typeName,
	                },
	                operation: DataQuery_1.DataQuery.operations.DeleteById,
	                additionalOptions: {
	                    id: clientItem.Id
	                }
	            });
	        }
	        else {
	            throw new EverliveError_1.EverliveError({ message: 'Both serverItem and clientItem are not set when syncing data with "KeepServer" resolution strategy.' });
	        }
	        syncQuery.isSync = true;
	        offlineSyncOperations.push(new Promise(function (resolve, reject) {
	            self.processQuery(syncQuery)
	                .then(function () {
	                switch (syncQuery.operation) {
	                    case DataQuery_1.DataQuery.operations.Update:
	                        self._onItemProcessed(serverItem, typeName, syncLocation.client, constants_1.Constants.offlineItemStates.modified);
	                        // the files content type is special and needs to enable the file contents offline, so we cannot only
	                        // update the data
	                        if (utils_1.Utils.isContentType.files(typeName)) {
	                            contentTypeSyncData.modifiedItems.push({
	                                remoteItem: conflictingItem.serverItem,
	                                resultingItem: serverItem,
	                                resolutionType: constants_1.Constants.ConflictResolution.KeepServer
	                            });
	                        }
	                        break;
	                    case DataQuery_1.DataQuery.operations.Create:
	                        self._onItemProcessed(serverItem, typeName, syncLocation.client, constants_1.Constants.offlineItemStates.created);
	                        break;
	                    case DataQuery_1.DataQuery.operations.DeleteById:
	                        self._onItemProcessed(clientItem, typeName, syncLocation.client, constants_1.Constants.offlineItemStates.deleted);
	                        break;
	                }
	                resolve();
	            }, function (err) {
	                var itemId;
	                var operation;
	                switch (syncQuery.operation) {
	                    case DataQuery_1.DataQuery.operations.Update:
	                        itemId = serverItem.Id;
	                        operation = constants_1.Constants.offlineItemStates.modified;
	                        break;
	                    case DataQuery_1.DataQuery.operations.Create:
	                        itemId = serverItem.Id;
	                        operation = constants_1.Constants.offlineItemStates.created;
	                        break;
	                    case DataQuery_1.DataQuery.operations.DeleteById:
	                        itemId = clientItem.Id;
	                        operation = constants_1.Constants.offlineItemStates.deleted;
	                        break;
	                }
	                reject({
	                    itemId: itemId,
	                    type: operation,
	                    contentType: syncQuery.collectionName,
	                    error: err,
	                    storage: syncLocation.client
	                });
	            });
	        }));
	    };
	    OfflineStorageModule.prototype._handleKeepClient = function (conflictingItem, contentTypeSyncData) {
	        var serverItem = conflictingItem.serverItem;
	        var clientItem = conflictingItem.clientItem;
	        var resultingItem;
	        var collection;
	        if (serverItem && clientItem) {
	            resultingItem = _.extend(clientItem, {
	                ModifiedAt: new Date(serverItem.ModifiedAt)
	            });
	            collection = contentTypeSyncData.modifiedItems;
	        }
	        else if (serverItem && !clientItem) {
	            resultingItem = serverItem;
	            collection = contentTypeSyncData.deletedItems;
	        }
	        else if (!serverItem && clientItem) {
	            resultingItem = clientItem;
	            collection = contentTypeSyncData.createdItems;
	        }
	        else {
	            throw new EverliveError_1.EverliveError({ message: 'Both serverItem and clientItem are not set when syncing data with "KeepClient" resolution strategy.' });
	        }
	        collection.push({
	            remoteItem: conflictingItem.serverItem,
	            resultingItem: resultingItem,
	            resolutionType: constants_1.Constants.ConflictResolution.KeepClient
	        });
	    };
	    OfflineStorageModule.prototype._handleCustom = function (conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData) {
	        var serverItem = conflictingItem.serverItem;
	        var clientItem = conflictingItem.clientItem;
	        var customItem = _.omit(conflictingItem.result.item, 'CreatedAt', 'ModifiedAt');
	        if (serverItem && customItem) {
	            var createItemOfflineQuery = new DataQuery_1.DataQuery({
	                meta: {
	                    collectionName: typeName
	                },
	                operation: DataQuery_1.DataQuery.operations.Create,
	                data: serverItem,
	                preserveState: true,
	                isSync: true
	            });
	            offlineSyncOperations.push(this.processQuery(createItemOfflineQuery));
	            this._onItemProcessed(serverItem, typeName, syncLocation.client, constants_1.Constants.offlineItemStates.created);
	        }
	        if (serverItem && customItem && !clientItem) {
	            customItem.Id = serverItem.Id;
	            contentTypeSyncData.modifiedItems.push({
	                remoteItem: serverItem,
	                resultingItem: customItem,
	                isCustom: true
	            });
	        }
	        else if (serverItem && !customItem) {
	            contentTypeSyncData.deletedItems.push({
	                remoteItem: conflictingItem.serverItem,
	                resultingItem: serverItem,
	                isCustom: true
	            });
	        }
	        else if (!serverItem && customItem && clientItem) {
	            var updateItemOfflineQuery = new DataQuery_1.DataQuery({
	                meta: {
	                    collectionName: typeName
	                },
	                operation: DataQuery_1.DataQuery.operations.Update,
	                data: customItem,
	                additionalOptions: {
	                    id: clientItem.Id
	                }
	            });
	            offlineSyncOperations.push(this.processQuery(updateItemOfflineQuery));
	            customItem.Id = clientItem.Id;
	            contentTypeSyncData.createdItems.push({
	                remoteItem: serverItem,
	                resultingItem: customItem,
	                isCustom: true
	            });
	        }
	        else {
	            customItem.Id = serverItem.Id;
	            contentTypeSyncData.modifiedItems.push({
	                remoteItem: serverItem,
	                resultingItem: customItem,
	                isCustom: true
	            });
	        }
	    };
	    OfflineStorageModule.prototype._mergeResolvedConflicts = function (conflicts, syncData) {
	        var self = this;
	        var offlineSyncOperations = [];
	        _.each(conflicts, function (conflict) {
	            var typeName = conflict.contentTypeName;
	            _.each(conflict.conflictingItems, function (conflictingItem) {
	                var contentTypeSyncData = syncData[typeName];
	                switch (conflictingItem.result.resolutionType) {
	                    case constants_1.Constants.ConflictResolution.KeepServer:
	                        self._handleKeepServer(typeName, conflictingItem, offlineSyncOperations, contentTypeSyncData);
	                        break;
	                    case constants_1.Constants.ConflictResolution.KeepClient:
	                        self._handleKeepClient(conflictingItem, contentTypeSyncData);
	                        break;
	                    case constants_1.Constants.ConflictResolution.Custom:
	                        if (utils_1.Utils.isContentType.files(typeName)) {
	                            throw new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.customFileSyncNotSupported);
	                        }
	                        self._handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData);
	                        break;
	                    case constants_1.Constants.ConflictResolution.Skip:
	                        break;
	                }
	            });
	        });
	        return Promise.all(offlineSyncOperations);
	    };
	    OfflineStorageModule.prototype._getSyncItemStates = function (contentType, offlineItems, serverItems) {
	        var self = this;
	        var contentTypeSyncData = {
	            itemsForSync: {
	                createdItems: [],
	                modifiedItems: [],
	                modifiedItemsOnServer: [],
	                deletedItems: [],
	                deletedItemsOnServer: []
	            },
	            conflicts: {
	                contentTypeName: contentType,
	                conflictingItems: []
	            }
	        };
	        _.each(offlineItems, function (offlineItem) {
	            var serverItem = _.findWhere(serverItems, {
	                Id: offlineItem.Id
	            });
	            if (serverItem) {
	                if (serverItem.Id === offlineItem.Id && offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.created) {
	                    if (self.options.conflicts.strategy === constants_1.Constants.ConflictResolutionStrategy.Custom) {
	                        self._onItemFailed({
	                            type: constants_1.Constants.offlineItemStates.modified,
	                            storage: syncLocation.client,
	                            error: new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.syncError),
	                            contentType: contentType
	                        }, offlineItem.Id);
	                        return self._onItemFailed({
	                            type: constants_1.Constants.offlineItemStates.modified,
	                            storage: syncLocation.server,
	                            error: new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.syncError),
	                            contentType: contentType
	                        }, serverItem.Id);
	                    }
	                    else {
	                        return self._onItemFailed({
	                            type: constants_1.Constants.offlineItemStates.created,
	                            storage: syncLocation.client,
	                            error: new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.syncError),
	                            contentType: contentType
	                        }, serverItem.Id);
	                    }
	                }
	                var clientItemChanged = !!offlineItem[constants_1.Constants.offlineItemsStateMarker];
	                var hasUpdateConflict = false;
	                if (clientItemChanged) {
	                    hasUpdateConflict = serverItem.ModifiedAt.getTime() !== offlineItem.ModifiedAt.getTime() || offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.deleted;
	                }
	                if (hasUpdateConflict) {
	                    contentTypeSyncData.conflicts.conflictingItems.push({
	                        // if the item was modified on the server and deleted locally we have a conflict and set the client item to null
	                        // otherwise it is a simple modification conflict
	                        clientItem: offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.deleted ? null : offlineItem,
	                        serverItem: serverItem,
	                        result: {}
	                    });
	                }
	                else {
	                    if (offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.deleted) {
	                        contentTypeSyncData.itemsForSync.deletedItems.push({
	                            remoteItem: serverItem,
	                            resultingItem: offlineItem
	                        });
	                    }
	                    else if (offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.modified) {
	                        contentTypeSyncData.itemsForSync.modifiedItems.push({
	                            remoteItem: serverItem,
	                            resultingItem: offlineItem
	                        });
	                    }
	                    else if (offlineItem[constants_1.Constants.offlineItemsStateMarker] === undefined) {
	                        contentTypeSyncData.itemsForSync.modifiedItemsOnServer.push(serverItem);
	                    }
	                    else {
	                        contentTypeSyncData.itemsForSync.modifiedItems.push({
	                            remoteItem: serverItem,
	                            resultingItem: serverItem
	                        });
	                    }
	                }
	            }
	            else {
	                // if the item in memory has been modified, but the item on the server has been deleted
	                if (offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.modified) {
	                    contentTypeSyncData.conflicts.conflictingItems.push({
	                        clientItem: offlineItem,
	                        serverItem: null,
	                        result: {}
	                    });
	                }
	                else if (offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.created) {
	                    contentTypeSyncData.itemsForSync.createdItems.push({
	                        remoteItem: serverItem,
	                        resultingItem: offlineItem
	                    });
	                }
	                else {
	                    contentTypeSyncData.itemsForSync.deletedItemsOnServer.push(offlineItem);
	                }
	            }
	            delete offlineItem[constants_1.Constants.offlineItemsStateMarker];
	        });
	        return contentTypeSyncData;
	    };
	    OfflineStorageModule.prototype._setResolutionTypeForItem = function (resolutionType, conflictingItem) {
	        conflictingItem.result = {
	            resolutionType: resolutionType
	        };
	    };
	    OfflineStorageModule.prototype._applyResolutionStrategy = function (conflicts) {
	        var self = this;
	        var conflictResolutionStrategy = self.options.conflicts.strategy;
	        return new Promise(function (resolve, reject) {
	            var conflictResolutionPromises = [];
	            for (var i = 0; i < conflicts.length; i++) {
	                var conflict = conflicts[i];
	                if (conflict.conflictingItems.length) {
	                    switch (conflictResolutionStrategy) {
	                        case constants_1.Constants.ConflictResolutionStrategy.ServerWins:
	                            _.each(conflict.conflictingItems, self._setResolutionTypeForItem.bind(self, constants_1.Constants.ConflictResolution.KeepServer));
	                            break;
	                        case constants_1.Constants.ConflictResolutionStrategy.Custom:
	                            var customStrategy = self.options.conflicts.implementation;
	                            if (!customStrategy) {
	                                return reject(new EverliveError_1.EverliveError({ message: 'Implementation of the conflict resolution strategy ' +
	                                        'must be provided when set to Custom' }));
	                            }
	                            conflictResolutionPromises.push(new Promise(function (resolve) {
	                                customStrategy(conflicts, resolve);
	                            }));
	                            break;
	                        default:
	                            return reject(new EverliveError_1.EverliveError({ message: 'Invalid resolution strategy provided' }));
	                    }
	                }
	            }
	            Promise.all(conflictResolutionPromises)
	                .then(function () {
	                resolve();
	            });
	        });
	    };
	    OfflineStorageModule.prototype._getSyncPromiseBatch = function (contentType, batchIds) {
	        var self = this;
	        var dataQuery = new DataQuery_1.DataQuery({
	            meta: {
	                collectionName: contentType
	            },
	            query: new Query_1.Query({
	                'Id': {
	                    '$in': batchIds
	                }
	            }),
	            operation: DataQuery_1.DataQuery.operations.Read,
	            applyOffline: false
	        });
	        var getRequestOptionsFromQuery = RequestOptionsBuilder_1.RequestOptionsBuilder[dataQuery.operation];
	        var requestOptions = getRequestOptionsFromQuery(dataQuery);
	        var request = new Request_1.Request(self._everlive.setup, requestOptions);
	        return RequestService_1.RequestService.sendRequest(request);
	    };
	    OfflineStorageModule.prototype._getPlainItemsForSync = function (collection, forceDirty) {
	        if (this.options.syncUnmodified && !forceDirty) {
	            return _.values(collection);
	        }
	        else {
	            return this.queryProcessor._getDirtyItems(collection);
	        }
	    };
	    OfflineStorageModule.prototype._getIdsForSync = function (contentType, offlineItemsToSync) {
	        if (this._shouldAutogenerateIdForContentType(contentType)) {
	            return _.pluck(offlineItemsToSync, '_id');
	        }
	        else {
	            return _.pluck(_.reject(offlineItemsToSync, function (offlineItem) {
	                return offlineItem[constants_1.Constants.offlineItemsStateMarker] === constants_1.Constants.offlineItemStates.created;
	            }), '_id');
	        }
	    };
	    OfflineStorageModule.prototype._getSyncPromiseForCollection = function (collection, contentType) {
	        var batches = [];
	        var batchSize = constants_1.Constants.syncBatchSize;
	        var offlineItemsToSync = this._getPlainItemsForSync(collection);
	        var allIdsForSync = this._getIdsForSync(contentType, offlineItemsToSync);
	        var batchCount = Math.ceil(allIdsForSync.length / batchSize);
	        for (var i = 0; i < batchCount; i++) {
	            var batchSkipSize = i * batchSize;
	            var batchIds = allIdsForSync.slice(batchSkipSize, batchSkipSize + batchSize);
	            var syncGetServerItemsPromise = this._getSyncPromiseBatch(contentType, batchIds);
	            batches.push(syncGetServerItemsPromise);
	        }
	        return Promise.all(batches)
	            .then(function (serverItemsSyncResponses) {
	            var result = {
	                serverItems: [],
	                offlineItemsToSync: offlineItemsToSync
	            };
	            _.each(serverItemsSyncResponses, function (serverItems) {
	                result.serverItems = _.union(result.serverItems, serverItems);
	            });
	            return result;
	        });
	    };
	    OfflineStorageModule.prototype._onItemFailed = function (syncResult, itemId) {
	        var self = this;
	        var results = syncResult.reason ? syncResult.reason : syncResult;
	        var targetType = results.contentType;
	        var getFailedItem = function (id) {
	            var pickedObject = _.pick(results, 'storage', 'type', 'error');
	            if (!pickedObject.error) {
	                pickedObject.error = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.syncErrorUnknown);
	            }
	            return _.extend({
	                itemId: id,
	                contentType: targetType
	            }, pickedObject);
	        };
	        var failedItems = [];
	        if (results.type === constants_1.Constants.offlineItemStates.created && results.items) {
	            failedItems = _.map(results.items, function (item) {
	                return getFailedItem(item.Id);
	            });
	        }
	        else {
	            failedItems.push(getFailedItem(itemId));
	        }
	        self._syncResultInfo.failedItems[targetType] = self._syncResultInfo.failedItems[targetType] || [];
	        _.each(failedItems, function (failedItem) {
	            self._syncResultInfo.failedItems[targetType].push(failedItem);
	            self._fireItemProcessed(failedItem);
	        });
	    };
	    OfflineStorageModule.prototype._onItemProcessed = function (item, contentType, syncStorage, syncType) {
	        var syncInfo = {
	            itemId: item.Id,
	            type: syncType,
	            storage: syncStorage,
	            contentType: contentType
	        };
	        this._syncResultInfo.syncedItems[contentType] = this._syncResultInfo.syncedItems[contentType] || [];
	        this._syncResultInfo.syncedItems[contentType].push(syncInfo);
	        if (syncInfo.storage == syncLocation.server) {
	            this._syncResultInfo.syncedToServer++;
	        }
	        else {
	            this._syncResultInfo.syncedToClient++;
	        }
	        this._fireItemProcessed(syncInfo);
	    };
	    OfflineStorageModule.prototype._fireItemProcessed = function (syncInfo) {
	        this._everlive.emit(constants_1.Constants.Events.ItemProcessed, syncInfo);
	    };
	    OfflineStorageModule.prototype._getClientWinsSyncData = function (collections, forceDirty) {
	        var self = this;
	        var syncData = {};
	        _.each(collections, function (collection, typeName) {
	            if (!syncData[typeName]) {
	                syncData[typeName] = {
	                    createdItems: [],
	                    modifiedItems: [],
	                    deletedItems: [],
	                    deletedItemsOnServer: [],
	                    modifiedItemsOnServer: []
	                };
	            }
	            var plainItems = self._getPlainItemsForSync(collection, forceDirty);
	            var itemsForSync = offlineTransformations_1.offlineTransformations.idTransform(plainItems);
	            _.each(itemsForSync, function (itemForSync) {
	                switch (itemForSync[constants_1.Constants.offlineItemsStateMarker]) {
	                    case constants_1.Constants.offlineItemStates.created:
	                        syncData[typeName].createdItems.push({
	                            remoteItem: itemForSync,
	                            resultingItem: itemForSync
	                        });
	                        break;
	                    case constants_1.Constants.offlineItemStates.modified:
	                        syncData[typeName].modifiedItems.push({
	                            remoteItem: itemForSync,
	                            resultingItem: itemForSync
	                        });
	                        break;
	                    case constants_1.Constants.offlineItemStates.deleted:
	                        syncData[typeName].deletedItems.push({
	                            remoteItem: itemForSync,
	                            resultingItem: itemForSync
	                        });
	                        break;
	                }
	                delete itemForSync[constants_1.Constants.offlineItemsStateMarker];
	            });
	        });
	        return syncData;
	    };
	    OfflineStorageModule.prototype._getModifiedFilesForSyncClientWins = function (itemId, item, collectionName) {
	        var self = this;
	        var sdk = self._everlive;
	        return new Promise(function (resolve, reject) {
	            var offlineFiles = self.files;
	            offlineFiles.getOfflineLocation(itemId)
	                .then(function (location) {
	                if (location) {
	                    return self._transferFile(true, item, location)
	                        .then(function (result) {
	                        if (result.Result === false) {
	                            reject({
	                                type: constants_1.Constants.offlineItemStates.modified,
	                                itemId: item.Id,
	                                contentType: collectionName,
	                                error: result,
	                                storage: syncLocation.server
	                            });
	                        }
	                        else {
	                            return {
	                                result: result
	                            };
	                        }
	                    }, function (err) {
	                        reject({
	                            type: constants_1.Constants.offlineItemStates.modified,
	                            itemId: item.Id,
	                            contentType: collectionName,
	                            error: err,
	                            storage: syncLocation.server
	                        });
	                    });
	                }
	                else {
	                    return sdk.files
	                        .isSync(true)
	                        .applyOffline(false)
	                        .updateSingle(item)
	                        .then(function (response) {
	                        return response;
	                    }, function (err) {
	                        reject({
	                            type: constants_1.Constants.offlineItemStates.modified,
	                            itemId: item.Id,
	                            contentType: collectionName,
	                            error: err,
	                            storage: syncLocation.server
	                        });
	                    });
	                }
	            })
	                .then(function (onlineResponse) {
	                var onlineResult = onlineResponse.result;
	                item.ModifiedAt = onlineResult.ModifiedAt;
	                self._onItemProcessed(item, collectionName, syncLocation.server, constants_1.Constants.offlineItemStates.modified);
	                return sdk.files
	                    .isSync(true)
	                    .useOffline(true)
	                    .updateSingle(item);
	            })
	                .then(resolve)
	                .catch(function (err) {
	                reject({
	                    type: constants_1.Constants.offlineItemStates.modified,
	                    itemId: item.Id,
	                    contentType: collectionName,
	                    error: err,
	                    storage: syncLocation.server
	                });
	            });
	        });
	    };
	    OfflineStorageModule.prototype._getModifiedItemForSyncClientWins = function (dataCollection, item, collectionName) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            return dataCollection
	                .isSync(true)
	                .applyOffline(false)
	                .updateSingle(item)
	                .then(function (res) {
	                self._onItemProcessed(item, collectionName, syncLocation.server, constants_1.Constants.offlineItemStates.modified);
	                var updatedItem = _.extend({}, item, {
	                    ModifiedAt: res.ModifiedAt
	                });
	                var updateQuery = new DataQuery_1.DataQuery({
	                    operation: DataQuery_1.DataQuery.operations.Update,
	                    data: updatedItem,
	                    additionalOptions: {
	                        id: item.Id
	                    },
	                    meta: {
	                        collectionName: collectionName
	                    },
	                    isSync: true
	                });
	                return self.processQuery(updateQuery);
	            }, function (res) {
	                reject({
	                    storage: syncLocation.server,
	                    type: constants_1.Constants.offlineItemStates.modified,
	                    itemId: item.Id,
	                    contentType: collectionName,
	                    error: res
	                });
	            })
	                .then(resolve, function (err) {
	                reject({
	                    storage: syncLocation.client,
	                    type: constants_1.Constants.offlineItemStates.modified,
	                    itemId: item.Id,
	                    contentType: collectionName,
	                    error: err
	                });
	            });
	        });
	    };
	    OfflineStorageModule.prototype._addModifiedItemsForSyncClientWins = function (contentTypeData, syncPromises, dataCollection) {
	        var self = this;
	        this._addUpdatedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item) {
	            var itemId = item.Id;
	            if (!itemId) {
	                throw new EverliveError_1.EverliveError({ message: 'When updating an item it must have an Id field.' });
	            }
	            var collectionName = dataCollection.collectionName;
	            if (utils_1.Utils.isContentType.files(collectionName)) {
	                syncPromises[itemId] = self._getModifiedFilesForSyncClientWins(itemId, item, collectionName);
	            }
	            else {
	                syncPromises[itemId] = self._getModifiedItemForSyncClientWins(dataCollection, item, collectionName);
	            }
	        });
	    };
	    OfflineStorageModule.prototype._addDeletedItemsForSyncClientWins = function (contentTypeData, syncPromises, dataCollection) {
	        var self = this;
	        this._addDeletedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item, itemFilter) {
	            var collectionName = dataCollection.collectionName;
	            syncPromises[item.Id] = new Promise(function (resolve, reject) {
	                var itemId = item.Id;
	                if (!itemId) {
	                    throw new EverliveError_1.EverliveError({ message: 'When deleting an item it must have an Id field.' });
	                }
	                return dataCollection
	                    .isSync(true)
	                    .applyOffline(false)
	                    .destroySingle(itemFilter)
	                    .then(function () {
	                    self._onItemProcessed(item, collectionName, syncLocation.server, constants_1.Constants.offlineItemStates.deleted);
	                    return self._purgeById(collectionName, item.Id).then(function () {
	                        resolve();
	                    }, function (err) {
	                        reject(_.extend({}, {
	                            storage: syncLocation.client,
	                            type: constants_1.Constants.offlineItemStates.deleted,
	                            contentType: collectionName,
	                            itemId: itemId,
	                            error: err
	                        }));
	                    });
	                }, function (err) {
	                    reject(_.extend({}, {
	                        storage: syncLocation.server,
	                        type: constants_1.Constants.offlineItemStates.deleted,
	                        contentType: collectionName,
	                        error: err,
	                        itemId: itemId
	                    }));
	                });
	            });
	        });
	    };
	    OfflineStorageModule.prototype._applyClientWins = function (collections) {
	        var self = this;
	        var syncData = this._getClientWinsSyncData(collections, true);
	        var syncPromises = {};
	        _.each(syncData, function (contentTypeData, typeName) {
	            var dataCollection = self._everlive.data(typeName);
	            if (contentTypeData.createdItems.length) {
	                self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
	            }
	            if (contentTypeData.modifiedItems.length) {
	                self._addModifiedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
	            }
	            if (contentTypeData.deletedItems.length) {
	                self._addDeletedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
	            }
	        });
	        var syncResult;
	        return utils_1.Utils.promiseHashSettled(syncPromises)
	            .then(function (result) {
	            syncResult = result;
	            if (self.options.syncUnmodified) {
	                var promises = [];
	                _.each(collections, function (collection, collectionName) {
	                    var allOfflineItems = self._getPlainItemsForSync(collection);
	                    var itemsToDownload = _.where(allOfflineItems, function (offlineItem) {
	                        return offlineItem[constants_1.Constants.offlineItemsStateMarker] !== undefined;
	                    });
	                    var DataCollection = self._everlive.data(collectionName);
	                    var itemIdsForSync = _.pluck(itemsToDownload, '_id');
	                    var downloadPromise = DataCollection
	                        .isSync(true)
	                        .useOffline(false)
	                        .get({
	                        Id: {
	                            $in: itemIdsForSync
	                        }
	                    })
	                        .then(function (res) {
	                        var serverItems = res.result;
	                        var serverItemIds = _.pluck(serverItems, 'Id');
	                        return self._unmodifiedClientWinsItemsDeletedOnServer(collectionName, serverItemIds, itemsToDownload)
	                            .then(function () {
	                            return self._unmodifiedClientWinsItemsUpdatedOnServer(collectionName, serverItems, itemsToDownload);
	                        });
	                    });
	                    promises.push(downloadPromise);
	                });
	                return Promise.all(promises);
	            }
	        })
	            .then(function () {
	            return syncResult;
	        });
	    };
	    OfflineStorageModule.prototype._unmodifiedClientWinsItemsDeletedOnServer = function (collectionName, serverItemIds, clientItems) {
	        var self = this;
	        var itemsForDeleteIds = [];
	        var itemIdsForSync = _.pluck(clientItems, '_id');
	        _.each(itemIdsForSync, function (itemId) {
	            if (serverItemIds.indexOf(itemId) === -1) {
	                itemsForDeleteIds.push(itemId);
	            }
	        });
	        return utils_1.Utils.successfulPromise()
	            .then(function () {
	            if (itemsForDeleteIds.length !== 0) {
	                var deleteQuery = new DataQuery_1.DataQuery({
	                    operation: DataQuery_1.DataQuery.operations.Delete,
	                    filter: {
	                        Id: {
	                            $in: itemsForDeleteIds
	                        }
	                    },
	                    meta: {
	                        collectionName: collectionName
	                    },
	                    isSync: true
	                });
	                return self.processQuery(deleteQuery).then(function () {
	                    _.each(itemsForDeleteIds, function (itemsForDeleteId) {
	                        self._onItemProcessed({ Id: itemsForDeleteId }, collectionName, syncLocation.client, constants_1.Constants.offlineItemStates.deleted);
	                    });
	                });
	            }
	        });
	    };
	    OfflineStorageModule.prototype._unmodifiedClientWinsItemsUpdatedOnServer = function (collectionName, serverItems, clientItems) {
	        var self = this;
	        var updatePromises = [];
	        _.each(serverItems, function (serverItem) {
	            var item = _.find(clientItems, function (clientItem) {
	                return clientItem._id === serverItem.Id;
	            });
	            if (item) {
	                var updateQuery = new DataQuery_1.DataQuery({
	                    operation: DataQuery_1.DataQuery.operations.Update,
	                    data: serverItem,
	                    additionalOptions: {
	                        id: item._id
	                    },
	                    meta: {
	                        collectionName: collectionName
	                    },
	                    isSync: true
	                });
	                var itemUpdatedPromise = self.processQuery(updateQuery)
	                    .then(function (res) {
	                    self._onItemProcessed(serverItem, collectionName, syncLocation.client, constants_1.Constants.offlineItemStates.modified);
	                });
	                updatePromises.push(itemUpdatedPromise);
	            }
	        });
	        return Promise.all(updatePromises);
	    };
	    OfflineStorageModule.prototype._modifyFileStandardSync = function (syncPromises, itemId, item, collectionName, resolutionType) {
	        var self = this;
	        var filesCollection = self._everlive.files;
	        syncPromises[itemId] = new Promise(function (resolve, reject) {
	            var offlineLocation;
	            self.files.getOfflineLocation(itemId)
	                .then(function (locationOnDisk) {
	                offlineLocation = locationOnDisk;
	            })
	                .then(function () {
	                return filesCollection
	                    .isSync(true)
	                    .applyOffline(false)
	                    .getById(itemId);
	            })
	                .then(function (response) {
	                var file = response.result;
	                if (file.ModifiedAt.getTime() !== item.ModifiedAt.getTime()) {
	                    reject(_.extend({}, new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.syncConflict), {
	                        contentType: collectionName
	                    }));
	                }
	                else {
	                    if (offlineLocation) {
	                        if (resolutionType === constants_1.Constants.ConflictResolution.KeepServer) {
	                            return self.files._saveFile(item.Uri, item.Filename, item.Id)
	                                .then(function () {
	                                return self.offlineFilesProcessor.purge(offlineLocation);
	                            })
	                                .then(function () {
	                                return response;
	                            });
	                        }
	                        else if (resolutionType === constants_1.Constants.ConflictResolution.KeepClient) {
	                            return self._transferFile(true, item, offlineLocation);
	                        }
	                    }
	                }
	            })
	                .then(function () {
	                return self._everlive.files
	                    .isSync(true)
	                    .useOffline(true)
	                    .updateSingle(item);
	            })
	                .then(resolve)
	                .catch(reject);
	        });
	    };
	    OfflineStorageModule.prototype._modifyContentTypeStandardSync = function (syncPromises, itemId, dataCollection, item, itemFilter, collectionName, isCustom) {
	        var self = this;
	        syncPromises[itemId] = dataCollection
	            .isSync(true)
	            .applyOffline(false)
	            .update(item, itemFilter)
	            .then(function (res) {
	            return self._onSyncResponse(res, item, collectionName, DataQuery_1.DataQuery.operations.Update, isCustom);
	        }, function (err) {
	            return new Promise(function (resolve, reject) {
	                reject({
	                    type: constants_1.Constants.offlineItemStates.modified,
	                    itemId: item.Id,
	                    contentType: collectionName,
	                    error: err,
	                    storage: syncLocation.server
	                });
	            });
	        });
	    };
	    OfflineStorageModule.prototype._applyStandardSync = function (collections) {
	        var self = this;
	        var promises = {};
	        _.each(collections, function (collection, contentType) {
	            promises[contentType] = self._getSyncPromiseForCollection(collection, contentType);
	        });
	        return utils_1.Utils.promiseHash(promises)
	            .then(function (contentTypes) {
	            return self._prepareSyncData(contentTypes);
	        })
	            .then(function (syncData) {
	            return self._resolveConflicts(syncData);
	        })
	            .then(function (contentTypeSyncData) {
	            var syncPromises = {};
	            _.each(contentTypeSyncData, function (contentTypeData, collectionName) {
	                var dataCollection = self._everlive.data(collectionName);
	                if (contentTypeData.createdItems.length) {
	                    self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
	                }
	                if (contentTypeData.modifiedItems.length) {
	                    self._addUpdatedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom, resolutionType) {
	                        var itemId = item.Id;
	                        if (utils_1.Utils.isContentType.files(collectionName)) {
	                            self._modifyFileStandardSync(syncPromises, itemId, item, collectionName, resolutionType);
	                        }
	                        else {
	                            self._modifyContentTypeStandardSync(syncPromises, itemId, dataCollection, item, itemFilter, collectionName, isCustom);
	                        }
	                    });
	                }
	                if (contentTypeData.deletedItems.length) {
	                    self._addDeletedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter, isCustom) {
	                        syncPromises[item.Id] = dataCollection
	                            .isSync(true)
	                            .applyOffline(false)
	                            .destroy(itemFilter)
	                            .then(function (res) {
	                            return self._onSyncResponse(res, item, collectionName, DataQuery_1.DataQuery.operations.Delete, isCustom);
	                        }, function (err) {
	                            return new Promise(function (resolve, reject) {
	                                reject({
	                                    type: constants_1.Constants.offlineItemStates.deleted,
	                                    itemId: item.Id,
	                                    contentType: collectionName,
	                                    error: err,
	                                    storage: syncLocation.server
	                                });
	                            });
	                        });
	                    });
	                }
	                _.each(contentTypeData.deletedItemsOnServer, function (item) {
	                    syncPromises[item.Id] = dataCollection
	                        .isSync(true)
	                        .useOffline(true)
	                        .destroySingle({
	                        Id: item.Id
	                    })
	                        .then(function (res) {
	                        return self._onItemProcessed(item, collectionName, syncLocation.client, constants_1.Constants.offlineItemStates.deleted);
	                    }, function (err) {
	                        return new Promise(function (resolve, reject) {
	                            reject({
	                                type: constants_1.Constants.offlineItemStates.deleted,
	                                itemId: item.Id,
	                                contentType: collectionName,
	                                error: err,
	                                storage: syncLocation.client
	                            });
	                        });
	                    });
	                });
	                _.each(contentTypeData.modifiedItemsOnServer, function (item) {
	                    syncPromises[item.Id] = dataCollection
	                        .isSync(true)
	                        .useOffline(true)
	                        .update(item, {
	                        Id: item.Id
	                    })
	                        .then(function (res) {
	                        return self._onItemProcessed(item, collectionName, syncLocation.client, constants_1.Constants.offlineItemStates.modified);
	                    }, function (err) {
	                        return utils_1.Utils.rejectedPromise({
	                            type: constants_1.Constants.offlineItemStates.modified,
	                            itemId: item.Id,
	                            contentType: collectionName,
	                            error: err,
	                            storage: syncLocation.client
	                        });
	                    });
	                });
	            });
	            return utils_1.Utils.promiseHashSettled(syncPromises);
	        });
	    };
	    OfflineStorageModule.prototype._applySync = function () {
	        var self = this;
	        return this.queryProcessor._getAllCollections()
	            .then(function (collections) {
	            if (self.options.conflicts.strategy === constants_1.Constants.ConflictResolutionStrategy.ClientWins) {
	                return self._applyClientWins(collections);
	            }
	            else {
	                return self._applyStandardSync(collections);
	            }
	        });
	    };
	    /**
	     * Get all the offline items that have not been synced online.
	     * @method getItemsForSync
	     * @name getItemsForSync
	     * @memberOf OfflineModule.prototype
	     * @param {function} [success] A success callback.
	     * @param {function} [error] An error callback.
	     */
	    /**
	     * Get all the offline items that have not been synced online.
	     * @method getItemsForSync
	     * @name getItemsForSync
	     * @memberOf OfflineModule.prototype
	     * @returns {Promise}
	     */
	    OfflineStorageModule.prototype.getItemsForSync = function (success, error) {
	        var self = this;
	        var plainItemsForSync = {};
	        return utils_1.Utils.buildPromise(function (successCb, errorCb) {
	            self.queryProcessor._getAllCollections()
	                .then(function (collections) {
	                _.each(collections, function (collection, collectionName) {
	                    var plainItems = self._getPlainItemsForSync(collection);
	                    plainItemsForSync[collectionName] = _.map(plainItems, function (item) {
	                        var itemForSync = {
	                            item: _.extend({}, item),
	                            action: item[constants_1.Constants.offlineItemsStateMarker]
	                        };
	                        delete itemForSync.item[constants_1.Constants.offlineItemsStateMarker];
	                        return itemForSync;
	                    });
	                });
	                successCb(plainItemsForSync);
	            }).catch(errorCb);
	        }, success, error);
	    };
	    return OfflineStorageModule;
	}());
	exports.OfflineStorageModule = OfflineStorageModule;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var FileStore_1 = __webpack_require__(34);
	var BasePersister_1 = __webpack_require__(20);
	var FileSystemPersister = (function (_super) {
	    __extends(FileSystemPersister, _super);
	    /**
	     * @class FileSystemPersister
	     * @protected
	     * @extends BasePersister
	     */
	    function FileSystemPersister(key, options) {
	        _super.call(this, key, options);
	        this.fileStore = FileStore_1.getFileStore(options.storage.storagePath, options);
	    }
	    FileSystemPersister.prototype.getAllData = function (success, error) {
	        var errorHandler = this._fileSystemErrorHandler(error);
	        _super.prototype.getAllData.call(this, success, errorHandler);
	    };
	    FileSystemPersister.prototype.getData = function (contentType, success, error) {
	        var _this = this;
	        var errorHandler = this._fileSystemErrorHandler(error);
	        this.getFileHandle(contentType, function (fileEntry) {
	            _this._readFileContent(fileEntry, success, errorHandler);
	        }, error);
	    };
	    FileSystemPersister.prototype.saveData = function (contentType, data, success, error) {
	        var _this = this;
	        var errorHandler = this._fileSystemErrorHandler(error);
	        this.getFileHandle(contentType, function (fileEntry) {
	            _this._writeFileContent(fileEntry, data, function () {
	                _this._saveContentTypes(contentType, success, errorHandler);
	            }, errorHandler);
	        }, errorHandler);
	    };
	    FileSystemPersister.prototype.purge = function (contentType, success, error) {
	        var _this = this;
	        var errorHandler = this._fileSystemErrorHandler(error);
	        this.getFileHandle(contentType, function (fileEntry) {
	            _this.fileStore.removeFile(fileEntry).then(function () {
	                success();
	            }).catch(error);
	        }, errorHandler);
	    };
	    FileSystemPersister.prototype.purgeAll = function (success, error) {
	        var errorHandler = this._fileSystemErrorHandler(error);
	        this.fileStore.removeFilesDirectory()
	            .then(function () {
	            success();
	        })
	            .catch(errorHandler);
	    };
	    FileSystemPersister.prototype.getFileHandle = function (contentType, success, error) {
	        var _this = this;
	        var path = this._getFilePath(contentType);
	        this.fileStore.getFilesDirectory()
	            .then(function () {
	            return _this.fileStore.getFile(path);
	        })
	            .then(function (fileHandle) {
	            success(fileHandle);
	        })
	            .catch(error);
	    };
	    FileSystemPersister.prototype._getContentTypes = function (success, error) {
	        this.getData(this.contentTypesStoreKey, function (savedContentTypesRaw) {
	            var savedContentTypes = JSON.parse(savedContentTypesRaw || '[]');
	            success(savedContentTypes);
	        }, error);
	    };
	    FileSystemPersister.prototype._saveContentTypes = function (contentType, success, error) {
	        var _this = this;
	        this._getContentTypes(function (savedContentTypes) {
	            if (!_.contains(savedContentTypes, contentType)) {
	                savedContentTypes.push(contentType);
	            }
	            _this.getFileHandle(_this.contentTypesStoreKey, function (contentTypesFile) {
	                _this._writeFileContent(contentTypesFile, JSON.stringify(savedContentTypes), success, error);
	            }, error);
	        }, error);
	    };
	    FileSystemPersister.prototype._readFileContent = function (fileEntry, success, error) {
	        this.fileStore.readFileAsText(fileEntry).then(function (content) {
	            success(content);
	        }).catch(error);
	    };
	    FileSystemPersister.prototype._writeFileContent = function (fileEntry, content, success, error) {
	        this.fileStore.writeTextToFile(fileEntry, content)
	            .then(success)
	            .catch(error);
	    };
	    FileSystemPersister.prototype._getFilePath = function (contentType) {
	        return this._getKey(contentType);
	        //return utils.joinPath(this.fileStore.filesDirectoryPath, this._getKey(contentType));
	    };
	    FileSystemPersister.prototype._fileSystemErrorHandler = function (callback) {
	        return this.fileStore.getErrorHandler(callback);
	    };
	    return FileSystemPersister;
	}(BasePersister_1.BasePersister));
	exports.FileSystemPersister = FileSystemPersister;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var LocalStore_1 = __webpack_require__(35);
	var BasePersister_1 = __webpack_require__(20);
	var LocalStoragePersister = (function (_super) {
	    __extends(LocalStoragePersister, _super);
	    /**
	     * @class LocalStoragePersister
	     * @extends BasePersister
	     */
	    function LocalStoragePersister(key, options) {
	        _super.call(this, key, options);
	        this._localStore = new LocalStore_1.LocalStore(options);
	    }
	    LocalStoragePersister.prototype.getData = function (contentType, success, error) {
	        try {
	            var key = this._getKey(contentType);
	            var storedItem = this._getItem(key);
	            success(storedItem);
	        }
	        catch (e) {
	            error(e);
	        }
	    };
	    LocalStoragePersister.prototype.saveData = function (contentType, data, success, error) {
	        try {
	            var contentTypeKey = this._getKey(contentType);
	            this._setItem(contentTypeKey, data);
	            success();
	        }
	        catch (e) {
	            error(e);
	        }
	    };
	    LocalStoragePersister.prototype.purge = function (contentType, success, error) {
	        var _this = this;
	        try {
	            var key = this._getKey(contentType);
	            this._removeItem(key);
	            this._getContentTypes(function (contentTypes) {
	                contentTypes = _.without(contentTypes, contentType);
	                _this._setContentTypesCollection(contentTypes);
	                success();
	            }, error);
	        }
	        catch (e) {
	            error(e);
	        }
	    };
	    LocalStoragePersister.prototype.purgeAll = function (success, error) {
	        var _this = this;
	        try {
	            this._getContentTypes(function (contentTypes) {
	                _.each(contentTypes, function (contentType) {
	                    var contentTypeKey = _this._getKey(contentType);
	                    _this._removeItem(contentTypeKey);
	                });
	                _this._removeItem(_this.contentTypesStoreKey);
	                success();
	            }, error);
	        }
	        catch (e) {
	            error(e);
	        }
	    };
	    LocalStoragePersister.prototype._getItem = function (key) {
	        return this._localStore.getItem(key);
	    };
	    LocalStoragePersister.prototype._setItem = function (key, value) {
	        return this._localStore.setItem(key, value);
	    };
	    LocalStoragePersister.prototype._removeItem = function (key) {
	        return this._localStore.removeItem(key);
	    };
	    LocalStoragePersister.prototype._getKey = function (contentType) {
	        this._addTypeToCollectionsCache(contentType);
	        return _super.prototype._getKey.call(this, contentType);
	    };
	    LocalStoragePersister.prototype._getContentTypes = function (success, error) {
	        try {
	            var localStorageString = this._getItem(this.contentTypesStoreKey);
	            var data = [];
	            if (localStorageString) {
	                data = JSON.parse(localStorageString);
	            }
	            success(data);
	        }
	        catch (e) {
	            error(e);
	        }
	    };
	    LocalStoragePersister.prototype._setContentTypesCollection = function (collection) {
	        this._setItem(this.contentTypesStoreKey, JSON.stringify(collection));
	    };
	    LocalStoragePersister.prototype._addTypeToCollectionsCache = function (typeName) {
	        var _this = this;
	        var err;
	        this._getContentTypes(function (contentTypes) {
	            if (!_.contains(contentTypes, typeName)) {
	                contentTypes.push(typeName);
	                _this._setContentTypesCollection(contentTypes);
	            }
	        }, function (e) { return err = e; });
	        if (err) {
	            throw err;
	        }
	    };
	    return LocalStoragePersister;
	}(BasePersister_1.BasePersister));
	exports.LocalStoragePersister = LocalStoragePersister;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var platform = __webpack_require__(5);
	function getCurrentDevice(pushHandler) {
	    if (platform.isNativeScript) {
	        var NativeScriptCurrentDevice = __webpack_require__(32);
	        return new NativeScriptCurrentDevice(pushHandler);
	    }
	    else if (platform.isCordova || platform.isDesktop) {
	        var CordovaCurrentDevice = __webpack_require__(31);
	        return new CordovaCurrentDevice(pushHandler);
	    }
	    else {
	        return {};
	    }
	}
	exports.getCurrentDevice = getCurrentDevice;
	function ensurePushIsAvailable() {
	    if (platform.isNativeScript) {
	        var NativeScriptCurrentDevice = __webpack_require__(32);
	        NativeScriptCurrentDevice.ensurePushIsAvailable();
	    }
	    else if (platform.isCordova || platform.isDesktop) {
	        var CordovaCurrentDevice = __webpack_require__(31);
	        CordovaCurrentDevice.ensurePushIsAvailable();
	    }
	}
	exports.ensurePushIsAvailable = ensurePushIsAvailable;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Constants_1 = __webpack_require__(8);
	var constants_1 = __webpack_require__(2);
	/**
	 * @class EventQuery
	 * @classdesc A query which is passed in the 'beforeExecute' event of [Everlive]{@link Everlive}. Allows changing the parameters of
	 * a query before executing it.
	 */
	var EventQuery = (function () {
	    function EventQuery() {
	    }
	    EventQuery.fromDataQuery = function (dataQuery) {
	        var eventQuery = new EventQuery();
	        eventQuery.contentTypeName = dataQuery.collectionName;
	        if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
	            switch (dataQuery.operation) {
	                case Constants_1.DataQueryOperation.Update:
	                    eventQuery.operation = Constants_1.DataQueryOperation.UpdateById;
	                    break;
	                case Constants_1.DataQueryOperation.Delete:
	                    eventQuery.operation = Constants_1.DataQueryOperation.DeleteById;
	                    break;
	                default:
	                    eventQuery.operation = dataQuery.operation;
	            }
	        }
	        else {
	            eventQuery.operation = dataQuery.operation;
	        }
	        eventQuery.itemId = dataQuery.additionalOptions ? dataQuery.additionalOptions.id : undefined;
	        eventQuery.data = dataQuery.data;
	        applyDataQuerySettings(eventQuery, dataQuery);
	        applyDataQueryParameters(eventQuery, dataQuery);
	        eventQuery.headers = dataQuery.getHeaders();
	        var powerFieldsHeader = eventQuery.headers[constants_1.Constants.Headers.powerFields];
	        if (typeof powerFieldsHeader === 'string') {
	            eventQuery.powerfields = JSON.parse(powerFieldsHeader);
	        }
	        eventQuery.isSync = dataQuery.isSync; // readonly
	        return eventQuery;
	    };
	    /**
	     * Cancels the query.
	     * @memberOf EventQuery.prototype
	     * @method cancel
	     */
	    EventQuery.prototype.cancel = function () {
	        this._cancelled = true;
	    };
	    /**
	     * Indicates whether the query has been canceled.
	     * @memberOf EventQuery.prototype
	     * @method isCanceled
	     * @returns {boolean}
	     */
	    EventQuery.prototype.isCancelled = function () {
	        return this._cancelled;
	    };
	    return EventQuery;
	}());
	exports.EventQuery = EventQuery;
	/** The name of the content type, e.g. EmailSubcrbers.
	 * @memberOf EventQuery.prototype
	 * @member {string} contentTypeName
	 */
	/** The query data which will be send to the server.
	 * @memberOf EventQuery.prototype
	 * @member {Object} data
	 */
	/** The query headers which will be send with the HTTP request.
	 * @memberOf EventQuery.prototype
	 * @member {Object} headers
	 */
	/** The Id of the item.
	 * @memberOf EventQuery.prototype
	 * @member {string} itemId
	 */
	/** The type of the operation--read, write, update, delete.
	 * @memberOf EventQuery.prototype
	 * @member {string} operation
	 */
	/** A power fields expression.
	 * @memberOf EventQuery.prototype
	 * @member {string} powerfields
	 * @deprecated
	 */
	/** A custom settings object.
	 * @memberOf EventQuery.prototype
	 * @member {string} settings
	 */
	/** A [filter expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-filtering) definition.
	 * @memberOf EventQuery.prototype
	 * @member {Object} filter
	 */
	/** A [fields expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-subset-fields) definition.
	 * @memberOf EventQuery.prototype
	 * @member {Object} fields
	 */
	/** A [sort expression](http://docs.telerik.com/platform/backend-services/rest/queries/queries-sorting) definition.
	 * @memberOf EventQuery.prototype
	 * @member {Object} sort
	 */
	/** The number of result items to skip. Used for paging.
	 * @memberOf EventQuery.prototype
	 * @member {Number} skip
	 */
	/** The number of result items to take. Used for paging.
	 * @memberOf EventQuery.prototype
	 * @member {Number} take
	 */
	/** An [expand expression](http://docs.telerik.com/platform/backend-services/javascript/data/relations/relations-defining) definition.
	 * @memberOf EventQuery.prototype
	 * @member {Object} expand
	 */
	/** Indicates whether the query is a synchronization query. Used with Offline Support.
	 * @memberOf EventQuery.prototype
	 * @member {boolean} isSync
	 * @readonly
	 */
	function applyDataQueryParameters(eventQuery, dataQuery) {
	    var queryParameters = dataQuery.getQueryParameters();
	    eventQuery.filter = queryParameters.filter;
	    eventQuery.fields = queryParameters.select;
	    eventQuery.sort = queryParameters.sort;
	    eventQuery.skip = queryParameters.skip;
	    eventQuery.take = queryParameters.limit || queryParameters.take;
	    eventQuery.expand = queryParameters.expand;
	    eventQuery.aggregate = queryParameters.aggregate;
	    return queryParameters;
	}
	/** An object allowing to modify the settings of the EventQuery.
	 * @memberOf EventQuery.prototype
	 * @member {Object} settings
	 * @property {boolean} useOffline - Modifies whether the query should be invoked on the offline storage.
	 * @property {boolean} applyOffline - Modifies whether the query should be applied offline if the SDK is currently working online. Default is true. Only valid when offlineStorage is enabled.
	 * @property {boolean} ignoreCache - Does not use the cache when retrieving the data. Only valid when caching is enabled.
	 * @property {boolean} forceCache - Forces the request to get the data from the cache even if the data is already expired. Only valid when caching is enabled.
	 */
	function applyDataQuerySettings(eventQuery, dataQuery) {
	    eventQuery.settings = {
	        useOffline: dataQuery.useOffline,
	        applyOffline: dataQuery.applyOffline,
	        ignoreCache: dataQuery.ignoreCache,
	        forceCache: dataQuery.forceCache
	    };
	}


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Expression_1 = __webpack_require__(18);
	var constants_1 = __webpack_require__(2);
	var OperatorType = constants_1.Constants.OperatorType;
	/**
	 * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
	 * @class WhereQuery
	 * @protected
	 * @borrows WhereQuery#eq as WhereQuery#equal
	 * @borrows WhereQuery#ne as WhereQuery#notEqual
	 * @borrows WhereQuery#gt as WhereQuery#greaterThan
	 * @borrows WhereQuery#gte as WhereQuery#greaterThanEqual
	 * @borrows WhereQuery#lt as WhereQuery#lessThan
	 * @borrows WhereQuery#lte as WhereQuery#lessThanEqual
	 */
	var WhereQuery = (function () {
	    function WhereQuery(parentQuery, exprOp, singleOperand) {
	        this.parent = parentQuery;
	        this.single = singleOperand;
	        this.expr = new Expression_1.Expression(exprOp || OperatorType.where);
	        this.parent.expr.addOperand(this.expr);
	    }
	    /**
	     * Adds an `and` clause to the current condition and returns it for further chaining.
	     * @method and
	     * @memberOf WhereQuery.prototype
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.and = function () {
	        return new WhereQuery(this, OperatorType.and);
	    };
	    /**
	     * Adds an `or` clause to the current condition and returns it for further chaining.
	     * @method or
	     * @memberOf WhereQuery.prototype
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.or = function () {
	        return new WhereQuery(this, OperatorType.or);
	    };
	    /**
	     * Adds a `not` clause to the current condition and returns it for further chaining.
	     * @method not
	     * @memberOf WhereQuery.prototype
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.not = function () {
	        return new WhereQuery(this, OperatorType.not, true);
	    };
	    WhereQuery.prototype._simple = function (operator) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        this.expr.addOperand(new Expression_1.Expression(operator, args));
	        return this._done();
	    };
	    /**
	     * Adds a condition that a field must be equal to a specific value.
	     * @method eq
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {*} value Comparison value (to which the fields must be equal).
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.eq = function (field, value) {
	        return this._simple(OperatorType.equal, field, value);
	    };
	    /**
	     * Adds a condition that a field must *not* be equal to a specific value.
	     * @method ne
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {*} value Comparison value (to which the field must not be equal).
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.ne = function (field, value) {
	        return this._simple(OperatorType.not_equal, field, value);
	    };
	    /**
	     * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
	     * @method gt
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {*} value Comparison value (that the field should be greater than).
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.gt = function (field, value) {
	        return this._simple(OperatorType.gt, field, value);
	    };
	    /**
	     * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
	     * @method gte
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {*} value Comparison value (that the field should be greater than or equal to).
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.gte = function (field, value) {
	        return this._simple(OperatorType.gte, field, value);
	    };
	    /**
	     * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
	     * @method lt
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {*} value Comparison value (that the field should be less than).
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.lt = function (field, value) {
	        return this._simple(OperatorType.lt, field, value);
	    };
	    /**
	     * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
	     * @method lte
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {*} value Comparison value (that the field should be less than or equal to).
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.lte = function (field, value) {
	        return this._simple(OperatorType.lte, field, value);
	    };
	    /**
	     * Adds a condition that a field must be in a set of values.
	     * @method isin
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {Array} value An array of the values that the field should be in.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.isin = function (field, value) {
	        return this._simple(OperatorType.isin, field, value);
	    };
	    /**
	     * Adds a condition that a field must *not* be in a set of values.
	     * @method notin
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {Array} value An array of values that the field should not be in.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.notin = function (field, value) {
	        return this._simple(OperatorType.notin, field, value);
	    };
	    /**
	     * Adds a condition that a field must include *all* of the specified values. Applicable to Array fields.
	     * @method all
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {Array} value An array of values that the field must include.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.all = function (field, value) {
	        return this._simple(OperatorType.all, field, value);
	    };
	    /**
	     * Adds a condition that a field must contain an array whose length is larger than a specified value. Applicable to Array fields.
	     * @method size
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {number} value The size that the array must be bigger than.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.size = function (field, value) {
	        return this._simple(OperatorType.size, field, value);
	    };
	    /**
	     * Adds a condition that a field must satisfy a specified regex.
	     * @method regex
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {string} regularExpression Regular expression in PCRE format.
	     * @param {string} [options] A string of regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.regex = function (field, value, flags) {
	        return this._simple(OperatorType.regex, field, value, flags);
	    };
	    /**
	     * Adds a condition that a field value must *start* with a specified string.
	     * @method startsWith
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {string} value The string that the field should start with.
	     * @param {string} [options] A string of regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.startsWith = function (field, value, flags) {
	        return this._simple(OperatorType.startsWith, field, value, flags);
	    };
	    /**
	     * Adds a condition that a field value must *end* with a specified string.
	     * @method endsWith
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name.
	     * @param {string} value The string that the field should end with.
	     * @param {string} [options] A string of  regex options to use. See [specs](http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options) for a description of available options.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.endsWith = function (field, value, flags) {
	        return this._simple(OperatorType.endsWith, field, value, flags);
	    };
	    /**
	     * Adds a Geospatial condition that a specified geopoint must be within a certain distance from another geopoint. Applicable to GeoPoint fields only.
	     * @method nearSphere
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
	     * @param {Everlive.GeoPoint} point Comparison geopoint value.
	     * @param {number} distance Distance value.
	     * @param {string} [metrics=radians] A string representing what unit of measurement is used for distance. Possible values: radians, km, miles.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.nearSphere = function (field, point, distance, metrics) {
	        return this._simple(OperatorType.nearShpere, field, point, distance, metrics);
	    };
	    /**
	     * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate rectangle. Applicable to GeoPoint fields only.
	     * @method withinBox
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
	     * @param {Everlive.GeoPoint} pointBottomLeft Value representing the bottom left corner of the box.
	     * @param {Everlive.GeoPoint} pointUpperRight Value representing the upper right corner of the box.
	     * @example ```js
	     var query = new Everlive.Query();
	     query.where().withinBox('Location',
	     new Everlive.GeoPoint(23.317871, 42.687709),
	     new Everlive.GeoPoint(23.331346, 42.707075));
	     ```
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.withinBox = function (field, pointBottomLeft, pointUpperRight) {
	        return this._simple(OperatorType.withinBox, field, pointBottomLeft, pointUpperRight);
	    };
	    /**
	     * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate polygon. The polygon is specified as an array of geopoints. The last point in the array is implicitly connected to the first point thus closing the shape. Applicable to GeoPoint fields only.
	     * @method withinPolygon
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
	     * @param {Everlive.GeoPoint[]} points Comparison value in the form of an array of geopoints defining the polygon.
	     * @example ```js
	     var point1 = new Everlive.GeoPoint(23.317871, 42.687709);
	     var point2 = new Everlive.GeoPoint(42.698749, 42.698749);
	     var point3 = new Everlive.GeoPoint(23.331346, 42.702282);
	
	     var query = new Everlive.Query();
	     query.where().withinPolygon("location", [point1, point2, point3]);
	     * ```
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.withinPolygon = function (field, points) {
	        return this._simple(OperatorType.withinPolygon, field, points);
	    };
	    /**
	     * Adds a Geospatial condition that a specified geopoint must be within a coordinate circle. Applicable to GeoPoint fields only.
	     * @method withinCenterSphere
	     * @memberOf WhereQuery.prototype
	     * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
	     * @param {Everlive.GeoPoint} center Comparison value specifying the center of the coordinate circle.
	     * @param {number} radius Value specifying the radius length.
	     * @param {string} [metrics=radians] A string representing what unit of measurement is used for radius length. Possible values: radians, km, miles.
	     * @returns {WhereQuery}
	     */
	    WhereQuery.prototype.withinCenterSphere = function (field, center, radius, metrics) {
	        return this._simple(OperatorType.withinShpere, field, center, radius, metrics);
	    };
	    /**
	     * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent `Query`. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
	     * @method done
	     * @memberOf WhereQuery.prototype
	     * @returns {Query}
	     */
	    WhereQuery.prototype.done = function () {
	        if (this.parent instanceof WhereQuery) {
	            return this.parent._done();
	        }
	        else {
	            return this.parent;
	        }
	    };
	    WhereQuery.prototype._done = function () {
	        if (this.single) {
	            return this.parent;
	        }
	        else {
	            return this;
	        }
	    };
	    WhereQuery.prototype.equal = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this.eq.apply(this, args);
	    };
	    WhereQuery.prototype.notEqual = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this.ne.apply(this, args);
	    };
	    WhereQuery.prototype.greaterThan = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this.gt.apply(this, args);
	    };
	    WhereQuery.prototype.greaterThanEqual = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this.gt.apply(this, args);
	    };
	    WhereQuery.prototype.lessThan = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this.lt.apply(this, args);
	    };
	    WhereQuery.prototype.lessThanEqual = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        return this.lt.apply(this, args);
	    };
	    return WhereQuery;
	}());
	exports.WhereQuery = WhereQuery;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var http = __webpack_require__(132);
	var constants_1 = __webpack_require__(2);
	// NodeJS nulls header name casing by lowering all casing,
	// we simulate this in NS with this function to avoid header name issues
	function getCaseInsensitiveHeaders(headers) {
	    var result = {};
	    for (var headerName in headers) {
	        if (headers.hasOwnProperty(headerName)) {
	            result[headerName.toLowerCase()] = headers[headerName];
	        }
	    }
	    return result;
	}
	function reqwest(options) {
	    var httpRequestOptions = {
	        url: options.url,
	        method: options.method,
	        headers: options.headers || {}
	    };
	    if (options.data) {
	        httpRequestOptions.content = options.data; // NOTE: If we pass null/undefined, it will raise an exception in the http module.
	    }
	    httpRequestOptions.headers[constants_1.Constants.Headers.ContentType] = httpRequestOptions.contentType || 'application/json';
	    return new Promise(function (resolve, reject) {
	        return http.request(httpRequestOptions)
	            .then(function (response) {
	            var contentString = response.content.toString();
	            var content = JSON.parse(contentString);
	            if (response.statusCode < 400) {
	                resolve(content);
	            }
	            else {
	                reject(contentString);
	            }
	        }, function (error) {
	            // possible reasons: no internet connectivity
	            // error is an object with message (contains the reason) and stack (null)
	            reject(error);
	        });
	    });
	}
	module.exports = reqwest;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	var url = null;
	var zlib = null;
	var https = null;
	try {
	    url = __webpack_require__(189);
	    zlib = __webpack_require__(190);
	    https = __webpack_require__(184);
	}
	catch (e) {
	    throw e;
	} // because of webpack external dependency declaration - this marks it as optional
	var http = __webpack_require__(132);
	var constants_1 = __webpack_require__(2);
	var EverliveError_1 = __webpack_require__(3);
	function reqwest(options) {
	    var urlParts = url.parse(options.url);
	    var request;
	    if (urlParts.protocol === 'https:') {
	        request = https.request;
	    }
	    else {
	        request = http.request;
	    }
	    var headers = options.headers || {};
	    headers[constants_1.Constants.Headers.ContentType] = options.contentType;
	    return new Promise(function (resolve, reject) {
	        var req = request({
	            method: options.method,
	            hostname: urlParts.hostname,
	            port: urlParts.port,
	            path: urlParts.path,
	            headers: headers
	        }, function (res) {
	            var json = '';
	            var contentEncoding = res.headers['content-encoding'];
	            var responseProxy;
	            switch (contentEncoding) {
	                case 'gzip':
	                    responseProxy = zlib.createGunzip();
	                    res.pipe(responseProxy);
	                    break;
	                default:
	                    responseProxy = res;
	                    responseProxy.setEncoding('utf8');
	                    break;
	            }
	            responseProxy.on('data', function (data) {
	                json += data.toString();
	            });
	            responseProxy.on('end', function () {
	                // 1xx Informational, 2xx Success, 3xx Redirection, 4xx Client Error, 5xx Server Error
	                if (200 <= res.statusCode && res.statusCode < 400) {
	                    var result = JSON.parse(json);
	                    resolve(result);
	                }
	                else {
	                    if (json) {
	                        reject(json);
	                    }
	                    else {
	                        var error = new EverliveError_1.EverliveError({ message: 'Response error.' });
	                        error.statusCode = res.statusCode;
	                        reject(error);
	                    }
	                }
	            });
	        });
	        req.on('error', function (e) {
	            reject({ responseText: e });
	        });
	        if (options.data) {
	            var contentEncoding = headers['content-encoding'];
	            switch (contentEncoding) {
	                case 'gzip':
	                    var buf = new Buffer(options.data, 'utf-8');
	                    zlib.gzip(buf, function (err, result) {
	                        req.end(result);
	                    });
	                    break;
	                default:
	                    req.end(options.data);
	                    break;
	            }
	        }
	        else {
	            req.end();
	        }
	    });
	}
	module.exports = reqwest;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36).Buffer))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var constants_1 = __webpack_require__(2);
	var Request_1 = __webpack_require__(9);
	var ResponseParserProcessor = (function () {
	    function ResponseParserProcessor() {
	    }
	    ResponseParserProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        if (query.operation === constants_1.DataQueryOperation.InvokeCloudFunction ||
	            query.operation === constants_1.DataQueryOperation.InvokeStoredProcedure) {
	            return iterator.next(value);
	        }
	        var parser = null;
	        switch (query.operation) {
	            case constants_1.DataQueryOperation.ReadById:
	            case constants_1.DataQueryOperation.Aggregate:
	            case constants_1.DataQueryOperation.Count:
	            case constants_1.DataQueryOperation.Create:
	            case constants_1.DataQueryOperation.SetAcl:
	            case constants_1.DataQueryOperation.FilesGetDownloadUrlById:
	            case constants_1.DataQueryOperation.UserLinkWithProvider:
	            case constants_1.DataQueryOperation.UserUnlinkFromProvider:
	                parser = Request_1.Request.parsers.single;
	                break;
	            case constants_1.DataQueryOperation.RawUpdate:
	            case constants_1.DataQueryOperation.Update:
	                parser = Request_1.Request.parsers.update;
	                break;
	            default:
	                if (query.isCustomRequest) {
	                    parser = Request_1.Request.parsers.customRequest;
	                }
	                else {
	                    parser = Request_1.Request.parsers.simple;
	                }
	        }
	        var parsedResponse = parser.result(value);
	        return iterator.next(parsedResponse);
	    };
	    return ResponseParserProcessor;
	}());
	exports.ResponseParserProcessor = ResponseParserProcessor;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var underscore_1 = __webpack_require__(1);
	var Constants_1 = __webpack_require__(8);
	//TODO: is this really needed or is obsolete, or at least parts of it
	var ResponseDataMergeProcessor = (function () {
	    function ResponseDataMergeProcessor() {
	    }
	    ResponseDataMergeProcessor.prototype.mergeResultData = function (data, res) {
	        var attrs = res.result;
	        // support for kendo observable array
	        if (underscore_1.isArray(data) || typeof data.length === 'number') {
	            underscore_1.each(data, function (item, index) {
	                underscore_1.extend(item, attrs[index]);
	            });
	        }
	        else {
	            underscore_1.extend(data, attrs);
	        }
	        return res;
	    };
	    ResponseDataMergeProcessor.prototype.mergeUpdateResultData = function (data, res) {
	        var modifiedAt = res.ModifiedAt;
	        data.ModifiedAt = modifiedAt;
	        return res;
	    };
	    ResponseDataMergeProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        var result = null;
	        switch (query.operation) {
	            case Constants_1.DataQueryOperation.Update:
	                result = this.mergeUpdateResultData(query.data, value);
	                break;
	            case Constants_1.DataQueryOperation.Create:
	                result = this.mergeResultData(query.data, value);
	                break;
	            case Constants_1.DataQueryOperation.FilesGetDownloadUrlById:
	                result = value.result.Uri;
	                break;
	            default:
	                result = value;
	                break;
	        }
	        return iterator.next(result);
	    };
	    return ResponseDataMergeProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ResponseDataMergeProcessor;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NativeScriptFileStore = (function () {
	    function NativeScriptFileStore(storagePath, options) {
	        this.storagePath = storagePath;
	        this.options = options;
	        this.options = options;
	        try {
	            this.fs = __webpack_require__(183);
	        }
	        catch (err) {
	            throw err;
	        } // because of webpack external dependency declaration - this marks it as optional
	        this.dataDirectoryPath = this.fs.knownFolders.documents().path;
	        this.filesDirectoryPath = this.fs.path.join(this.dataDirectoryPath, storagePath);
	    }
	    NativeScriptFileStore.prototype.getErrorHandler = function (callback) {
	        return function (e) {
	            callback && callback(e);
	        };
	    };
	    NativeScriptFileStore.prototype.removeFilesDirectory = function () {
	        var self = this;
	        return self.getFilesDirectory()
	            .then(function (filesDirectory) {
	            return filesDirectory.remove();
	        });
	    };
	    NativeScriptFileStore.prototype.removeFile = function (fileEntry) {
	        return fileEntry.remove();
	    };
	    NativeScriptFileStore.prototype.readFileAsText = function (fileEntry) {
	        return fileEntry.readText();
	    };
	    NativeScriptFileStore.prototype.writeTextToFile = function (fileEntry, content) {
	        return fileEntry.writeText(content);
	    };
	    NativeScriptFileStore.prototype.getFile = function (path) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            self.resolveDataDirectory()
	                .then(function (directoryEntry) {
	                var fullFilePath = self.fs.path.join(directoryEntry.path, path);
	                var file = self.fs.File.fromPath(fullFilePath);
	                resolve(file);
	            })
	                .catch(reject);
	        });
	    };
	    NativeScriptFileStore.prototype.getFilesDirectory = function () {
	        var self = this;
	        return new Promise(function (resolve) {
	            var filesDirectory = self.fs.Folder.fromPath(self.filesDirectoryPath);
	            resolve(filesDirectory);
	        });
	    };
	    NativeScriptFileStore.prototype.resolveDataDirectory = function () {
	        var self = this;
	        return new Promise(function (resolve) {
	            var dataDirectory = self.fs.Folder.fromPath(self.dataDirectoryPath);
	            resolve(dataDirectory);
	        });
	    };
	    NativeScriptFileStore.prototype.ensureFilesDirectory = function () {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            self.resolveDataDirectory()
	                .then(function (directoryEntry) {
	                var fileDirectoryPath = self.fs.path.join(directoryEntry.path, self.filesDirectoryPath);
	                self.fs.Folder.fromPath(fileDirectoryPath);
	                resolve();
	            })
	                .catch(reject);
	        });
	    };
	    NativeScriptFileStore.prototype.getFilesDirectoryPath = function () {
	        return this.filesDirectoryPath;
	    };
	    // TODO: [offline] Implement
	    NativeScriptFileStore.prototype.writeText = function (fileName, text, path) {
	        throw new Error('Not implemented');
	    };
	    // TODO: [offline] Implement
	    NativeScriptFileStore.prototype.createDirectory = function () {
	        throw new Error('Not implemented');
	    };
	    // TODO: [offline] Implement
	    NativeScriptFileStore.prototype.getFileSize = function (file, getFileSize) {
	        throw new Error('Not implemented');
	    };
	    // TODO: [offline] Implement
	    NativeScriptFileStore.prototype.getFileByAbsolutePath = function (path) {
	        throw new Error('Not implemented');
	    };
	    NativeScriptFileStore.prototype.readFileAsBase64 = function (file) {
	        throw new Error('Not implemented');
	    };
	    NativeScriptFileStore.prototype.renameFile = function () {
	        throw new Error('Not implemented');
	    };
	    return NativeScriptFileStore;
	}());
	exports.NativeScriptFileStore = NativeScriptFileStore;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var platform = __webpack_require__(5);
	var EverliveError_1 = __webpack_require__(3);
	var utils_1 = __webpack_require__(4);
	var deviceReadyPromise = function () {
	    return new Promise(function (resolve) {
	        document.addEventListener('deviceready', resolve);
	    });
	};
	var WebFileStore = (function () {
	    function WebFileStore(storagePath, options) {
	        var _this = this;
	        this.options = options;
	        var filesDirectoryPath;
	        if (platform.isWindowsPhone || platform.isInAppBuilderSimulator()) {
	            //windows phone does not handle leading or trailing slashes very well :(
	            filesDirectoryPath = storagePath.replace(new RegExp('/', 'g'), '');
	        }
	        else {
	            if (storagePath.lastIndexOf('/') === -1) {
	                filesDirectoryPath = storagePath + '/';
	            }
	        }
	        filesDirectoryPath = filesDirectoryPath || storagePath;
	        deviceReadyPromise().then(function () {
	            _this.filesDirectoryPath = filesDirectoryPath;
	            _this._requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
	            _this._resolveLocalFileSystemURL = window.resolveLocalFileSystemURL || window.webkitResolveLocalFileSystemURL;
	            _this._PERSISTENT_FILE_SYSTEM = window.LocalFileSystem ? window.LocalFileSystem.PERSISTENT : window.PERSISTENT;
	        });
	    }
	    WebFileStore.prototype.getErrorHandler = function (callback) {
	        var errorsMap = {
	            '1000': 'NOT_FOUND'
	        };
	        _.each(Object.keys(FileError), function (error) {
	            errorsMap[FileError[error]] = error;
	        });
	        return function (e) {
	            if (!e.message) {
	                e.message = errorsMap[e.code];
	            }
	            callback && callback(e);
	        };
	    };
	    WebFileStore.prototype.getDataDirectory = function () {
	        var _this = this;
	        return deviceReadyPromise()
	            .then(function () {
	            var requestFileSystem = function (bytes, success, error) {
	                _this._requestFileSystem.call(window, _this._PERSISTENT_FILE_SYSTEM, bytes, function (fileSystem) {
	                    _this.fileSystemRoot = fileSystem.root;
	                    _this.fileSystemRoot.nativeURL = _this.fileSystemRoot.nativeURL || _this.fileSystemRoot.toURL();
	                    success(_this.fileSystemRoot);
	                }, error);
	            };
	            return new Promise(function (resolve, reject) {
	                if (_this.fileSystemRoot) {
	                    return resolve(_this.fileSystemRoot);
	                }
	                if (platform.isDesktop) {
	                    if (navigator && !navigator.webkitPersistentStorage) {
	                        return reject(new EverliveError_1.EverliveError({ message: 'FileSystemStorage can be used only with browsers supporting it. Consider using localStorage.' }));
	                    }
	                    navigator.webkitPersistentStorage.requestQuota(_this.options.storage.requestedQuota, function (grantedBytes) {
	                        requestFileSystem(grantedBytes, resolve, reject);
	                    }, reject);
	                }
	                else {
	                    requestFileSystem(0, resolve, reject);
	                }
	            });
	        });
	    };
	    ;
	    WebFileStore.prototype.getFilesDirectory = function () {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            self.getDataDirectory()
	                .then(function (dataDirectory) {
	                dataDirectory.getDirectory(self.filesDirectoryPath, {
	                    create: true,
	                    exclusive: false
	                }, resolve, reject);
	            })
	                .catch(reject);
	        });
	    };
	    WebFileStore.prototype.removeFilesDirectory = function () {
	        var self = this;
	        return this.getFilesDirectory()
	            .then(function (filesDirectory) {
	            return self._removeFolderWrap(filesDirectory);
	        });
	    };
	    WebFileStore.prototype.removeFile = function (fileEntry) {
	        return new Promise(function (resolve, reject) {
	            fileEntry.remove(function () {
	                resolve();
	            }, reject);
	        });
	    };
	    WebFileStore.prototype.readFileAsText = function (fileEntry) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            self.getFilesDirectory().then(function () {
	                fileEntry.file(function (file) {
	                    var reader = new FileReader();
	                    reader.onloadend = function () {
	                        var result = this.result;
	                        //windows phone returns an object....
	                        if (typeof this.result === 'object') {
	                            result = JSON.stringify(this.result);
	                        }
	                        resolve(result);
	                    };
	                    reader.onerror = reject;
	                    reader.readAsText(file);
	                }, reject);
	            }).catch(reject);
	        });
	    };
	    WebFileStore.prototype.writeTextToFile = function (fileEntry, content) {
	        var self = this;
	        return self.getFilesDirectory()
	            .then(function () {
	            return self._getWriterWrap(fileEntry, content);
	        });
	    };
	    WebFileStore.prototype.getFileSize = function (filename, folder) {
	        var self = this;
	        return new Promise(function (resolve, reject) {
	            var fileLocation = utils_1.Utils.joinPath(folder, filename);
	            return self.getFile(fileLocation)
	                .then(function (fileEntry) {
	                fileEntry.file(function (file) {
	                    resolve(file.size);
	                }, reject);
	            });
	        });
	    };
	    WebFileStore.prototype.getFile = function (fileName, dirEntry) {
	        return this.getFilesDirectory()
	            .then(function (directoryEntry) {
	            var fileDirectory;
	            if (dirEntry) {
	                fileDirectory = dirEntry;
	            }
	            else {
	                fileDirectory = directoryEntry;
	            }
	            return new Promise(function (resolve, reject) {
	                fileDirectory.getFile(fileName, {
	                    create: true,
	                    exclusive: false
	                }, resolve, reject);
	            });
	        });
	    };
	    WebFileStore.prototype.getFileByAbsolutePath = function (path) {
	        var self = this;
	        path = utils_1.Utils.transformPlatformPath(path);
	        return new Promise(function (resolve, reject) {
	            self._resolveLocalFileSystemURL.call(window, path, resolve, function (err) {
	                if (err && err.code === FileError.NOT_FOUND_ERR) {
	                    return resolve();
	                }
	                return reject(err);
	            });
	        });
	    };
	    WebFileStore.prototype.createDirectory = function (directory) {
	        var self = this;
	        return this.getFilesDirectory()
	            .then(function (directoryEntry) {
	            return self._getDirectoryWrap(directory, directoryEntry, {
	                create: true,
	                exclusive: false
	            });
	        });
	    };
	    WebFileStore.prototype.renameFile = function (directoryEntry, fileEntry, filename) {
	        return new Promise(function (resolve, reject) {
	            fileEntry.moveTo(directoryEntry, filename, resolve, reject);
	        });
	    };
	    WebFileStore.prototype._getDirectoryWrap = function (directory, directoryEntry, options) {
	        return new Promise(function (resolve, reject) {
	            directoryEntry.getDirectory(directory, options, resolve, reject);
	        });
	    };
	    WebFileStore.prototype._removeFolderWrap = function (filesDirEntry) {
	        return new Promise(function (resolve, reject) {
	            filesDirEntry.removeRecursively(function () {
	                resolve();
	            }, reject);
	        });
	    };
	    WebFileStore.prototype._getWriterWrap = function (fileEntry, content) {
	        return new Promise(function (resolve, reject) {
	            fileEntry.createWriter(function (fileWriter) {
	                fileWriter.onwriteend = function () {
	                    resolve();
	                };
	                fileWriter.onerror = reject;
	                var bb = new Blob([content]);
	                fileWriter.write(bb);
	            }, reject);
	        });
	    };
	    WebFileStore.prototype.writeText = function (fileName, text, path) {
	        var self = this;
	        var fileHandle;
	        return this.getFilesDirectory()
	            .then(function (directoryEntry) {
	            if (path) {
	                return self.createDirectory(path);
	            }
	            else {
	                return directoryEntry;
	            }
	        })
	            .then(function (directoryEntry) {
	            return self.getFile(fileName, directoryEntry);
	        })
	            .then(function (fileEntry) {
	            fileHandle = fileEntry;
	            return self.writeTextToFile(fileEntry, text);
	        })
	            .then(function () {
	            // there  is a difference between the cordova implementation and the standard FileTransfer fileEntry
	            return fileHandle.nativeURL || fileHandle.toURL();
	        });
	    };
	    // http://stackoverflow.com/questions/9583363/get-base64-from-imageuri-with-phonegap
	    WebFileStore.prototype.readFileAsBase64 = function (fileEntry) {
	        return new Promise(function (resolve, reject) {
	            fileEntry.file(function (file) {
	                var reader = new FileReader();
	                reader.onloadend = function (evt) {
	                    resolve(utils_1.Utils.arrayBufferToBase64(evt.target.result));
	                };
	                reader.readAsArrayBuffer(file);
	            }, reject);
	        });
	    };
	    return WebFileStore;
	}());
	exports.WebFileStore = WebFileStore;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var utils_1 = __webpack_require__(4);
	var platform = __webpack_require__(5);
	var Data_1 = __webpack_require__(16);
	var constants_1 = __webpack_require__(2);
	var Files = (function (_super) {
	    __extends(Files, _super);
	    /**
	     * @class Files
	     * @protected
	     * @extends Data
	     */
	    function Files(sdk) {
	        _super.call(this, sdk, 'Files');
	    }
	    /**
	     * Get a URL that can be used as an endpoint for uploading a file. It is specific to each {{site.TelerikBackendServices}} app.
	     * @memberof Files.prototype
	     * @method getUploadUrl
	     * @returns {string}
	     */
	    Files.prototype.getUploadUrl = function () {
	        return utils_1.Utils.buildUrl(this.setup) + this.collectionName;
	    };
	    /**
	     * Get the download URL for a file.
	     * @memberof Files.prototype
	     * @method getDownloadUrl
	     * @deprecated
	     * @see [files.getDownloadUrlById]{@link ../Files/files.getDownloadUrlById}
	     * @param {string} fileId The ID of the file.
	     * @returns {string} url The download URL.
	     */
	    Files.prototype.getDownloadUrl = function (fileId) {
	        return utils_1.Utils.buildUrl(this.setup) + this.collectionName + '/' + fileId + '/Download';
	    };
	    /**
	     * Get a URL that can be used as an endpoint for updating the file content. It is specific to each {{site.TelerikBackendServices}} app.
	     * @memberof Files.prototype
	     * @method getUpdateUrl
	     * @param {string} fileId The ID of the file.
	     * @returns {string} url The update URL.
	     */
	    Files.prototype.getUpdateUrl = function (fileId) {
	        return utils_1.Utils.buildUrl(this.setup) + this._getUpdateUrl(fileId);
	    };
	    /**
	     * Updates a file's content
	     * @memberof Files.prototype
	     * @method updateContent
	     * @param {string} fileId File ID.
	     * @param {Object} file The file metadata and the base64 encoded file content.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     * @returns {Promise} The promise for the request
	     */
	    Files.prototype.updateContent = function (fileId, file, success, error) {
	        var data = file;
	        var additionalOptions = { id: fileId };
	        var dataQuery = this.buildDataQuery({
	            data: data,
	            additionalOptions: additionalOptions
	        }, constants_1.DataQueryOperation.FilesUpdateContent);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     * Gets the download URL for a file by ID.
	     * @memberof Files.prototype
	     * @method getDownloadUrlById
	     * @param {string} fileId File ID.
	     * @returns {Promise} The promise for the request
	     */
	    /**
	     * Gets the download URL for a file by ID.
	     * @memberof Files.prototype
	     * @method getDownloadUrlById
	     * @see [files.getDownloadUrlById]{@link ../Files/files.getDownloadUrlById}
	     * @param {string} fileId File ID.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Files.prototype.getDownloadUrlById = function (fileId, success, error) {
	        if (platform.isDesktop && !this.sdk.isOnline()) {
	            //while in offline we cannot get the url of the file, but we can generate one
	            var url = this.getDownloadUrl(fileId);
	            return utils_1.Utils.buildPromise(function (resolve) { return resolve(url); }, success, error);
	        }
	        var additionalOptions = { id: fileId };
	        var dataQuery = this.buildDataQuery({ additionalOptions: additionalOptions }, constants_1.DataQueryOperation.FilesGetDownloadUrlById);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    /**
	     * Downloads a file to the device's file system. Wraps the Apache Cordova "download()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
	     * @memberof Files.prototype
	     * @method download
	     * @param {string} fileId A Backend Services File ID.
	     * @param {string} localPath An Apache Cordova FileSystem URL representing the local path on the device where the downloaded file will be saved. Maps to the "target" FileTransfer plugin parameter.
	     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
	     * @param {object} [options.headers] A JSON object containing headers to send along with the request.
	     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Downloads a file to the device's file system. Wraps the Apache Cordova "download()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
	     * @memberof Files.prototype
	     * @method download
	     * @param {string} fileId A Backend Services File ID.
	     * @param {string} localPath An Apache Cordova FileSystem URL representing the local path on the device where the downloaded file will be saved. Maps to the "target" FileTransfer plugin parameter.
	     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
	     * @param {object} [options.headers] A JSON object containing headers to send along with the request.
	     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
	     * @param {Function} [success] A success callback that is passed an Apache Cordova [FileEntry](https://cordova.apache.org/docs/en/3.3.0/cordova_file_file.md.html#FileEntry) object. Maps to the "successCallback" FileTransfer plugin parameter.
	     * @param {Function} [error] An error callback that is passed an Apache Cordova [FileTransferError](https://github.com/apache/cordova-plugin-file-transfer#filetransfererror) object. Maps to the "errorCallback" FileTransfer plugin parameter.
	     */
	    Files.prototype.download = function (fileId, localPath, options, trustAllHosts, success, error) {
	        var _this = this;
	        if (trustAllHosts === void 0) { trustAllHosts = false; }
	        return utils_1.Utils.buildPromise(function (success, error) {
	            var headers = options && options.headers ? options.headers : {};
	            var fileTransfer = new FileTransfer();
	            _this.withHeaders(headers)
	                .getById(fileId)
	                .then(function (res) {
	                var file = res.result;
	                fileId = file.Uri;
	                fileTransfer.download(fileId, localPath, success, error, trustAllHosts, options);
	            }, error);
	        }, success, error);
	    };
	    /**
	     * Uploads a file from the device's file system to Backend Services. Wraps the Apache Cordova "upload()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
	     * @memberof Files.prototype
	     * @method upload
	     * @param {string} localPath An Apache Cordova FileSystem URL representing the full path to the file on the device.
	     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
	     * @param {string} [options.fileKey] The name of the form element. Defaults to 'file' in the FileTransfer plugin parameter.
	     * @param {string} [options.fileName] The file name to use when uploading the file. Defaults to 'image.jpg' in the FileTransfer plugin.
	     * @param {string} [options.httpMethod] The HTTP method to use, either POST or PUT. Defaults to 'POST' in the FileTransfer plugin parameter.
	     * @param {string} [options.mimeType] The mime type of the uploaded data. Defaults to 'image/jpeg' in the FileTransfer plugin parameter.
	     * @param {object} [options.params] A set of optional key/value pairs to pass in the HTTP request.
	     * @param {boolean} [options.chunkedMode] Whether to upload the data in chunked streaming mode. Defaults to 'true' in the FileTransfer plugin parameter.
	     * @param {object} [options.headers] A JSON object for the headers to send along with the request.
	     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Uploads a file from the device's file system to Backend Services. Wraps the Apache Cordova "upload()" [FileTransfer](http://cordova.apache.org/docs/en/2.7.0/cordova_file_file.md.html#FileTransfer) method. Note that the signatures of these methods differ.
	     * @memberof Files.prototype
	     * @method upload
	     * @param {string} localPath An Apache Cordova FileSystem URL representing the full path to the file on the device.
	     * @param {object} [options] Additional request options. Maps to the "options" FileTransfer plugin parameter.
	     * @param {string} [options.fileKey] The name of the form element. Defaults to 'file' in the FileTransfer plugin parameter.
	     * @param {string} [options.fileName] The file name to use when uploading the file. Defaults to 'image.jpg' in the FileTransfer plugin parameter.
	     * @param {string} [options.httpMethod] The HTTP method to use, either POST or PUT. Defaults to 'POST' in the FileTransfer plugin parameter.
	     * @param {string} [options.mimeType] The mime type of the uploaded data. Defaults to 'image/jpeg' in the FileTransfer plugin parameter.
	     * @param {object} [options.params] A set of optional key/value pairs to pass in the HTTP request.
	     * @param {boolean} [options.chunkedMode] Whether to upload the data in chunked streaming mode. Defaults to 'true' in the FileTransfer plugin parameter.
	     * @param {object} [options.headers] A JSON object for the headers to send along with the request.
	     * @param {boolean} [trustAllHosts=false] Whether to accept all security certificates including self-signed certificates. Maps to the "trustAllHosts" FileTransfer plugin parameter.
	     * @param {Function} [success] A success callback that is passed an Apache Cordova [FileUploadResult](https://github.com/apache/cordova-plugin-file-transfer#fileuploadresult) object. Maps to the "successCallback" FileTransfer plugin parameter.
	     * @param {Function} [error] An error callback that is passed an Apache Cordova [FileTransferError](https://github.com/apache/cordova-plugin-file-transfer#filetransfererror) object. Maps to the "errorCallback" FileTransfer plugin parameter.
	     */
	    Files.prototype.upload = function (localPath, options, trustAllHosts, success, error) {
	        if (trustAllHosts === void 0) { trustAllHosts = false; }
	        var url = this.getUploadUrl();
	        return utils_1.Utils.buildPromise(function (success, error) {
	            var fileTransfer = new FileTransfer();
	            var uri = encodeURI(url);
	            fileTransfer.upload(localPath, uri, success, error, options, trustAllHosts);
	        }, success, error);
	    };
	    Files.prototype._getUpdateUrl = function (fileId) {
	        return this.collectionName + '/' + fileId + '/Content';
	    };
	    return Files;
	}(Data_1.Data));
	exports.Files = Files;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(1);
	var utils_1 = __webpack_require__(4);
	var EverliveError_1 = __webpack_require__(3);
	var Data_1 = __webpack_require__(16);
	var constants_1 = __webpack_require__(2);
	var Users = (function (_super) {
	    __extends(Users, _super);
	    /**
	     * @class Users
	     * @extends Data
	     * @protected
	     */
	    function Users(sdk) {
	        _super.call(this, sdk, 'Users');
	    }
	    /**
	     * Registers a new user with username and password.
	     * @memberOf Users.prototype
	     * @method register
	     * @name register
	     * @param {string} username The new user's username.
	     * @param {string} password The new user's password.
	     * @param {object} userInfo Additional information for the user (ex. DisplayName, Email, etc.)
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Registers a new user using a username and a password.
	     * @memberOf Users.prototype
	     * @method register
	     * @name register
	     * @param {string} username The new user's username.
	     * @param {string} password The new user's password.
	     * @param attrs
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.register = function (username, password, attrs, success, error) {
	        utils_1.Utils.guardUnset(username, 'username');
	        utils_1.Utils.guardUnset(password, 'password');
	        var user = _.extend({
	            Username: username,
	            Password: password,
	        }, attrs);
	        return this.create(user, success, error);
	    };
	    /**
	     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with [Users.ResultTypes.currentUserResult]{@link Users.ResultTypes.currentUserResult}.
	     * @memberOf Users.prototype
	     * @method currentUser
	     * @name currentUser
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK. The success function is called with [Users.ResultTypes.currentUserResult]{@link Users.ResultTypes.currentUserResult}.
	     * @memberOf Users.prototype
	     * @method currentUser
	     * @name currentUser
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.currentUser = function (success, error) {
	        var _this = this;
	        var id = (this.sdk._isOfflineStorageEnabled() && this.sdk.isOffline()) ? this.sdk.setup.principalId : 'me';
	        return utils_1.Utils.buildPromise(function (success, error) {
	            if (id === 'me' && !_this.sdk.setup.token && !_this.sdk.setup.masterKey || !id) {
	                return success({ result: null });
	            }
	            _this.getById(id).then(function (res) {
	                if (typeof res.result !== 'undefined') {
	                    success({ result: res.result });
	                }
	                else {
	                    success({ result: null });
	                }
	            }, function (err) {
	                if (_this.sdk.authentication && _this.sdk.authentication.isAuthenticationInProgress()) {
	                    success({ result: null });
	                }
	                else if (err.code === 601) {
	                    success({ result: null });
	                }
	                else if (err.code === 801) {
	                    error(new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.invalidToken));
	                }
	                else {
	                    error(err);
	                }
	            });
	        }, success, error);
	    };
	    /**
	     * Changes the password of a user.
	     * @memberOf Users.prototype
	     * @method changePassword
	     * @name changePassword
	     * @param {string} username The user's username.
	     * @param {string} password The user's password.
	     * @param {string} newPassword The user's new password.
	     * @param {boolean=false} [keepTokens] If set to true, the user tokens will be preserved even after the password change.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Changes the password of a user.
	     * @memberOf Users.prototype
	     * @method changePassword
	     * @name changePassword
	     * @param {string} username The user's username.
	     * @param {string} password The user's password.
	     * @param {string} newPassword The user's new password.
	     * @param {boolean=false} [keepTokens] If set to true, the user tokens will be preserved even after the password change.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.changePassword = function (username, password, newPassword, keepTokens, success, error) {
	        var _this = this;
	        if (keepTokens === void 0) { keepTokens = false; }
	        var data = {
	            Username: username,
	            Password: password,
	            NewPassword: newPassword
	        };
	        var additionalOptions = { keepTokens: keepTokens };
	        var dataQuery = this.buildDataQuery({ data: data, additionalOptions: additionalOptions }, constants_1.DataQueryOperation.UserChangePassword);
	        return utils_1.Utils.buildPromise(function (success, error) {
	            _this.processDataQuery(dataQuery)
	                .then(function (data) {
	                if (data && data.result) {
	                    if (!keepTokens) {
	                        _this.clearAuthorization();
	                    }
	                }
	                return success(data);
	            })
	                .catch(error);
	        }, success, error);
	    };
	    /**
	     *
	     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
	     * @memberOf Users.prototype
	     * @method login
	     * @name login
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.login}
	     * @param {string} username The user's username.
	     * @param {string} password The user's password.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
	     * @memberOf Users.prototype
	     * @method login
	     * @name login
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.login}
	     * @param {string} username The user's username.
	     * @param {string} password The user's password.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.login = function (username, password, success, error) {
	        return this.sdk.authentication.login(username, password, success, error);
	    };
	    /**
	     * Log out the user who is currently logged in.
	     * @memberOf Users.prototype
	     * @method logout
	     * @name logout
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.logout}
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log out the user who is currently logged in.
	     * @memberOf Users.prototype
	     * @method logout
	     * @name logout
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.logout}
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.logout = function (success, error) {
	        return this.sdk.authentication.logout(success, error);
	    };
	    /**
	     * Log in a user using an Facebook access token.
	     * @memberOf Users.prototype
	     * @method loginWithFacebook
	     * @name loginWithFacebook
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
	     * @param {string} accessToken Facebook access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using an Facebook access token.
	     * @memberOf Users.prototype
	     * @method loginWithFacebook
	     * @name loginWithFacebook
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithFacebook}
	     * @param {string} accessToken Facebook access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.loginWithFacebook = function (accessToken, success, error) {
	        return this.sdk.authentication.loginWithFacebook(accessToken, success, error);
	    };
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to a Facebook access token.
	     * @memberOf Users.prototype
	     * @method linkWithFacebook
	     * @name linkWithFacebook
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Links a Backend Services user with a Facebook access token.
	     * @memberOf Users.prototype
	     * @method linkWithFacebook
	     * @name linkWithFacebook
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.         * @param {Function} [success] a success callback.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.linkWithFacebook = function (userId, accessToken, success, error) {
	        var identity = {
	            Provider: 'Facebook',
	            Token: accessToken
	        };
	        return this._linkWithProvider(identity, userId, success, error);
	    };
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromFacebook
	     * @name unlinkFromFacebook
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromFacebook
	     * @name unlinkFromFacebook
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.unlinkFromFacebook = function (userId, success, error) {
	        return this._unlinkFromProvider('Facebook', userId, success, error);
	    };
	    /**
	     * Log in a user using an ADFS access token.
	     * @memberOf Users.prototype
	     * @method loginWithADFS
	     * @name loginWithADFS
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
	     * @param {string} accessToken ADFS access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using an ADFS access token.
	     * @memberOf Users.prototype
	     * @method loginWithADFS
	     * @name loginWithADFS
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithADFS}
	     * @param {string} accessToken ADFS access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.loginWithADFS = function (accessToken, success, error) {
	        return this.sdk.authentication.loginWithADFS(accessToken, success, error);
	    };
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
	     * @memberOf Users.prototype
	     * @method linkWithADFS
	     * @name linkWithADFS
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
	     * @memberOf Users.prototype
	     * @method linkWithADFS
	     * @name linkWithADFS
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.linkWithADFS = function (userId, accessToken, success, error) {
	        var identity = {
	            Provider: 'ADFS',
	            Token: accessToken
	        };
	        return this._linkWithProvider(identity, userId, success, error);
	    };
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromADFS
	     * @name unlinkFromADFS
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromADFS
	     * @name unlinkFromADFS
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.unlinkFromADFS = function (userId, success, error) {
	        return this._unlinkFromProvider('ADFS', userId, success, error);
	    };
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to an SAML access token.
	     * @memberOf Users.prototype
	     * @method linkWithSAML
	     * @name linkWithSAML
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The SAML access token that will be linked to the {{site.bs}} user account.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to an SAML access token.
	     * @memberOf Users.prototype
	     * @method linkWithSAML
	     * @name linkWithSAML
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The SAML access token that will be linked to the {{site.bs}} user account.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.linkWithSAML = function (userId, accessToken, success, error) {
	        var identity = {
	            Provider: 'SAML',
	            Token: accessToken
	        };
	        return this._linkWithProvider(identity, userId, success, error);
	    };
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the SAML token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromSAML
	     * @name unlinkFromSAML
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the SAML token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromSAML
	     * @name unlinkFromSAML
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.unlinkFromSAML = function (userId, success, error) {
	        return this._unlinkFromProvider('SAML', userId, success, error);
	    };
	    /**
	     * Log in a user using a Microsoft Account access token.
	     * @memberOf Users.prototype
	     * @method loginWithLiveID
	     * @name loginWithLiveID
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
	     * @param {string} accessToken Microsoft Account access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using a Microsoft Account access token.
	     * @memberOf Users.prototype
	     * @method loginWithLiveID
	     * @name loginWithLiveID
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithLiveID}
	     * @param {string} accessToken Microsoft Account access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.loginWithLiveID = function (accessToken, success, error) {
	        return this.sdk.authentication.loginWithLiveID(accessToken, success, error);
	    };
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
	     * @memberOf Users.prototype
	     * @method linkWithLiveID
	     * @name linkWithLiveID
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to a Microsoft Account access token.
	     * @memberOf Users.prototype
	     * @method linkWithLiveID
	     * @name linkWithLiveID
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The Microsoft Account access token that will be linked to the {{site.bs}} user account.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.linkWithLiveID = function (userId, accessToken, success, error) {
	        var identity = {
	            Provider: 'LiveID',
	            Token: accessToken
	        };
	        return this._linkWithProvider(identity, userId, success, error);
	    };
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromLiveID
	     * @name unlinkFromLiveID
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Microsoft Account access token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromLiveID
	     * @name unlinkFromLiveID
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.unlinkFromLiveID = function (userId, success, error) {
	        return this._unlinkFromProvider('LiveID', userId, success, error);
	    };
	    /**
	     * Log in a user using a Google access token.
	     * @memberOf Users.prototype
	     * @method loginWithGoogle
	     * @name loginWithGoogle
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
	     * @param {string} accessToken Google access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using a Google access token.
	     * @memberOf Users.prototype
	     * @method loginWithGoogle
	     * @name loginWithGoogle
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.loginWithGoogle}
	     * @param {string} accessToken Google access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.loginWithGoogle = function (accessToken, success, error) {
	        return this.sdk.authentication.loginWithGoogle(accessToken, success, error);
	    };
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
	     * @memberOf Users.prototype
	     * @method linkWithGoogle
	     * @name linkWithGoogle
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
	     * @memberOf Users.prototype
	     * @method linkWithGoogle
	     * @name linkWithGoogle
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.linkWithGoogle = function (userId, accessToken, success, error) {
	        var identity = {
	            Provider: 'Google',
	            Token: accessToken
	        };
	        return this._linkWithProvider(identity, userId, success, error);
	    };
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromGoogle
	     * @name unlinkFromGoogle
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromGoogle
	     * @name unlinkFromGoogle
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.unlinkFromGoogle = function (userId, success, error) {
	        return this._unlinkFromProvider('Google', userId, success, error);
	    };
	    /**
	     * Log in a user with a Twitter token. A secret token needs to be provided.
	     * @memberOf Users.prototype
	     * @method loginWithTwitter
	     * @name loginWithTwitter
	     * @param {string} token Twitter token.
	     * @param {string} tokenSecret Twitter secret token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user with a Twitter token. A secret token needs to be provided.
	     * @memberOf Users.prototype
	     * @method loginWithTwitter
	     * @name loginWithTwitter
	     * @param {string} token Twitter token.
	     * @param {string} tokenSecret Twitter secret token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.loginWithTwitter = function (token, tokenSecret, success, error) {
	        return this.sdk.authentication.loginWithTwitter(token, tokenSecret, success, error);
	    };
	    /**
	     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.
	     * @memberOf Users.prototype
	     * @method linkWithTwitter
	     * @name linkWithTwitter
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
	     * @param {string} tokenSecret The Twitter secret token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.         * Links a Backend Services user with a Twitter token. A secret token needs to be provided.
	     * @memberOf Users.prototype
	     * @method linkWithTwitter
	     * @name linkWithTwitter
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
	     * @param {string} tokenSecret The Twitter secret token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.linkWithTwitter = function (userId, token, tokenSecret, success, error) {
	        var identity = {
	            Provider: 'Twitter',
	            Token: token,
	            TokenSecret: tokenSecret
	        };
	        return this._linkWithProvider(identity, userId, success, error);
	    };
	    /**
	     * Log in a user using an SAML access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithSAML
	     * @name loginWithSAML
	     * @param {string} accessToken SAML access token.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Log in a user using an SAML access token.
	     * @memberOf Authentication.prototype
	     * @method loginWithSAML
	     * @name loginWithSAML
	     * @param {string} accessToken SAML access token.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.loginWithSAML = function (accessToken, success, error) {
	        return this.sdk.authentication.loginWithGoogle(accessToken, success, error);
	    };
	    ;
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromTwitter
	     * @name unlinkFromTwitter
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
	     * @memberOf Users.prototype
	     * @method unlinkFromTwitter
	     * @name unlinkFromTwitter
	     * @param {string} userId The user's ID in {{site.bs}}.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.unlinkFromTwitter = function (userId, success, error) {
	        return this._unlinkFromProvider('Twitter', userId, success, error);
	    };
	    /**
	     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
	     * @memberOf Users.prototype
	     * @method setAuthorization
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.setAuthorization}
	     * @param {string} token Token that will be used for authorization.
	     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
	     * @param {string} principalId The id of the user that is logged in.
	     */
	    Users.prototype.setAuthorization = function (token, tokenType, principalId) {
	        this.sdk.authentication.setAuthorization(token, tokenType, principalId);
	    };
	    /**
	     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the current authorization token is not invalidated.
	     * @method clearAuthorization
	     * @deprecated
	     * @see [authentication.login]{@link ../Authentication/authentication.clearAuthorization}
	     * @memberOf Users.prototype
	     */
	    Users.prototype.clearAuthorization = function () {
	        this.sdk.authentication.setAuthorization(null, null, null);
	    };
	    /**
	     * Sends a password reset email to a specified user.
	     * @memberOf Users.prototype
	     * @method resetPassword
	     * @name resetPassword
	     * @param {Object} user The user object, which must contain either username or email address.
	     * @returns {Promise} The promise for the request.
	     */
	    /**
	     * Sends a password reset email to a specified user.
	     * @memberOf Users.prototype
	     * @method resetPassword
	     * @name resetPassword
	     * @param {Object} user The user object, which must contain either username or email address.
	     * @param {Function} [success] A success callback.
	     * @param {Function} [error] An error callback.
	     */
	    Users.prototype.resetPassword = function (user, success, error) {
	        var dataQuery = this.buildDataQuery(user, constants_1.DataQueryOperation.UserResetPassword);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    Users.prototype.setPassword = function (setPasswordObject, success, error) {
	        var dataQuery = this.buildDataQuery(setPasswordObject, constants_1.DataQueryOperation.UserSetPassword);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    Users.prototype.skipAuth = function (options) {
	        return _super.prototype.skipAuth.call(this, options);
	    };
	    Users.prototype._linkWithProvider = function (identity, userId, success, error) {
	        var dataQuery = this.buildDataQuery({
	            additionalOptions: {
	                id: userId
	            },
	            data: identity
	        }, constants_1.DataQueryOperation.UserLinkWithProvider);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    Users.prototype._unlinkFromProvider = function (providerName, userId, success, error) {
	        var dataQuery = this.buildDataQuery({
	            additionalOptions: { id: userId },
	            data: {
	                Provider: providerName
	            }
	        }, constants_1.DataQueryOperation.UserUnlinkFromProvider);
	        return this.processDataQuery(dataQuery, success, error);
	    };
	    return Users;
	}(Data_1.Data));
	exports.Users = Users;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var utils_1 = __webpack_require__(4);
	var EverliveError_1 = __webpack_require__(3);
	var DataPreprocessor = (function () {
	    function DataPreprocessor() {
	    }
	    DataPreprocessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        var offlineStorageEnabled = data.sdk._isOfflineStorageEnabled();
	        query.useOffline = offlineStorageEnabled ? !data.sdk.isOnline() : false;
	        var isCachingEnabled = (data.sdk.setup.caching === true || (data.sdk.setup.caching && data.sdk.setup.caching.enabled));
	        var isSupportedInOffline = utils_1.Utils.isQuerySupportedOffline(query);
	        if (data.options) {
	            query = _.extend(query, data.options);
	            data.options = null;
	        }
	        query.useCache = isCachingEnabled && !query.isSync && isSupportedInOffline;
	        query.applyOffline = query.applyOffline !== undefined ? query.applyOffline : offlineStorageEnabled || query.useCache;
	        if (!query.useCache && (query.forceCache || query.maxAge || query.ignoreCache)) {
	            var wantedCacheOperation = void 0;
	            if (query.forceCache) {
	                wantedCacheOperation = 'forceCache';
	            }
	            else if (query.maxAge) {
	                wantedCacheOperation = 'maxAge';
	            }
	            else {
	                wantedCacheOperation = 'ignoreCache';
	            }
	            var cacheDisabledErrorMessage = EverliveError_1.EverliveErrorHelper.buildCacheDisabledErrorMessage(wantedCacheOperation);
	            return iterator.error(new EverliveError_1.EverliveError({ message: cacheDisabledErrorMessage, code: EverliveError_1.EverliveErrors.cacheDisabled.code }));
	        }
	        return iterator.next(value);
	    };
	    return DataPreprocessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DataPreprocessor;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var EverliveError_1 = __webpack_require__(3);
	var constants_1 = __webpack_require__(2);
	var utils_1 = __webpack_require__(4);
	var platform = __webpack_require__(5);
	var OfflineQueryPreprocessor = (function () {
	    function OfflineQueryPreprocessor() {
	    }
	    OfflineQueryPreprocessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        if ((!query.isSync && data.offlineStorage && data.offlineStorage.isSynchronizing())) {
	            var error = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.syncInProgress);
	            return iterator.error(error);
	        }
	        if (utils_1.Utils.isContentType.files(data.collectionName) && platform.isDesktop) {
	            var op = query.operation;
	            if (query.useOffline && query.applyOffline && (op === constants_1.DataQueryOperation.Create || op === constants_1.DataQueryOperation.Update)) {
	                var error = new EverliveError_1.EverliveError(EverliveError_1.EverliveErrors.filesNotSupportedInBrowser);
	                return iterator.error(error);
	            }
	        }
	        return iterator.next(value);
	    };
	    return OfflineQueryPreprocessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OfflineQueryPreprocessor;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var utils_1 = __webpack_require__(4);
	var EverliveError_1 = __webpack_require__(3);
	var AuthenticationProcessor = (function () {
	    function AuthenticationProcessor() {
	    }
	    AuthenticationProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        if (!query.skipAuth && data.sdk.authentication && data.sdk.authentication.isAuthenticationInProgress()) {
	            iterator.prependOnceListener('error', function (error, ev) {
	                var err = utils_1.Utils.parseUtilities.parseErrorOrResponse(error);
	                if (err && (err.code === EverliveError_1.EverliveErrors.invalidToken.code || err.code === EverliveError_1.EverliveErrors.expiredToken.code)) {
	                    ev.cancel();
	                    var whenAuthenticatedPromise_1 = data.sdk.authentication._ensureAuthentication();
	                    if (!query.noRetry) {
	                        whenAuthenticatedPromise_1.then(function () {
	                            if (query.headers && query.headers.authorization) {
	                                //at this stage if a token is used for authentication it is already invalidated
	                                //we need to set the new one to the query
	                                var authHeader = utils_1.Utils.buildAuthHeader(data.sdk.setup);
	                                _.extend(query.headers, authHeader);
	                            }
	                            return iterator.restart();
	                        });
	                    }
	                    else {
	                        return iterator.next(value);
	                    }
	                }
	            });
	            //if we are currently authenticating, queue the data query after we have logged in
	            if (data.sdk.authentication.isAuthenticating()) {
	                var whenAuthenticatedPromise = data.sdk.authentication._ensureAuthentication();
	                if (!query.noRetry) {
	                    whenAuthenticatedPromise.then(function () {
	                        return iterator.restart();
	                    });
	                }
	                return whenAuthenticatedPromise;
	            }
	            else {
	                return iterator.next(value);
	            }
	        }
	        else {
	            return iterator.next(value);
	        }
	    };
	    return AuthenticationProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AuthenticationProcessor;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var constants_1 = __webpack_require__(2);
	var RequestService_1 = __webpack_require__(10);
	var BusinessLogicQueryProcessor = (function () {
	    function BusinessLogicQueryProcessor() {
	    }
	    BusinessLogicQueryProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        var op = query.operation;
	        if (op !== constants_1.DataQueryOperation.InvokeCloudFunction &&
	            op !== constants_1.DataQueryOperation.InvokeStoredProcedure) {
	            return iterator.next(value);
	        }
	        var request = RequestService_1.RequestService.buildRequest(query, data);
	        return request.send()
	            .then(function (res) {
	            return iterator.end(res);
	        })
	            .catch(function (err) {
	            return iterator.error(err);
	        });
	    };
	    return BusinessLogicQueryProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BusinessLogicQueryProcessor;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RequestService_1 = __webpack_require__(10);
	var CacheQueryProcessor = (function () {
	    function CacheQueryProcessor() {
	    }
	    CacheQueryProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        if (!query.useCache || (query.useCache && query.canUseOffline)) {
	            return iterator.next(value);
	        }
	        return this._cacheDataQuery(query, data)
	            .then(function (result) {
	            return iterator.next(result || value);
	        }, function (error) {
	            return iterator.error(error);
	        });
	    };
	    CacheQueryProcessor.prototype._cacheDataQuery = function (query, data) {
	        var shouldSkipCache = data.sdk.cache._shouldSkipCache(query);
	        if (shouldSkipCache) {
	            if (query.ignoreCache && !data.sdk.cache.isQueryUnsupportedOffline(query)) {
	                var hash = data.sdk.cache._getHashForQuery(query);
	                return data.sdk.cache._cacheQuery(query, hash, data);
	            }
	            else {
	                return RequestService_1.RequestService.handleRequestProcessing(query, data);
	            }
	        }
	        else {
	            query.useCache = false;
	            return data.sdk.cache._processCacheItem(query, data);
	        }
	    };
	    return CacheQueryProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CacheQueryProcessor;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var constants_1 = __webpack_require__(2);
	var EventQuery_1 = __webpack_require__(67);
	var beforeExecuteAllowedOperations = [
	    constants_1.DataQueryOperation.Count,
	    constants_1.DataQueryOperation.Read,
	    constants_1.DataQueryOperation.Create,
	    constants_1.DataQueryOperation.Update,
	    constants_1.DataQueryOperation.UpdateById,
	    constants_1.DataQueryOperation.Delete,
	    constants_1.DataQueryOperation.DeleteById,
	    constants_1.DataQueryOperation.ReadById,
	    constants_1.DataQueryOperation.Aggregate,
	    constants_1.DataQueryOperation.RawUpdate
	];
	var EventQueryProcessor = (function () {
	    function EventQueryProcessor() {
	    }
	    EventQueryProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        if (_.contains(beforeExecuteAllowedOperations, query.operation)) {
	            var eventQuery = EventQuery_1.EventQuery.fromDataQuery(query);
	            data.sdk.emit(constants_1.Constants.Events.BeforeExecute, eventQuery);
	            if (eventQuery.isCancelled()) {
	                return iterator.cancel();
	            }
	            query.applyEventQuery(eventQuery);
	        }
	        return iterator.next(value);
	    };
	    return EventQueryProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EventQueryProcessor;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var EverliveError_1 = __webpack_require__(3);
	var OfflineQueryProcessor = (function () {
	    function OfflineQueryProcessor() {
	    }
	    OfflineQueryProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        if (!query.canUseOffline) {
	            return iterator.next(value);
	        }
	        if (!query.applyOffline) {
	            var error = new EverliveError_1.EverliveError({ message: 'The applyOffline must be true when working offline.' });
	            return iterator.error(error);
	        }
	        else {
	            return data.offlineStorage.processQuery(query)
	                .then(function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i - 0] = arguments[_i];
	                }
	                return iterator.next.apply(iterator, args);
	            }, function (err) {
	                if (!err.code) {
	                    err = new EverliveError_1.EverliveError({ message: err.message, code: EverliveError_1.EverliveErrors.generalDatabaseError.code });
	                }
	                return iterator.error(err);
	            });
	        }
	    };
	    return OfflineQueryProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OfflineQueryProcessor;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RequestService_1 = __webpack_require__(10);
	var OnlineQueryProcessor = (function () {
	    function OnlineQueryProcessor() {
	    }
	    OnlineQueryProcessor.prototype.processDataQuery = function (query, iterator, data, value) {
	        if (query.canUseOffline || query.useCache) {
	            return iterator.next(value);
	        }
	        return RequestService_1.RequestService.handleRequestProcessing(query, data)
	            .then(function (result) {
	            return iterator.next(result || value);
	        }, function (err) {
	            return iterator.error(err);
	        });
	    };
	    return OnlineQueryProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = OnlineQueryProcessor;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var buffer = __webpack_require__(24);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(145);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if ('env' in (typeof process === 'undefined' ? {} : process)) {
	    r = process.env.DEBUG;
	  }
	  
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var type = __webpack_require__(170);
	
	/**
	 * Gets a certain `path` from the `obj`.
	 *
	 * @param {Object} target
	 * @param {String} key
	 * @return {Object} found object, or `undefined
	 * @api public
	 */
	
	exports.get = function(obj, path){
	  if (~path.indexOf('.')) {
	    var par = parent(obj, path);
	    var mainKey = path.split('.').pop();
	    var t = type(par);
	    if ('object' == t || 'array' == t) return par[mainKey];
	  } else {
	    return obj[path];
	  }
	};
	
	/**
	 * Sets the given `path` to `val` in `obj`.
	 *
	 * @param {Object} target
	 * @Param {String} key
	 * @param {Object} value
	 * @api public
	 */
	
	exports.set = function(obj, path, val){
	  if (~path.indexOf('.')) {
	    var par = parent(obj, path, true);
	    var mainKey = path.split('.').pop();
	    if (par && 'object' == type(par)) par[mainKey] = val;
	  } else {
	    obj[path] = val;
	  }
	};
	
	/**
	 * Gets the parent object for a given key (dot notation aware).
	 *
	 * - If a parent object doesn't exist, it's initialized.
	 * - Array index lookup is supported
	 *
	 * @param {Object} target object
	 * @param {String} key
	 * @param {Boolean} true if it should initialize the path
	 * @api public
	 */
	
	exports.parent = parent;
	
	function parent(obj, key, init){
	  if (~key.indexOf('.')) {
	    var pieces = key.split('.');
	    var ret = obj;
	
	    for (var i = 0; i < pieces.length - 1; i++) {
	      // if the key is a number string and parent is an array
	      if (Number(pieces[i]) == pieces[i] && 'array' == type(ret)) {
	        ret = ret[pieces[i]];
	      } else if ('object' == type(ret)) {
	        if (init && !ret.hasOwnProperty(pieces[i])) {
	          ret[pieces[i]] = {};
	        }
	        if (ret) ret = ret[pieces[i]];
	      }
	    }
	
	    return ret;
	  } else {
	    return obj;
	  }
	}


/***/ },
/* 88 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var type = __webpack_require__(25);
	
	/**
	 * Module exports.
	 */
	
	module.exports = eql;
	
	/**
	 * MongoDB style value comparisons.
	 *
	 * @param {Object} matcher
	 * @param {Object} value
	 * @return {Boolean} true if they match
	 */
	
	function eql(matcher, val){
	  switch (type(matcher)) {
	    case 'null':
	    case 'undefined':
	      // we treat null as undefined
	      return null == val;
	
	    case 'regexp':
	      return matcher.test(val);
	
	    case 'array':
	      if ('array' == type(val) && matcher.length == val.length) {
	        for (var i = 0; i < matcher.length; i++) {
	          if (!eql(val[i], matcher[i])) return false;
	        }
	        return true;
	      } else {
	        return false;
	      }
	      break;
	
	    case 'object':
	      // object can match keys in any order
	      var keys = {};
	
	      // we match all values of `matcher` in `val`
	      for (var i in matcher) {
	        if (matcher.hasOwnProperty(i)) {
	          if (!val.hasOwnProperty(i) || !eql(matcher[i], val[i])) {
	            return false;
	          }
	        }
	        keys[i] = true;
	      }
	
	      // we make sure `val` doesn't have extra keys
	      for (var i in val) {
	        if (val.hasOwnProperty(i) && !keys.hasOwnProperty(i)) {
	          return false;
	        }
	      }
	
	      return true;
	
	    default:
	      return matcher === val;
	  }
	}


/***/ },
/* 90 */
/***/ function(module, exports) {

	
	/**
	 * HOP ref.
	 */
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Return own keys in `obj`.
	 *
	 * @param {Object} obj
	 * @return {Array}
	 * @api public
	 */
	
	exports.keys = Object.keys || function(obj){
	  var keys = [];
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      keys.push(key);
	    }
	  }
	  return keys;
	};
	
	/**
	 * Return own values in `obj`.
	 *
	 * @param {Object} obj
	 * @return {Array}
	 * @api public
	 */
	
	exports.values = function(obj){
	  var vals = [];
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      vals.push(obj[key]);
	    }
	  }
	  return vals;
	};
	
	/**
	 * Merge `b` into `a`.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api public
	 */
	
	exports.merge = function(a, b){
	  for (var key in b) {
	    if (has.call(b, key)) {
	      a[key] = b[key];
	    }
	  }
	  return a;
	};
	
	/**
	 * Return length of `obj`.
	 *
	 * @param {Object} obj
	 * @return {Number}
	 * @api public
	 */
	
	exports.length = function(obj){
	  return exports.keys(obj).length;
	};
	
	/**
	 * Check if `obj` is empty.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api public
	 */
	
	exports.isEmpty = function(obj){
	  return 0 == exports.length(obj);
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(14);
	
	/*<replacement>*/
	var util = __webpack_require__(26);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(91);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(26);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(171)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(37);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(17).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(24).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(85);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(14);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance) {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(14);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(38).setImmediate))

/***/ },
/* 94 */
/***/ function(module, exports) {

	'use strict';
	function ExpandError(message) {
	    this.name = 'ExpandError';
	    this.message = message;
	    this.stack = (new Error()).stack;
	}
	ExpandError.prototype = new Error;
	module.exports = ExpandError;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module, setImmediate, process) {(function (global, factory) {
	     true ? factory(exports) :
	    typeof define === 'function' && define.amd ? define(['exports'], factory) :
	    (factory((global.async = global.async || {})));
	}(this, (function (exports) { 'use strict';
	
	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	
	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]';
	var genTag = '[object GeneratorFunction]';
	var proxyTag = '[object Proxy]';
	
	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto$1.toString;
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag || tag == proxyTag;
	}
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString$1.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype;
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());
	
	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};
	
	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 500;
	var HOT_SPAN = 16;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;
	
	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;
	
	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);
	
	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}
	
	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);
	
	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest$1(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}
	
	var initialParams = function (fn) {
	    return baseRest$1(function (args /*..., callback*/) {
	        var callback = args.pop();
	        fn.call(this, args, callback);
	    });
	};
	
	function applyEach$1(eachfn) {
	    return baseRest$1(function (fns, args) {
	        var go = initialParams(function (args, callback) {
	            var that = this;
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat([cb]));
	            }, callback);
	        });
	        if (args.length) {
	            return go.apply(this, args);
	        } else {
	            return go;
	        }
	    });
	}
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}
	
	function once(fn) {
	    return function () {
	        if (fn === null) return;
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	
	var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;
	
	var getIterator = function (coll) {
	    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
	};
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString$1 = objectProto$4.toString;
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && objectToString$1.call(value) == argsTag;
	}
	
	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER$1 : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]';
	var arrayTag = '[object Array]';
	var boolTag = '[object Boolean]';
	var dateTag = '[object Date]';
	var errorTag = '[object Error]';
	var funcTag$1 = '[object Function]';
	var mapTag = '[object Map]';
	var numberTag = '[object Number]';
	var objectTag = '[object Object]';
	var regexpTag = '[object RegExp]';
	var setTag = '[object Set]';
	var stringTag = '[object String]';
	var weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]';
	var dataViewTag = '[object DataView]';
	var float32Tag = '[object Float32Array]';
	var float64Tag = '[object Float64Array]';
	var int8Tag = '[object Int8Array]';
	var int16Tag = '[object Int16Array]';
	var int32Tag = '[object Int32Array]';
	var uint8Tag = '[object Uint8Array]';
	var uint8ClampedTag = '[object Uint8ClampedArray]';
	var uint16Tag = '[object Uint16Array]';
	var uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString$2 = objectProto$5.toString;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString$2.call(value)];
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty$1.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$7;
	
	  return value === proto;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$6.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	function createArrayIterator(coll) {
	    var i = -1;
	    var len = coll.length;
	    return function next() {
	        return ++i < len ? { value: coll[i], key: i } : null;
	    };
	}
	
	function createES2015Iterator(iterator) {
	    var i = -1;
	    return function next() {
	        var item = iterator.next();
	        if (item.done) return null;
	        i++;
	        return { value: item.value, key: i };
	    };
	}
	
	function createObjectIterator(obj) {
	    var okeys = keys(obj);
	    var i = -1;
	    var len = okeys.length;
	    return function next() {
	        var key = okeys[++i];
	        return i < len ? { value: obj[key], key: key } : null;
	    };
	}
	
	function iterator(coll) {
	    if (isArrayLike(coll)) {
	        return createArrayIterator(coll);
	    }
	
	    var iterator = getIterator(coll);
	    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
	}
	
	function onlyOnce(fn) {
	    return function () {
	        if (fn === null) throw new Error("Callback was already called.");
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	
	// A temporary value used to identify if the loop should be broken.
	// See #1064, #1293
	var breakLoop = {};
	
	function _eachOfLimit(limit) {
	    return function (obj, iteratee, callback) {
	        callback = once(callback || noop);
	        if (limit <= 0 || !obj) {
	            return callback(null);
	        }
	        var nextElem = iterator(obj);
	        var done = false;
	        var running = 0;
	
	        function iterateeCallback(err, value) {
	            running -= 1;
	            if (err) {
	                done = true;
	                callback(err);
	            } else if (value === breakLoop || done && running <= 0) {
	                done = true;
	                return callback(null);
	            } else {
	                replenish();
	            }
	        }
	
	        function replenish() {
	            while (running < limit && !done) {
	                var elem = nextElem();
	                if (elem === null) {
	                    done = true;
	                    if (running <= 0) {
	                        callback(null);
	                    }
	                    return;
	                }
	                running += 1;
	                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
	            }
	        }
	
	        replenish();
	    };
	}
	
	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name eachOfLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachOfLimit(coll, limit, iteratee, callback) {
	  _eachOfLimit(limit)(coll, iteratee, callback);
	}
	
	function doLimit(fn, limit) {
	    return function (iterable, iteratee, callback) {
	        return fn(iterable, limit, iteratee, callback);
	    };
	}
	
	// eachOf implementation optimized for array-likes
	function eachOfArrayLike(coll, iteratee, callback) {
	    callback = once(callback || noop);
	    var index = 0,
	        completed = 0,
	        length = coll.length;
	    if (length === 0) {
	        callback(null);
	    }
	
	    function iteratorCallback(err) {
	        if (err) {
	            callback(err);
	        } else if (++completed === length) {
	            callback(null);
	        }
	    }
	
	    for (; index < length; index++) {
	        iteratee(coll[index], index, onlyOnce(iteratorCallback));
	    }
	}
	
	// a generic version of eachOf which can handle array, object, and iterator cases.
	var eachOfGeneric = doLimit(eachOfLimit, Infinity);
	
	/**
	 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
	 * to the iteratee.
	 *
	 * @name eachOf
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEachOf
	 * @category Collection
	 * @see [async.each]{@link module:Collections.each}
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
	 * var configs = {};
	 *
	 * async.forEachOf(obj, function (value, key, callback) {
	 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
	 *         if (err) return callback(err);
	 *         try {
	 *             configs[key] = JSON.parse(data);
	 *         } catch (e) {
	 *             return callback(e);
	 *         }
	 *         callback();
	 *     });
	 * }, function (err) {
	 *     if (err) console.error(err.message);
	 *     // configs is now a map of JSON data
	 *     doSomethingWith(configs);
	 * });
	 */
	var eachOf = function (coll, iteratee, callback) {
	    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
	    eachOfImplementation(coll, iteratee, callback);
	};
	
	function doParallel(fn) {
	    return function (obj, iteratee, callback) {
	        return fn(eachOf, obj, iteratee, callback);
	    };
	}
	
	function _asyncMap(eachfn, arr, iteratee, callback) {
	    callback = once(callback || noop);
	    arr = arr || [];
	    var results = [];
	    var counter = 0;
	
	    eachfn(arr, function (value, _, callback) {
	        var index = counter++;
	        iteratee(value, function (err, v) {
	            results[index] = v;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, results);
	    });
	}
	
	/**
	 * Produces a new collection of values by mapping each value in `coll` through
	 * the `iteratee` function. The `iteratee` is called with an item from `coll`
	 * and a callback for when it has finished processing. Each of these callback
	 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
	 * `iteratee` passes an error to its callback, the main `callback` (for the
	 * `map` function) is immediately called with the error.
	 *
	 * Note, that since this function applies the `iteratee` to each item in
	 * parallel, there is no guarantee that the `iteratee` functions will complete
	 * in order. However, the results array will be in the same order as the
	 * original `coll`.
	 *
	 * If `map` is passed an Object, the results will be an Array.  The results
	 * will roughly be in the order of the original Objects' keys (but this can
	 * vary across JavaScript engines)
	 *
	 * @name map
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an Array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 * @example
	 *
	 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
	 *     // results is now an array of stats for each file
	 * });
	 */
	var map = doParallel(_asyncMap);
	
	/**
	 * Applies the provided arguments to each function in the array, calling
	 * `callback` after all functions have completed. If you only provide the first
	 * argument, `fns`, then it will return a function which lets you pass in the
	 * arguments as if it were a single function call. If more arguments are
	 * provided, `callback` is required while `args` is still optional.
	 *
	 * @name applyEach
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of asynchronous functions
	 * to all call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument, `fns`, is provided, it will
	 * return a function which lets you pass in the arguments as if it were a single
	 * function call. The signature is `(..args, callback)`. If invoked with any
	 * arguments, `callback` is required.
	 * @example
	 *
	 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
	 *
	 * // partial application example:
	 * async.each(
	 *     buckets,
	 *     async.applyEach([enableSearch, updateSchema]),
	 *     callback
	 * );
	 */
	var applyEach = applyEach$1(map);
	
	function doParallelLimit(fn) {
	    return function (obj, limit, iteratee, callback) {
	        return fn(_eachOfLimit(limit), obj, iteratee, callback);
	    };
	}
	
	/**
	 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name mapLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a transformed
	 * item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapLimit = doParallelLimit(_asyncMap);
	
	/**
	 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
	 *
	 * @name mapSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed item. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapSeries = doLimit(mapLimit, 1);
	
	/**
	 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
	 *
	 * @name applyEachSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of asynchronous functions to all
	 * call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument is provided, it will return
	 * a function which lets you pass in the arguments as if it were a single
	 * function call.
	 */
	var applyEachSeries = applyEach$1(mapSeries);
	
	/**
	 * Creates a continuation function with some arguments already applied.
	 *
	 * Useful as a shorthand when combined with other control flow functions. Any
	 * arguments passed to the returned function are added to the arguments
	 * originally passed to apply.
	 *
	 * @name apply
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to. Invokes with (arguments...).
	 * @param {...*} arguments... - Any number of arguments to automatically apply
	 * when the continuation is called.
	 * @example
	 *
	 * // using apply
	 * async.parallel([
	 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
	 *     async.apply(fs.writeFile, 'testfile2', 'test2')
	 * ]);
	 *
	 *
	 * // the same process without using apply
	 * async.parallel([
	 *     function(callback) {
	 *         fs.writeFile('testfile1', 'test1', callback);
	 *     },
	 *     function(callback) {
	 *         fs.writeFile('testfile2', 'test2', callback);
	 *     }
	 * ]);
	 *
	 * // It's possible to pass any number of additional arguments when calling the
	 * // continuation:
	 *
	 * node> var fn = async.apply(sys.puts, 'one');
	 * node> fn('two', 'three');
	 * one
	 * two
	 * three
	 */
	var apply$2 = baseRest$1(function (fn, args) {
	    return baseRest$1(function (callArgs) {
	        return fn.apply(null, args.concat(callArgs));
	    });
	});
	
	/**
	 * Take a sync function and make it async, passing its return value to a
	 * callback. This is useful for plugging sync functions into a waterfall,
	 * series, or other async functions. Any arguments passed to the generated
	 * function will be passed to the wrapped function (except for the final
	 * callback argument). Errors thrown will be passed to the callback.
	 *
	 * If the function passed to `asyncify` returns a Promise, that promises's
	 * resolved/rejected state will be used to call the callback, rather than simply
	 * the synchronous return value.
	 *
	 * This also means you can asyncify ES2016 `async` functions.
	 *
	 * @name asyncify
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @alias wrapSync
	 * @category Util
	 * @param {Function} func - The synchronous function to convert to an
	 * asynchronous function.
	 * @returns {Function} An asynchronous wrapper of the `func`. To be invoked with
	 * (callback).
	 * @example
	 *
	 * // passing a regular synchronous function
	 * async.waterfall([
	 *     async.apply(fs.readFile, filename, "utf8"),
	 *     async.asyncify(JSON.parse),
	 *     function (data, next) {
	 *         // data is the result of parsing the text.
	 *         // If there was a parsing error, it would have been caught.
	 *     }
	 * ], callback);
	 *
	 * // passing a function returning a promise
	 * async.waterfall([
	 *     async.apply(fs.readFile, filename, "utf8"),
	 *     async.asyncify(function (contents) {
	 *         return db.model.create(contents);
	 *     }),
	 *     function (model, next) {
	 *         // `model` is the instantiated model object.
	 *         // If there was an error, this function would be skipped.
	 *     }
	 * ], callback);
	 *
	 * // es6 example
	 * var q = async.queue(async.asyncify(async function(file) {
	 *     var intermediateStep = await processFile(file);
	 *     return await somePromise(intermediateStep)
	 * }));
	 *
	 * q.push(files);
	 */
	function asyncify(func) {
	    return initialParams(function (args, callback) {
	        var result;
	        try {
	            result = func.apply(this, args);
	        } catch (e) {
	            return callback(e);
	        }
	        // if result is Promise object
	        if (isObject(result) && typeof result.then === 'function') {
	            result.then(function (value) {
	                callback(null, value);
	            }, function (err) {
	                callback(err.message ? err : new Error(err));
	            });
	        } else {
	            callback(null, result);
	        }
	    });
	}
	
	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0;
	
	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}
	
	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;
	
	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}
	
	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);
	
	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}
	
	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;
	
	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}
	
	/**
	 * Determines the best order for running the functions in `tasks`, based on
	 * their requirements. Each function can optionally depend on other functions
	 * being completed first, and each function is run as soon as its requirements
	 * are satisfied.
	 *
	 * If any of the functions pass an error to their callback, the `auto` sequence
	 * will stop. Further tasks will not execute (so any other functions depending
	 * on it will not run), and the main `callback` is immediately called with the
	 * error.
	 *
	 * Functions also receive an object containing the results of functions which
	 * have completed so far as the first argument, if they have dependencies. If a
	 * task function has no dependencies, it will only be passed a callback.
	 *
	 * @name auto
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Object} tasks - An object. Each of its properties is either a
	 * function or an array of requirements, with the function itself the last item
	 * in the array. The object's key of a property serves as the name of the task
	 * defined by that property, i.e. can be used when specifying requirements for
	 * other tasks. The function receives one or two arguments:
	 * * a `results` object, containing the results of the previously executed
	 *   functions, only passed if the task has any dependencies,
	 * * a `callback(err, result)` function, which must be called when finished,
	 *   passing an `error` (which can be `null`) and the result of the function's
	 *   execution.
	 * @param {number} [concurrency=Infinity] - An optional `integer` for
	 * determining the maximum number of tasks that can be run in parallel. By
	 * default, as many as possible.
	 * @param {Function} [callback] - An optional callback which is called when all
	 * the tasks have been completed. It receives the `err` argument if any `tasks`
	 * pass an error to their callback. Results are always returned; however, if an
	 * error occurs, no further `tasks` will be performed, and the results object
	 * will only contain partial results. Invoked with (err, results).
	 * @returns undefined
	 * @example
	 *
	 * async.auto({
	 *     // this function will just be passed a callback
	 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
	 *     showData: ['readData', function(results, cb) {
	 *         // results.readData is the file's contents
	 *         // ...
	 *     }]
	 * }, callback);
	 *
	 * async.auto({
	 *     get_data: function(callback) {
	 *         console.log('in get_data');
	 *         // async code to get some data
	 *         callback(null, 'data', 'converted to array');
	 *     },
	 *     make_folder: function(callback) {
	 *         console.log('in make_folder');
	 *         // async code to create a directory to store a file in
	 *         // this is run at the same time as getting the data
	 *         callback(null, 'folder');
	 *     },
	 *     write_file: ['get_data', 'make_folder', function(results, callback) {
	 *         console.log('in write_file', JSON.stringify(results));
	 *         // once there is some data and the directory exists,
	 *         // write the data to a file in the directory
	 *         callback(null, 'filename');
	 *     }],
	 *     email_link: ['write_file', function(results, callback) {
	 *         console.log('in email_link', JSON.stringify(results));
	 *         // once the file is written let's email a link to it...
	 *         // results.write_file contains the filename returned by write_file.
	 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
	 *     }]
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('results = ', results);
	 * });
	 */
	var auto = function (tasks, concurrency, callback) {
	    if (typeof concurrency === 'function') {
	        // concurrency is optional, shift the args.
	        callback = concurrency;
	        concurrency = null;
	    }
	    callback = once(callback || noop);
	    var keys$$1 = keys(tasks);
	    var numTasks = keys$$1.length;
	    if (!numTasks) {
	        return callback(null);
	    }
	    if (!concurrency) {
	        concurrency = numTasks;
	    }
	
	    var results = {};
	    var runningTasks = 0;
	    var hasError = false;
	
	    var listeners = {};
	
	    var readyTasks = [];
	
	    // for cycle detection:
	    var readyToCheck = []; // tasks that have been identified as reachable
	    // without the possibility of returning to an ancestor task
	    var uncheckedDependencies = {};
	
	    baseForOwn(tasks, function (task, key) {
	        if (!isArray(task)) {
	            // no dependencies
	            enqueueTask(key, [task]);
	            readyToCheck.push(key);
	            return;
	        }
	
	        var dependencies = task.slice(0, task.length - 1);
	        var remainingDependencies = dependencies.length;
	        if (remainingDependencies === 0) {
	            enqueueTask(key, task);
	            readyToCheck.push(key);
	            return;
	        }
	        uncheckedDependencies[key] = remainingDependencies;
	
	        arrayEach(dependencies, function (dependencyName) {
	            if (!tasks[dependencyName]) {
	                throw new Error('async.auto task `' + key + '` has a non-existent dependency in ' + dependencies.join(', '));
	            }
	            addListener(dependencyName, function () {
	                remainingDependencies--;
	                if (remainingDependencies === 0) {
	                    enqueueTask(key, task);
	                }
	            });
	        });
	    });
	
	    checkForDeadlocks();
	    processQueue();
	
	    function enqueueTask(key, task) {
	        readyTasks.push(function () {
	            runTask(key, task);
	        });
	    }
	
	    function processQueue() {
	        if (readyTasks.length === 0 && runningTasks === 0) {
	            return callback(null, results);
	        }
	        while (readyTasks.length && runningTasks < concurrency) {
	            var run = readyTasks.shift();
	            run();
	        }
	    }
	
	    function addListener(taskName, fn) {
	        var taskListeners = listeners[taskName];
	        if (!taskListeners) {
	            taskListeners = listeners[taskName] = [];
	        }
	
	        taskListeners.push(fn);
	    }
	
	    function taskComplete(taskName) {
	        var taskListeners = listeners[taskName] || [];
	        arrayEach(taskListeners, function (fn) {
	            fn();
	        });
	        processQueue();
	    }
	
	    function runTask(key, task) {
	        if (hasError) return;
	
	        var taskCallback = onlyOnce(baseRest$1(function (err, args) {
	            runningTasks--;
	            if (args.length <= 1) {
	                args = args[0];
	            }
	            if (err) {
	                var safeResults = {};
	                baseForOwn(results, function (val, rkey) {
	                    safeResults[rkey] = val;
	                });
	                safeResults[key] = args;
	                hasError = true;
	                listeners = [];
	
	                callback(err, safeResults);
	            } else {
	                results[key] = args;
	                taskComplete(key);
	            }
	        }));
	
	        runningTasks++;
	        var taskFn = task[task.length - 1];
	        if (task.length > 1) {
	            taskFn(results, taskCallback);
	        } else {
	            taskFn(taskCallback);
	        }
	    }
	
	    function checkForDeadlocks() {
	        // Kahn's algorithm
	        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
	        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
	        var currentTask;
	        var counter = 0;
	        while (readyToCheck.length) {
	            currentTask = readyToCheck.pop();
	            counter++;
	            arrayEach(getDependents(currentTask), function (dependent) {
	                if (--uncheckedDependencies[dependent] === 0) {
	                    readyToCheck.push(dependent);
	                }
	            });
	        }
	
	        if (counter !== numTasks) {
	            throw new Error('async.auto cannot execute tasks due to a recursive dependency');
	        }
	    }
	
	    function getDependents(taskName) {
	        var result = [];
	        baseForOwn(tasks, function (task, key) {
	            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
	                result.push(key);
	            }
	        });
	        return result;
	    }
	};
	
	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;
	
	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}
	
	/** Built-in value references. */
	var Symbol$1 = root.Symbol;
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString$3 = objectProto$8.toString;
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString$3.call(value) == symbolTag);
	}
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
	var symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;
	
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;
	
	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}
	
	/**
	 * Casts `array` to a slice if it's needed.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {number} start The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the cast slice.
	 */
	function castSlice(array, start, end) {
	  var length = array.length;
	  end = end === undefined ? length : end;
	  return (!start && end >= length) ? array : baseSlice(array, start, end);
	}
	
	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the last unmatched string symbol.
	 */
	function charsEndIndex(strSymbols, chrSymbols) {
	  var index = strSymbols.length;
	
	  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}
	
	/**
	 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the first unmatched string symbol.
	 */
	function charsStartIndex(strSymbols, chrSymbols) {
	  var index = -1,
	      length = strSymbols.length;
	
	  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}
	
	/**
	 * Converts an ASCII `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function asciiToArray(string) {
	  return string.split('');
	}
	
	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff';
	var rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23';
	var rsComboSymbolsRange = '\\u20d0-\\u20f0';
	var rsVarRange = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsZWJ = '\\u200d';
	
	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
	
	/**
	 * Checks if `string` contains Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	 */
	function hasUnicode(string) {
	  return reHasUnicode.test(string);
	}
	
	/** Used to compose unicode character classes. */
	var rsAstralRange$1 = '\\ud800-\\udfff';
	var rsComboMarksRange$1 = '\\u0300-\\u036f\\ufe20-\\ufe23';
	var rsComboSymbolsRange$1 = '\\u20d0-\\u20f0';
	var rsVarRange$1 = '\\ufe0e\\ufe0f';
	
	/** Used to compose unicode capture groups. */
	var rsAstral = '[' + rsAstralRange$1 + ']';
	var rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';
	var rsFitz = '\\ud83c[\\udffb-\\udfff]';
	var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
	var rsNonAstral = '[^' + rsAstralRange$1 + ']';
	var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
	var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
	var rsZWJ$1 = '\\u200d';
	
	/** Used to compose unicode regexes. */
	var reOptMod = rsModifier + '?';
	var rsOptVar = '[' + rsVarRange$1 + ']?';
	var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
	var rsSeq = rsOptVar + reOptMod + rsOptJoin;
	var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	/**
	 * Converts a Unicode `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function unicodeToArray(string) {
	  return string.match(reUnicode) || [];
	}
	
	/**
	 * Converts `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function stringToArray(string) {
	  return hasUnicode(string)
	    ? unicodeToArray(string)
	    : asciiToArray(string);
	}
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/**
	 * Removes leading and trailing whitespace or specified characters from `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to trim.
	 * @param {string} [chars=whitespace] The characters to trim.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the trimmed string.
	 * @example
	 *
	 * _.trim('  abc  ');
	 * // => 'abc'
	 *
	 * _.trim('-_-abc-_-', '_-');
	 * // => 'abc'
	 *
	 * _.map(['  foo  ', '  bar  '], _.trim);
	 * // => ['foo', 'bar']
	 */
	function trim(string, chars, guard) {
	  string = toString(string);
	  if (string && (guard || chars === undefined)) {
	    return string.replace(reTrim, '');
	  }
	  if (!string || !(chars = baseToString(chars))) {
	    return string;
	  }
	  var strSymbols = stringToArray(string),
	      chrSymbols = stringToArray(chars),
	      start = charsStartIndex(strSymbols, chrSymbols),
	      end = charsEndIndex(strSymbols, chrSymbols) + 1;
	
	  return castSlice(strSymbols, start, end).join('');
	}
	
	var FN_ARGS = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
	var FN_ARG_SPLIT = /,/;
	var FN_ARG = /(=.+)?(\s*)$/;
	var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	
	function parseParams(func) {
	    func = func.toString().replace(STRIP_COMMENTS, '');
	    func = func.match(FN_ARGS)[2].replace(' ', '');
	    func = func ? func.split(FN_ARG_SPLIT) : [];
	    func = func.map(function (arg) {
	        return trim(arg.replace(FN_ARG, ''));
	    });
	    return func;
	}
	
	/**
	 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
	 * tasks are specified as parameters to the function, after the usual callback
	 * parameter, with the parameter names matching the names of the tasks it
	 * depends on. This can provide even more readable task graphs which can be
	 * easier to maintain.
	 *
	 * If a final callback is specified, the task results are similarly injected,
	 * specified as named parameters after the initial error parameter.
	 *
	 * The autoInject function is purely syntactic sugar and its semantics are
	 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
	 *
	 * @name autoInject
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.auto]{@link module:ControlFlow.auto}
	 * @category Control Flow
	 * @param {Object} tasks - An object, each of whose properties is a function of
	 * the form 'func([dependencies...], callback). The object's key of a property
	 * serves as the name of the task defined by that property, i.e. can be used
	 * when specifying requirements for other tasks.
	 * * The `callback` parameter is a `callback(err, result)` which must be called
	 *   when finished, passing an `error` (which can be `null`) and the result of
	 *   the function's execution. The remaining parameters name other tasks on
	 *   which the task is dependent, and the results from those tasks are the
	 *   arguments of those parameters.
	 * @param {Function} [callback] - An optional callback which is called when all
	 * the tasks have been completed. It receives the `err` argument if any `tasks`
	 * pass an error to their callback, and a `results` object with any completed
	 * task results, similar to `auto`.
	 * @example
	 *
	 * //  The example from `auto` can be rewritten as follows:
	 * async.autoInject({
	 *     get_data: function(callback) {
	 *         // async code to get some data
	 *         callback(null, 'data', 'converted to array');
	 *     },
	 *     make_folder: function(callback) {
	 *         // async code to create a directory to store a file in
	 *         // this is run at the same time as getting the data
	 *         callback(null, 'folder');
	 *     },
	 *     write_file: function(get_data, make_folder, callback) {
	 *         // once there is some data and the directory exists,
	 *         // write the data to a file in the directory
	 *         callback(null, 'filename');
	 *     },
	 *     email_link: function(write_file, callback) {
	 *         // once the file is written let's email a link to it...
	 *         // write_file contains the filename returned by write_file.
	 *         callback(null, {'file':write_file, 'email':'user@example.com'});
	 *     }
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('email_link = ', results.email_link);
	 * });
	 *
	 * // If you are using a JS minifier that mangles parameter names, `autoInject`
	 * // will not work with plain functions, since the parameter names will be
	 * // collapsed to a single letter identifier.  To work around this, you can
	 * // explicitly specify the names of the parameters your task function needs
	 * // in an array, similar to Angular.js dependency injection.
	 *
	 * // This still has an advantage over plain `auto`, since the results a task
	 * // depends on are still spread into arguments.
	 * async.autoInject({
	 *     //...
	 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
	 *         callback(null, 'filename');
	 *     }],
	 *     email_link: ['write_file', function(write_file, callback) {
	 *         callback(null, {'file':write_file, 'email':'user@example.com'});
	 *     }]
	 *     //...
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('email_link = ', results.email_link);
	 * });
	 */
	function autoInject(tasks, callback) {
	    var newTasks = {};
	
	    baseForOwn(tasks, function (taskFn, key) {
	        var params;
	
	        if (isArray(taskFn)) {
	            params = copyArray(taskFn);
	            taskFn = params.pop();
	
	            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
	        } else if (taskFn.length === 1) {
	            // no dependencies, use the function as-is
	            newTasks[key] = taskFn;
	        } else {
	            params = parseParams(taskFn);
	            if (taskFn.length === 0 && params.length === 0) {
	                throw new Error("autoInject task functions require explicit parameters.");
	            }
	
	            params.pop();
	
	            newTasks[key] = params.concat(newTask);
	        }
	
	        function newTask(results, taskCb) {
	            var newArgs = arrayMap(params, function (name) {
	                return results[name];
	            });
	            newArgs.push(taskCb);
	            taskFn.apply(null, newArgs);
	        }
	    });
	
	    auto(newTasks, callback);
	}
	
	var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
	var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';
	
	function fallback(fn) {
	    setTimeout(fn, 0);
	}
	
	function wrap(defer) {
	    return baseRest$1(function (fn, args) {
	        defer(function () {
	            fn.apply(null, args);
	        });
	    });
	}
	
	var _defer;
	
	if (hasSetImmediate) {
	    _defer = setImmediate;
	} else if (hasNextTick) {
	    _defer = process.nextTick;
	} else {
	    _defer = fallback;
	}
	
	var setImmediate$1 = wrap(_defer);
	
	// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
	// used for queues. This implementation assumes that the node provided by the user can be modified
	// to adjust the next and last properties. We implement only the minimal functionality
	// for queue support.
	function DLL() {
	    this.head = this.tail = null;
	    this.length = 0;
	}
	
	function setInitial(dll, node) {
	    dll.length = 1;
	    dll.head = dll.tail = node;
	}
	
	DLL.prototype.removeLink = function (node) {
	    if (node.prev) node.prev.next = node.next;else this.head = node.next;
	    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;
	
	    node.prev = node.next = null;
	    this.length -= 1;
	    return node;
	};
	
	DLL.prototype.empty = DLL;
	
	DLL.prototype.insertAfter = function (node, newNode) {
	    newNode.prev = node;
	    newNode.next = node.next;
	    if (node.next) node.next.prev = newNode;else this.tail = newNode;
	    node.next = newNode;
	    this.length += 1;
	};
	
	DLL.prototype.insertBefore = function (node, newNode) {
	    newNode.prev = node.prev;
	    newNode.next = node;
	    if (node.prev) node.prev.next = newNode;else this.head = newNode;
	    node.prev = newNode;
	    this.length += 1;
	};
	
	DLL.prototype.unshift = function (node) {
	    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
	};
	
	DLL.prototype.push = function (node) {
	    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
	};
	
	DLL.prototype.shift = function () {
	    return this.head && this.removeLink(this.head);
	};
	
	DLL.prototype.pop = function () {
	    return this.tail && this.removeLink(this.tail);
	};
	
	function queue(worker, concurrency, payload) {
	    if (concurrency == null) {
	        concurrency = 1;
	    } else if (concurrency === 0) {
	        throw new Error('Concurrency must not be zero');
	    }
	
	    function _insert(data, insertAtFront, callback) {
	        if (callback != null && typeof callback !== 'function') {
	            throw new Error('task callback must be a function');
	        }
	        q.started = true;
	        if (!isArray(data)) {
	            data = [data];
	        }
	        if (data.length === 0 && q.idle()) {
	            // call drain immediately if there are no tasks
	            return setImmediate$1(function () {
	                q.drain();
	            });
	        }
	
	        for (var i = 0, l = data.length; i < l; i++) {
	            var item = {
	                data: data[i],
	                callback: callback || noop
	            };
	
	            if (insertAtFront) {
	                q._tasks.unshift(item);
	            } else {
	                q._tasks.push(item);
	            }
	        }
	        setImmediate$1(q.process);
	    }
	
	    function _next(tasks) {
	        return baseRest$1(function (args) {
	            workers -= 1;
	
	            for (var i = 0, l = tasks.length; i < l; i++) {
	                var task = tasks[i];
	                var index = baseIndexOf(workersList, task, 0);
	                if (index >= 0) {
	                    workersList.splice(index);
	                }
	
	                task.callback.apply(task, args);
	
	                if (args[0] != null) {
	                    q.error(args[0], task.data);
	                }
	            }
	
	            if (workers <= q.concurrency - q.buffer) {
	                q.unsaturated();
	            }
	
	            if (q.idle()) {
	                q.drain();
	            }
	            q.process();
	        });
	    }
	
	    var workers = 0;
	    var workersList = [];
	    var q = {
	        _tasks: new DLL(),
	        concurrency: concurrency,
	        payload: payload,
	        saturated: noop,
	        unsaturated: noop,
	        buffer: concurrency / 4,
	        empty: noop,
	        drain: noop,
	        error: noop,
	        started: false,
	        paused: false,
	        push: function (data, callback) {
	            _insert(data, false, callback);
	        },
	        kill: function () {
	            q.drain = noop;
	            q._tasks.empty();
	        },
	        unshift: function (data, callback) {
	            _insert(data, true, callback);
	        },
	        process: function () {
	            while (!q.paused && workers < q.concurrency && q._tasks.length) {
	                var tasks = [],
	                    data = [];
	                var l = q._tasks.length;
	                if (q.payload) l = Math.min(l, q.payload);
	                for (var i = 0; i < l; i++) {
	                    var node = q._tasks.shift();
	                    tasks.push(node);
	                    data.push(node.data);
	                }
	
	                if (q._tasks.length === 0) {
	                    q.empty();
	                }
	                workers += 1;
	                workersList.push(tasks[0]);
	
	                if (workers === q.concurrency) {
	                    q.saturated();
	                }
	
	                var cb = onlyOnce(_next(tasks));
	                worker(data, cb);
	            }
	        },
	        length: function () {
	            return q._tasks.length;
	        },
	        running: function () {
	            return workers;
	        },
	        workersList: function () {
	            return workersList;
	        },
	        idle: function () {
	            return q._tasks.length + workers === 0;
	        },
	        pause: function () {
	            q.paused = true;
	        },
	        resume: function () {
	            if (q.paused === false) {
	                return;
	            }
	            q.paused = false;
	            var resumeCount = Math.min(q.concurrency, q._tasks.length);
	            // Need to call q.process once per concurrent
	            // worker to preserve full concurrency after pause
	            for (var w = 1; w <= resumeCount; w++) {
	                setImmediate$1(q.process);
	            }
	        }
	    };
	    return q;
	}
	
	/**
	 * A cargo of tasks for the worker function to complete. Cargo inherits all of
	 * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.
	 * @typedef {Object} CargoObject
	 * @memberOf module:ControlFlow
	 * @property {Function} length - A function returning the number of items
	 * waiting to be processed. Invoke like `cargo.length()`.
	 * @property {number} payload - An `integer` for determining how many tasks
	 * should be process per round. This property can be changed after a `cargo` is
	 * created to alter the payload on-the-fly.
	 * @property {Function} push - Adds `task` to the `queue`. The callback is
	 * called once the `worker` has finished processing the task. Instead of a
	 * single task, an array of `tasks` can be submitted. The respective callback is
	 * used for every task in the list. Invoke like `cargo.push(task, [callback])`.
	 * @property {Function} saturated - A callback that is called when the
	 * `queue.length()` hits the concurrency and further tasks will be queued.
	 * @property {Function} empty - A callback that is called when the last item
	 * from the `queue` is given to a `worker`.
	 * @property {Function} drain - A callback that is called when the last item
	 * from the `queue` has returned from the `worker`.
	 * @property {Function} idle - a function returning false if there are items
	 * waiting or being processed, or true if not. Invoke like `cargo.idle()`.
	 * @property {Function} pause - a function that pauses the processing of tasks
	 * until `resume()` is called. Invoke like `cargo.pause()`.
	 * @property {Function} resume - a function that resumes the processing of
	 * queued tasks when the queue is paused. Invoke like `cargo.resume()`.
	 * @property {Function} kill - a function that removes the `drain` callback and
	 * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.
	 */
	
	/**
	 * Creates a `cargo` object with the specified payload. Tasks added to the
	 * cargo will be processed altogether (up to the `payload` limit). If the
	 * `worker` is in progress, the task is queued until it becomes available. Once
	 * the `worker` has completed some tasks, each callback of those tasks is
	 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
	 * for how `cargo` and `queue` work.
	 *
	 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
	 * at a time, cargo passes an array of tasks to a single worker, repeating
	 * when the worker is finished.
	 *
	 * @name cargo
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.queue]{@link module:ControlFlow.queue}
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing an array
	 * of queued tasks, which must call its `callback(err)` argument when finished,
	 * with an optional `err` argument. Invoked with `(tasks, callback)`.
	 * @param {number} [payload=Infinity] - An optional `integer` for determining
	 * how many tasks should be processed per round; if omitted, the default is
	 * unlimited.
	 * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
	 * attached as certain properties to listen for specific events during the
	 * lifecycle of the cargo and inner queue.
	 * @example
	 *
	 * // create a cargo object with payload 2
	 * var cargo = async.cargo(function(tasks, callback) {
	 *     for (var i=0; i<tasks.length; i++) {
	 *         console.log('hello ' + tasks[i].name);
	 *     }
	 *     callback();
	 * }, 2);
	 *
	 * // add some items
	 * cargo.push({name: 'foo'}, function(err) {
	 *     console.log('finished processing foo');
	 * });
	 * cargo.push({name: 'bar'}, function(err) {
	 *     console.log('finished processing bar');
	 * });
	 * cargo.push({name: 'baz'}, function(err) {
	 *     console.log('finished processing baz');
	 * });
	 */
	function cargo(worker, payload) {
	  return queue(worker, 1, payload);
	}
	
	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
	 *
	 * @name eachOfSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`. The
	 * `key` is the item's key, or index in the case of an array. The iteratee is
	 * passed a `callback(err)` which must be called once it has completed. If no
	 * error has occurred, the callback should be run without arguments or with an
	 * explicit `null` argument. Invoked with (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Invoked with (err).
	 */
	var eachOfSeries = doLimit(eachOfLimit, 1);
	
	/**
	 * Reduces `coll` into a single value using an async `iteratee` to return each
	 * successive step. `memo` is the initial state of the reduction. This function
	 * only operates in series.
	 *
	 * For performance reasons, it may make sense to split a call to this function
	 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
	 * results. This function is for situations where each step in the reduction
	 * needs to be async; if you can get the data before reducing it, then it's
	 * probably a good idea to do so.
	 *
	 * @name reduce
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias inject
	 * @alias foldl
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {*} memo - The initial state of the reduction.
	 * @param {Function} iteratee - A function applied to each item in the
	 * array to produce the next step in the reduction. The `iteratee` is passed a
	 * `callback(err, reduction)` which accepts an optional error as its first
	 * argument, and the state of the reduction as the second. If an error is
	 * passed to the callback, the reduction is stopped and the main `callback` is
	 * immediately called with the error. Invoked with (memo, item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the reduced value. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.reduce([1,2,3], 0, function(memo, item, callback) {
	 *     // pointless async:
	 *     process.nextTick(function() {
	 *         callback(null, memo + item)
	 *     });
	 * }, function(err, result) {
	 *     // result is now equal to the last value of memo, which is 6
	 * });
	 */
	function reduce(coll, memo, iteratee, callback) {
	    callback = once(callback || noop);
	    eachOfSeries(coll, function (x, i, callback) {
	        iteratee(memo, x, function (err, v) {
	            memo = v;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, memo);
	    });
	}
	
	/**
	 * Version of the compose function that is more natural to read. Each function
	 * consumes the return value of the previous function. It is the equivalent of
	 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name seq
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.compose]{@link module:ControlFlow.compose}
	 * @category Control Flow
	 * @param {...Function} functions - the asynchronous functions to compose
	 * @returns {Function} a function that composes the `functions` in order
	 * @example
	 *
	 * // Requires lodash (or underscore), express3 and dresende's orm2.
	 * // Part of an app, that fetches cats of the logged user.
	 * // This example uses `seq` function to avoid overnesting and error
	 * // handling clutter.
	 * app.get('/cats', function(request, response) {
	 *     var User = request.models.User;
	 *     async.seq(
	 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
	 *         function(user, fn) {
	 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
	 *         }
	 *     )(req.session.user_id, function (err, cats) {
	 *         if (err) {
	 *             console.error(err);
	 *             response.json({ status: 'error', message: err.message });
	 *         } else {
	 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
	 *         }
	 *     });
	 * });
	 */
	var seq$1 = baseRest$1(function seq(functions) {
	    return baseRest$1(function (args) {
	        var that = this;
	
	        var cb = args[args.length - 1];
	        if (typeof cb == 'function') {
	            args.pop();
	        } else {
	            cb = noop;
	        }
	
	        reduce(functions, args, function (newargs, fn, cb) {
	            fn.apply(that, newargs.concat([baseRest$1(function (err, nextargs) {
	                cb(err, nextargs);
	            })]));
	        }, function (err, results) {
	            cb.apply(that, [err].concat(results));
	        });
	    });
	});
	
	/**
	 * Creates a function which is a composition of the passed asynchronous
	 * functions. Each function consumes the return value of the function that
	 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
	 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name compose
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {...Function} functions - the asynchronous functions to compose
	 * @returns {Function} an asynchronous function that is the composed
	 * asynchronous `functions`
	 * @example
	 *
	 * function add1(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n + 1);
	 *     }, 10);
	 * }
	 *
	 * function mul3(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n * 3);
	 *     }, 10);
	 * }
	 *
	 * var add1mul3 = async.compose(mul3, add1);
	 * add1mul3(4, function (err, result) {
	 *     // result now equals 15
	 * });
	 */
	var compose = baseRest$1(function (args) {
	  return seq$1.apply(null, args.reverse());
	});
	
	function concat$1(eachfn, arr, fn, callback) {
	    var result = [];
	    eachfn(arr, function (x, index, cb) {
	        fn(x, function (err, y) {
	            result = result.concat(y || []);
	            cb(err);
	        });
	    }, function (err) {
	        callback(err, result);
	    });
	}
	
	/**
	 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
	 * the concatenated list. The `iteratee`s are called in parallel, and the
	 * results are concatenated as they return. There is no guarantee that the
	 * results array will be returned in the original order of `coll` passed to the
	 * `iteratee` function.
	 *
	 * @name concat
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, results)` which must be called once
	 * it has completed with an error (which can be `null`) and an array of results.
	 * Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 * @example
	 *
	 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
	 *     // files is now a list of filenames that exist in the 3 directories
	 * });
	 */
	var concat = doParallel(concat$1);
	
	function doSeries(fn) {
	    return function (obj, iteratee, callback) {
	        return fn(eachOfSeries, obj, iteratee, callback);
	    };
	}
	
	/**
	 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
	 *
	 * @name concatSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.concat]{@link module:Collections.concat}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, results)` which must be called once
	 * it has completed with an error (which can be `null`) and an array of results.
	 * Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 */
	var concatSeries = doSeries(concat$1);
	
	/**
	 * Returns a function that when called, calls-back with the values provided.
	 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
	 * [`auto`]{@link module:ControlFlow.auto}.
	 *
	 * @name constant
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {...*} arguments... - Any number of arguments to automatically invoke
	 * callback with.
	 * @returns {Function} Returns a function that when invoked, automatically
	 * invokes the callback with the previous given arguments.
	 * @example
	 *
	 * async.waterfall([
	 *     async.constant(42),
	 *     function (value, next) {
	 *         // value === 42
	 *     },
	 *     //...
	 * ], callback);
	 *
	 * async.waterfall([
	 *     async.constant(filename, "utf8"),
	 *     fs.readFile,
	 *     function (fileData, next) {
	 *         //...
	 *     }
	 *     //...
	 * ], callback);
	 *
	 * async.auto({
	 *     hostname: async.constant("https://server.net/"),
	 *     port: findFreePort,
	 *     launchServer: ["hostname", "port", function (options, cb) {
	 *         startServer(options, cb);
	 *     }],
	 *     //...
	 * }, callback);
	 */
	var constant$2 = baseRest$1(function (values) {
	    var args = [null].concat(values);
	    return initialParams(function (ignoredArgs, callback) {
	        return callback.apply(this, args);
	    });
	});
	
	function _createTester(eachfn, check, getResult) {
	    return function (arr, limit, iteratee, cb) {
	        function done() {
	            if (cb) {
	                cb(null, getResult(false));
	            }
	        }
	        function wrappedIteratee(x, _, callback) {
	            if (!cb) return callback();
	            iteratee(x, function (err, v) {
	                // Check cb as another iteratee may have resolved with a
	                // value or error since we started this iteratee
	                if (cb && (err || check(v))) {
	                    if (err) cb(err);else cb(err, getResult(true, x));
	                    cb = iteratee = false;
	                    callback(err, breakLoop);
	                } else {
	                    callback();
	                }
	            });
	        }
	        if (arguments.length > 3) {
	            cb = cb || noop;
	            eachfn(arr, limit, wrappedIteratee, done);
	        } else {
	            cb = iteratee;
	            cb = cb || noop;
	            iteratee = limit;
	            eachfn(arr, wrappedIteratee, done);
	        }
	    };
	}
	
	function _findGetResult(v, x) {
	    return x;
	}
	
	/**
	 * Returns the first value in `coll` that passes an async truth test. The
	 * `iteratee` is applied in parallel, meaning the first iteratee to return
	 * `true` will fire the detect `callback` with that result. That means the
	 * result might not be the first item in the original `coll` (in terms of order)
	 * that passes the test.
	
	 * If order within the original `coll` is important, then look at
	 * [`detectSeries`]{@link module:Collections.detectSeries}.
	 *
	 * @name detect
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias find
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.detect(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // result now equals the first file in the list that exists
	 * });
	 */
	var detect = _createTester(eachOf, identity, _findGetResult);
	
	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name detectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findLimit
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	var detectLimit = _createTester(eachOfLimit, identity, _findGetResult);
	
	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
	 *
	 * @name detectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findSeries
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, truthValue)` which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	var detectSeries = _createTester(eachOfSeries, identity, _findGetResult);
	
	function consoleFunc(name) {
	    return baseRest$1(function (fn, args) {
	        fn.apply(null, args.concat([baseRest$1(function (err, args) {
	            if (typeof console === 'object') {
	                if (err) {
	                    if (console.error) {
	                        console.error(err);
	                    }
	                } else if (console[name]) {
	                    arrayEach(args, function (x) {
	                        console[name](x);
	                    });
	                }
	            }
	        })]));
	    });
	}
	
	/**
	 * Logs the result of an `async` function to the `console` using `console.dir`
	 * to display the properties of the resulting object. Only works in Node.js or
	 * in browsers that support `console.dir` and `console.error` (such as FF and
	 * Chrome). If multiple arguments are returned from the async function,
	 * `console.dir` is called on each argument in order.
	 *
	 * @name dir
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, {hello: name});
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.dir(hello, 'world');
	 * {hello: 'world'}
	 */
	var dir = consoleFunc('dir');
	
	/**
	 * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in
	 * the order of operations, the arguments `test` and `fn` are switched.
	 *
	 * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.
	 * @name doDuring
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.during]{@link module:ControlFlow.during}
	 * @category Control Flow
	 * @param {Function} fn - A function which is called each time `test` passes.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} test - asynchronous truth test to perform before each
	 * execution of `fn`. Invoked with (...args, callback), where `...args` are the
	 * non-error args from the previous callback of `fn`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error if one occured, otherwise `null`.
	 */
	function doDuring(fn, test, callback) {
	    callback = onlyOnce(callback || noop);
	
	    var next = baseRest$1(function (err, args) {
	        if (err) return callback(err);
	        args.push(check);
	        test.apply(this, args);
	    });
	
	    function check(err, truth) {
	        if (err) return callback(err);
	        if (!truth) return callback(null);
	        fn(next);
	    }
	
	    check(null, true);
	}
	
	/**
	 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
	 * the order of operations, the arguments `test` and `iteratee` are switched.
	 *
	 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
	 *
	 * @name doWhilst
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {Function} iteratee - A function which is called each time `test`
	 * passes. The function is passed a `callback(err)`, which must be called once
	 * it has completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} test - synchronous truth test to perform after each
	 * execution of `iteratee`. Invoked with the non-error callback results of 
	 * `iteratee`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `iteratee` has stopped.
	 * `callback` will be passed an error and any arguments passed to the final
	 * `iteratee`'s callback. Invoked with (err, [results]);
	 */
	function doWhilst(iteratee, test, callback) {
	    callback = onlyOnce(callback || noop);
	    var next = baseRest$1(function (err, args) {
	        if (err) return callback(err);
	        if (test.apply(this, args)) return iteratee(next);
	        callback.apply(null, [null].concat(args));
	    });
	    iteratee(next);
	}
	
	/**
	 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
	 * argument ordering differs from `until`.
	 *
	 * @name doUntil
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
	 * @category Control Flow
	 * @param {Function} fn - A function which is called each time `test` fails.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} test - synchronous truth test to perform after each
	 * execution of `fn`. Invoked with the non-error callback results of `fn`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has passed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `fn`'s
	 * callback. Invoked with (err, [results]);
	 */
	function doUntil(fn, test, callback) {
	    doWhilst(fn, function () {
	        return !test.apply(this, arguments);
	    }, callback);
	}
	
	/**
	 * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that
	 * is passed a callback in the form of `function (err, truth)`. If error is
	 * passed to `test` or `fn`, the main callback is immediately called with the
	 * value of the error.
	 *
	 * @name during
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {Function} test - asynchronous truth test to perform before each
	 * execution of `fn`. Invoked with (callback).
	 * @param {Function} fn - A function which is called each time `test` passes.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error, if one occured, otherwise `null`.
	 * @example
	 *
	 * var count = 0;
	 *
	 * async.during(
	 *     function (callback) {
	 *         return callback(null, count < 5);
	 *     },
	 *     function (callback) {
	 *         count++;
	 *         setTimeout(callback, 1000);
	 *     },
	 *     function (err) {
	 *         // 5 seconds have passed
	 *     }
	 * );
	 */
	function during(test, fn, callback) {
	    callback = onlyOnce(callback || noop);
	
	    function next(err) {
	        if (err) return callback(err);
	        test(check);
	    }
	
	    function check(err, truth) {
	        if (err) return callback(err);
	        if (!truth) return callback(null);
	        fn(next);
	    }
	
	    test(check);
	}
	
	function _withoutIndex(iteratee) {
	    return function (value, index, callback) {
	        return iteratee(value, callback);
	    };
	}
	
	/**
	 * Applies the function `iteratee` to each item in `coll`, in parallel.
	 * The `iteratee` is called with an item from the list, and a callback for when
	 * it has finished. If the `iteratee` passes an error to its `callback`, the
	 * main `callback` (for the `each` function) is immediately called with the
	 * error.
	 *
	 * Note, that since this function applies `iteratee` to each item in parallel,
	 * there is no guarantee that the iteratee functions will complete in order.
	 *
	 * @name each
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEach
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item
	 * in `coll`. The iteratee is passed a `callback(err)` which must be called once
	 * it has completed. If no error has occurred, the `callback` should be run
	 * without arguments or with an explicit `null` argument. The array index is not
	 * passed to the iteratee. Invoked with (item, callback). If you need the index,
	 * use `eachOf`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * // assuming openFiles is an array of file names and saveFile is a function
	 * // to save the modified contents of that file:
	 *
	 * async.each(openFiles, saveFile, function(err){
	 *   // if any of the saves produced an error, err would equal that error
	 * });
	 *
	 * // assuming openFiles is an array of file names
	 * async.each(openFiles, function(file, callback) {
	 *
	 *     // Perform operation on file here.
	 *     console.log('Processing file ' + file);
	 *
	 *     if( file.length > 32 ) {
	 *       console.log('This file name is too long');
	 *       callback('File name too long');
	 *     } else {
	 *       // Do work to process file here
	 *       console.log('File processed');
	 *       callback();
	 *     }
	 * }, function(err) {
	 *     // if any of the file processing produced an error, err would equal that error
	 *     if( err ) {
	 *       // One of the iterations produced an error.
	 *       // All processing will now stop.
	 *       console.log('A file failed to process');
	 *     } else {
	 *       console.log('All files have been processed successfully');
	 *     }
	 * });
	 */
	function eachLimit(coll, iteratee, callback) {
	  eachOf(coll, _withoutIndex(iteratee), callback);
	}
	
	/**
	 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name eachLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.each]{@link module:Collections.each}
	 * @alias forEachLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each item in `coll`. The
	 * iteratee is passed a `callback(err)` which must be called once it has
	 * completed. If no error has occurred, the `callback` should be run without
	 * arguments or with an explicit `null` argument. The array index is not passed
	 * to the iteratee. Invoked with (item, callback). If you need the index, use
	 * `eachOfLimit`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachLimit$1(coll, limit, iteratee, callback) {
	  _eachOfLimit(limit)(coll, _withoutIndex(iteratee), callback);
	}
	
	/**
	 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
	 *
	 * @name eachSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.each]{@link module:Collections.each}
	 * @alias forEachSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The iteratee is passed a `callback(err)` which must be called
	 * once it has completed. If no error has occurred, the `callback` should be run
	 * without arguments or with an explicit `null` argument. The array index is
	 * not passed to the iteratee. Invoked with (item, callback). If you need the
	 * index, use `eachOfSeries`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	var eachSeries = doLimit(eachLimit$1, 1);
	
	/**
	 * Wrap an async function and ensure it calls its callback on a later tick of
	 * the event loop.  If the function already calls its callback on a next tick,
	 * no extra deferral is added. This is useful for preventing stack overflows
	 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
	 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
	 * contained.
	 *
	 * @name ensureAsync
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} fn - an async function, one that expects a node-style
	 * callback as its last argument.
	 * @returns {Function} Returns a wrapped function with the exact same call
	 * signature as the function passed in.
	 * @example
	 *
	 * function sometimesAsync(arg, callback) {
	 *     if (cache[arg]) {
	 *         return callback(null, cache[arg]); // this would be synchronous!!
	 *     } else {
	 *         doSomeIO(arg, callback); // this IO would be asynchronous
	 *     }
	 * }
	 *
	 * // this has a risk of stack overflows if many results are cached in a row
	 * async.mapSeries(args, sometimesAsync, done);
	 *
	 * // this will defer sometimesAsync's callback if necessary,
	 * // preventing stack overflows
	 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
	 */
	function ensureAsync(fn) {
	    return initialParams(function (args, callback) {
	        var sync = true;
	        args.push(function () {
	            var innerArgs = arguments;
	            if (sync) {
	                setImmediate$1(function () {
	                    callback.apply(null, innerArgs);
	                });
	            } else {
	                callback.apply(null, innerArgs);
	            }
	        });
	        fn.apply(this, args);
	        sync = false;
	    });
	}
	
	function notId(v) {
	    return !v;
	}
	
	/**
	 * Returns `true` if every element in `coll` satisfies an async test. If any
	 * iteratee call returns `false`, the main `callback` is immediately called.
	 *
	 * @name every
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias all
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 * @example
	 *
	 * async.every(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then every file exists
	 * });
	 */
	var every = _createTester(eachOf, notId, notId);
	
	/**
	 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name everyLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	var everyLimit = _createTester(eachOfLimit, notId, notId);
	
	/**
	 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
	 *
	 * @name everySeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the
	 * collection in parallel. The iteratee is passed a `callback(err, truthValue)`
	 * which must be called with a  boolean argument once it has completed. Invoked
	 * with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	var everySeries = doLimit(everyLimit, 1);
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	function _filter(eachfn, arr, iteratee, callback) {
	    callback = once(callback || noop);
	    var results = [];
	    eachfn(arr, function (x, index, callback) {
	        iteratee(x, function (err, v) {
	            if (err) {
	                callback(err);
	            } else {
	                if (v) {
	                    results.push({ index: index, value: x });
	                }
	                callback();
	            }
	        });
	    }, function (err) {
	        if (err) {
	            callback(err);
	        } else {
	            callback(null, arrayMap(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), baseProperty('value')));
	        }
	    });
	}
	
	/**
	 * Returns a new array of all the values in `coll` which pass an async truth
	 * test. This operation is performed in parallel, but the results array will be
	 * in the same order as the original.
	 *
	 * @name filter
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias select
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.filter(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of the existing files
	 * });
	 */
	var filter = doParallel(_filter);
	
	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name filterLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var filterLimit = doParallelLimit(_filter);
	
	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
	 *
	 * @name filterSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results)
	 */
	var filterSeries = doLimit(filterLimit, 1);
	
	/**
	 * Calls the asynchronous function `fn` with a callback parameter that allows it
	 * to call itself again, in series, indefinitely.
	
	 * If an error is passed to the
	 * callback then `errback` is called with the error, and execution stops,
	 * otherwise it will never be called.
	 *
	 * @name forever
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} fn - a function to call repeatedly. Invoked with (next).
	 * @param {Function} [errback] - when `fn` passes an error to it's callback,
	 * this function will be called, and execution stops. Invoked with (err).
	 * @example
	 *
	 * async.forever(
	 *     function(next) {
	 *         // next is suitable for passing to things that need a callback(err [, whatever]);
	 *         // it will result in this function being called again.
	 *     },
	 *     function(err) {
	 *         // if next is called with a value in its first parameter, it will appear
	 *         // in here as 'err', and execution will stop.
	 *     }
	 * );
	 */
	function forever(fn, errback) {
	    var done = onlyOnce(errback || noop);
	    var task = ensureAsync(fn);
	
	    function next(err) {
	        if (err) return done(err);
	        task(next);
	    }
	    next();
	}
	
	/**
	 * Logs the result of an `async` function to the `console`. Only works in
	 * Node.js or in browsers that support `console.log` and `console.error` (such
	 * as FF and Chrome). If multiple arguments are returned from the async
	 * function, `console.log` is called on each argument in order.
	 *
	 * @name log
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} function - The function you want to eventually apply all
	 * arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, 'hello ' + name);
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.log(hello, 'world');
	 * 'hello world'
	 */
	var log = consoleFunc('log');
	
	/**
	 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name mapValuesLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.mapValues]{@link module:Collections.mapValues}
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each value in `obj`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 */
	function mapValuesLimit(obj, limit, iteratee, callback) {
	    callback = once(callback || noop);
	    var newObj = {};
	    eachOfLimit(obj, limit, function (val, key, next) {
	        iteratee(val, key, function (err, result) {
	            if (err) return next(err);
	            newObj[key] = result;
	            next();
	        });
	    }, function (err) {
	        callback(err, newObj);
	    });
	}
	
	/**
	 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
	 *
	 * Produces a new Object by mapping each value of `obj` through the `iteratee`
	 * function. The `iteratee` is called each `value` and `key` from `obj` and a
	 * callback for when it has finished processing. Each of these callbacks takes
	 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
	 * passes an error to its callback, the main `callback` (for the `mapValues`
	 * function) is immediately called with the error.
	 *
	 * Note, the order of the keys in the result is not guaranteed.  The keys will
	 * be roughly in the order they complete, (but this is very engine-specific)
	 *
	 * @name mapValues
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each value and key in
	 * `coll`. The iteratee is passed a `callback(err, transformed)` which must be
	 * called once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 * @example
	 *
	 * async.mapValues({
	 *     f1: 'file1',
	 *     f2: 'file2',
	 *     f3: 'file3'
	 * }, function (file, key, callback) {
	 *   fs.stat(file, callback);
	 * }, function(err, result) {
	 *     // result is now a map of stats for each file, e.g.
	 *     // {
	 *     //     f1: [stats for file1],
	 *     //     f2: [stats for file2],
	 *     //     f3: [stats for file3]
	 *     // }
	 * });
	 */
	
	var mapValues = doLimit(mapValuesLimit, Infinity);
	
	/**
	 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
	 *
	 * @name mapValuesSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.mapValues]{@link module:Collections.mapValues}
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each value in `obj`.
	 * The iteratee is passed a `callback(err, transformed)` which must be called
	 * once it has completed with an error (which can be `null`) and a
	 * transformed value. Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 */
	var mapValuesSeries = doLimit(mapValuesLimit, 1);
	
	function has(obj, key) {
	    return key in obj;
	}
	
	/**
	 * Caches the results of an `async` function. When creating a hash to store
	 * function results against, the callback is omitted from the hash and an
	 * optional hash function can be used.
	 *
	 * If no hash function is specified, the first argument is used as a hash key,
	 * which may work reasonably if it is a string or a data type that converts to a
	 * distinct string. Note that objects and arrays will not behave reasonably.
	 * Neither will cases where the other arguments are significant. In such cases,
	 * specify your own hash function.
	 *
	 * The cache of results is exposed as the `memo` property of the function
	 * returned by `memoize`.
	 *
	 * @name memoize
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} fn - The function to proxy and cache results from.
	 * @param {Function} hasher - An optional function for generating a custom hash
	 * for storing results. It has all the arguments applied to it apart from the
	 * callback, and must be synchronous.
	 * @returns {Function} a memoized version of `fn`
	 * @example
	 *
	 * var slow_fn = function(name, callback) {
	 *     // do something
	 *     callback(null, result);
	 * };
	 * var fn = async.memoize(slow_fn);
	 *
	 * // fn can now be used as if it were slow_fn
	 * fn('some name', function() {
	 *     // callback
	 * });
	 */
	function memoize(fn, hasher) {
	    var memo = Object.create(null);
	    var queues = Object.create(null);
	    hasher = hasher || identity;
	    var memoized = initialParams(function memoized(args, callback) {
	        var key = hasher.apply(null, args);
	        if (has(memo, key)) {
	            setImmediate$1(function () {
	                callback.apply(null, memo[key]);
	            });
	        } else if (has(queues, key)) {
	            queues[key].push(callback);
	        } else {
	            queues[key] = [callback];
	            fn.apply(null, args.concat([baseRest$1(function (args) {
	                memo[key] = args;
	                var q = queues[key];
	                delete queues[key];
	                for (var i = 0, l = q.length; i < l; i++) {
	                    q[i].apply(null, args);
	                }
	            })]));
	        }
	    });
	    memoized.memo = memo;
	    memoized.unmemoized = fn;
	    return memoized;
	}
	
	/**
	 * Calls `callback` on a later loop around the event loop. In Node.js this just
	 * calls `setImmediate`.  In the browser it will use `setImmediate` if
	 * available, otherwise `setTimeout(callback, 0)`, which means other higher
	 * priority events may precede the execution of `callback`.
	 *
	 * This is used internally for browser-compatibility purposes.
	 *
	 * @name nextTick
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @alias setImmediate
	 * @category Util
	 * @param {Function} callback - The function to call on a later loop around
	 * the event loop. Invoked with (args...).
	 * @param {...*} args... - any number of additional arguments to pass to the
	 * callback on the next tick.
	 * @example
	 *
	 * var call_order = [];
	 * async.nextTick(function() {
	 *     call_order.push('two');
	 *     // call_order now equals ['one','two']
	 * });
	 * call_order.push('one');
	 *
	 * async.setImmediate(function (a, b, c) {
	 *     // a, b, and c equal 1, 2, and 3
	 * }, 1, 2, 3);
	 */
	var _defer$1;
	
	if (hasNextTick) {
	    _defer$1 = process.nextTick;
	} else if (hasSetImmediate) {
	    _defer$1 = setImmediate;
	} else {
	    _defer$1 = fallback;
	}
	
	var nextTick = wrap(_defer$1);
	
	function _parallel(eachfn, tasks, callback) {
	    callback = callback || noop;
	    var results = isArrayLike(tasks) ? [] : {};
	
	    eachfn(tasks, function (task, key, callback) {
	        task(baseRest$1(function (err, args) {
	            if (args.length <= 1) {
	                args = args[0];
	            }
	            results[key] = args;
	            callback(err);
	        }));
	    }, function (err) {
	        callback(err, results);
	    });
	}
	
	/**
	 * Run the `tasks` collection of functions in parallel, without waiting until
	 * the previous function has completed. If any of the functions pass an error to
	 * its callback, the main `callback` is immediately called with the value of the
	 * error. Once the `tasks` have completed, the results are passed to the final
	 * `callback` as an array.
	 *
	 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
	 * parallel execution of code.  If your tasks do not use any timers or perform
	 * any I/O, they will actually be executed in series.  Any synchronous setup
	 * sections for each task will happen one after the other.  JavaScript remains
	 * single-threaded.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 * results from {@link async.parallel}.
	 *
	 * @name parallel
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
	 * Each function is passed a `callback(err, result)` which it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 * @example
	 * async.parallel([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // the results array will equal ['one','two'] even though
	 *     // the second function had a shorter timeout.
	 * });
	 *
	 * // an example using an object instead of an array
	 * async.parallel({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equals to: {one: 1, two: 2}
	 * });
	 */
	function parallelLimit(tasks, callback) {
	  _parallel(eachOf, tasks, callback);
	}
	
	/**
	 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name parallelLimit
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.parallel]{@link module:ControlFlow.parallel}
	 * @category Control Flow
	 * @param {Array|Collection} tasks - A collection containing functions to run.
	 * Each function is passed a `callback(err, result)` which it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 */
	function parallelLimit$1(tasks, limit, callback) {
	  _parallel(_eachOfLimit(limit), tasks, callback);
	}
	
	/**
	 * A queue of tasks for the worker function to complete.
	 * @typedef {Object} QueueObject
	 * @memberOf module:ControlFlow
	 * @property {Function} length - a function returning the number of items
	 * waiting to be processed. Invoke with `queue.length()`.
	 * @property {boolean} started - a boolean indicating whether or not any
	 * items have been pushed and processed by the queue.
	 * @property {Function} running - a function returning the number of items
	 * currently being processed. Invoke with `queue.running()`.
	 * @property {Function} workersList - a function returning the array of items
	 * currently being processed. Invoke with `queue.workersList()`.
	 * @property {Function} idle - a function returning false if there are items
	 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
	 * @property {number} concurrency - an integer for determining how many `worker`
	 * functions should be run in parallel. This property can be changed after a
	 * `queue` is created to alter the concurrency on-the-fly.
	 * @property {Function} push - add a new task to the `queue`. Calls `callback`
	 * once the `worker` has finished processing the task. Instead of a single task,
	 * a `tasks` array can be submitted. The respective callback is used for every
	 * task in the list. Invoke with `queue.push(task, [callback])`,
	 * @property {Function} unshift - add a new task to the front of the `queue`.
	 * Invoke with `queue.unshift(task, [callback])`.
	 * @property {Function} saturated - a callback that is called when the number of
	 * running workers hits the `concurrency` limit, and further tasks will be
	 * queued.
	 * @property {Function} unsaturated - a callback that is called when the number
	 * of running workers is less than the `concurrency` & `buffer` limits, and
	 * further tasks will not be queued.
	 * @property {number} buffer - A minimum threshold buffer in order to say that
	 * the `queue` is `unsaturated`.
	 * @property {Function} empty - a callback that is called when the last item
	 * from the `queue` is given to a `worker`.
	 * @property {Function} drain - a callback that is called when the last item
	 * from the `queue` has returned from the `worker`.
	 * @property {Function} error - a callback that is called when a task errors.
	 * Has the signature `function(error, task)`.
	 * @property {boolean} paused - a boolean for determining whether the queue is
	 * in a paused state.
	 * @property {Function} pause - a function that pauses the processing of tasks
	 * until `resume()` is called. Invoke with `queue.pause()`.
	 * @property {Function} resume - a function that resumes the processing of
	 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
	 * @property {Function} kill - a function that removes the `drain` callback and
	 * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.
	 */
	
	/**
	 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
	 * `queue` are processed in parallel (up to the `concurrency` limit). If all
	 * `worker`s are in progress, the task is queued until one becomes available.
	 * Once a `worker` completes a `task`, that `task`'s callback is called.
	 *
	 * @name queue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing a queued
	 * task, which must call its `callback(err)` argument when finished, with an
	 * optional `error` as an argument.  If you want to handle errors from an
	 * individual task, pass a callback to `q.push()`. Invoked with
	 * (task, callback).
	 * @param {number} [concurrency=1] - An `integer` for determining how many
	 * `worker` functions should be run in parallel.  If omitted, the concurrency
	 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
	 * attached as certain properties to listen for specific events during the
	 * lifecycle of the queue.
	 * @example
	 *
	 * // create a queue object with concurrency 2
	 * var q = async.queue(function(task, callback) {
	 *     console.log('hello ' + task.name);
	 *     callback();
	 * }, 2);
	 *
	 * // assign a callback
	 * q.drain = function() {
	 *     console.log('all items have been processed');
	 * };
	 *
	 * // add some items to the queue
	 * q.push({name: 'foo'}, function(err) {
	 *     console.log('finished processing foo');
	 * });
	 * q.push({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 *
	 * // add some items to the queue (batch-wise)
	 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
	 *     console.log('finished processing item');
	 * });
	 *
	 * // add some items to the front of the queue
	 * q.unshift({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 */
	var queue$1 = function (worker, concurrency) {
	  return queue(function (items, cb) {
	    worker(items[0], cb);
	  }, concurrency, 1);
	};
	
	/**
	 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
	 * completed in ascending priority order.
	 *
	 * @name priorityQueue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.queue]{@link module:ControlFlow.queue}
	 * @category Control Flow
	 * @param {Function} worker - An asynchronous function for processing a queued
	 * task, which must call its `callback(err)` argument when finished, with an
	 * optional `error` as an argument.  If you want to handle errors from an
	 * individual task, pass a callback to `q.push()`. Invoked with
	 * (task, callback).
	 * @param {number} concurrency - An `integer` for determining how many `worker`
	 * functions should be run in parallel.  If omitted, the concurrency defaults to
	 * `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
	 * differences between `queue` and `priorityQueue` objects:
	 * * `push(task, priority, [callback])` - `priority` should be a number. If an
	 *   array of `tasks` is given, all tasks will be assigned the same priority.
	 * * The `unshift` method was removed.
	 */
	var priorityQueue = function (worker, concurrency) {
	    // Start with a normal queue
	    var q = queue$1(worker, concurrency);
	
	    // Override push to accept second parameter representing priority
	    q.push = function (data, priority, callback) {
	        if (callback == null) callback = noop;
	        if (typeof callback !== 'function') {
	            throw new Error('task callback must be a function');
	        }
	        q.started = true;
	        if (!isArray(data)) {
	            data = [data];
	        }
	        if (data.length === 0) {
	            // call drain immediately if there are no tasks
	            return setImmediate$1(function () {
	                q.drain();
	            });
	        }
	
	        priority = priority || 0;
	        var nextNode = q._tasks.head;
	        while (nextNode && priority >= nextNode.priority) {
	            nextNode = nextNode.next;
	        }
	
	        for (var i = 0, l = data.length; i < l; i++) {
	            var item = {
	                data: data[i],
	                priority: priority,
	                callback: callback
	            };
	
	            if (nextNode) {
	                q._tasks.insertBefore(nextNode, item);
	            } else {
	                q._tasks.push(item);
	            }
	        }
	        setImmediate$1(q.process);
	    };
	
	    // Remove unshift function
	    delete q.unshift;
	
	    return q;
	};
	
	/**
	 * Runs the `tasks` array of functions in parallel, without waiting until the
	 * previous function has completed. Once any of the `tasks` complete or pass an
	 * error to its callback, the main `callback` is immediately called. It's
	 * equivalent to `Promise.race()`.
	 *
	 * @name race
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array} tasks - An array containing functions to run. Each function
	 * is passed a `callback(err, result)` which it must call on completion with an
	 * error `err` (which can be `null`) and an optional `result` value.
	 * @param {Function} callback - A callback to run once any of the functions have
	 * completed. This function gets an error or result from the first function that
	 * completed. Invoked with (err, result).
	 * @returns undefined
	 * @example
	 *
	 * async.race([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // main callback
	 * function(err, result) {
	 *     // the result will be equal to 'two' as it finishes earlier
	 * });
	 */
	function race(tasks, callback) {
	    callback = once(callback || noop);
	    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
	    if (!tasks.length) return callback();
	    for (var i = 0, l = tasks.length; i < l; i++) {
	        tasks[i](callback);
	    }
	}
	
	var slice = Array.prototype.slice;
	
	/**
	 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
	 *
	 * @name reduceRight
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reduce]{@link module:Collections.reduce}
	 * @alias foldr
	 * @category Collection
	 * @param {Array} array - A collection to iterate over.
	 * @param {*} memo - The initial state of the reduction.
	 * @param {Function} iteratee - A function applied to each item in the
	 * array to produce the next step in the reduction. The `iteratee` is passed a
	 * `callback(err, reduction)` which accepts an optional error as its first
	 * argument, and the state of the reduction as the second. If an error is
	 * passed to the callback, the reduction is stopped and the main `callback` is
	 * immediately called with the error. Invoked with (memo, item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the reduced value. Invoked with
	 * (err, result).
	 */
	function reduceRight(array, memo, iteratee, callback) {
	  var reversed = slice.call(array).reverse();
	  reduce(reversed, memo, iteratee, callback);
	}
	
	/**
	 * Wraps the function in another function that always returns data even when it
	 * errors.
	 *
	 * The object returned has either the property `error` or `value`.
	 *
	 * @name reflect
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} fn - The function you want to wrap
	 * @returns {Function} - A function that always passes null to it's callback as
	 * the error. The second argument to the callback will be an `object` with
	 * either an `error` or a `value` property.
	 * @example
	 *
	 * async.parallel([
	 *     async.reflect(function(callback) {
	 *         // do some stuff ...
	 *         callback(null, 'one');
	 *     }),
	 *     async.reflect(function(callback) {
	 *         // do some more stuff but error ...
	 *         callback('bad stuff happened');
	 *     }),
	 *     async.reflect(function(callback) {
	 *         // do some more stuff ...
	 *         callback(null, 'two');
	 *     })
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results[0].value = 'one'
	 *     // results[1].error = 'bad stuff happened'
	 *     // results[2].value = 'two'
	 * });
	 */
	function reflect(fn) {
	    return initialParams(function reflectOn(args, reflectCallback) {
	        args.push(baseRest$1(function callback(err, cbArgs) {
	            if (err) {
	                reflectCallback(null, {
	                    error: err
	                });
	            } else {
	                var value = null;
	                if (cbArgs.length === 1) {
	                    value = cbArgs[0];
	                } else if (cbArgs.length > 1) {
	                    value = cbArgs;
	                }
	                reflectCallback(null, {
	                    value: value
	                });
	            }
	        }));
	
	        return fn.apply(this, args);
	    });
	}
	
	function reject$1(eachfn, arr, iteratee, callback) {
	    _filter(eachfn, arr, function (value, cb) {
	        iteratee(value, function (err, v) {
	            if (err) {
	                cb(err);
	            } else {
	                cb(null, !v);
	            }
	        });
	    }, callback);
	}
	
	/**
	 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
	 *
	 * @name reject
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.reject(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of missing files
	 *     createFiles(results);
	 * });
	 */
	var reject = doParallel(reject$1);
	
	/**
	 * A helper function that wraps an array or an object of functions with reflect.
	 *
	 * @name reflectAll
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.reflect]{@link module:Utils.reflect}
	 * @category Util
	 * @param {Array} tasks - The array of functions to wrap in `async.reflect`.
	 * @returns {Array} Returns an array of functions, each function wrapped in
	 * `async.reflect`
	 * @example
	 *
	 * let tasks = [
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         // do some more stuff but error ...
	 *         callback(new Error('bad stuff happened'));
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ];
	 *
	 * async.parallel(async.reflectAll(tasks),
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results[0].value = 'one'
	 *     // results[1].error = Error('bad stuff happened')
	 *     // results[2].value = 'two'
	 * });
	 *
	 * // an example using an object instead of an array
	 * let tasks = {
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         callback('two');
	 *     },
	 *     three: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'three');
	 *         }, 100);
	 *     }
	 * };
	 *
	 * async.parallel(async.reflectAll(tasks),
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results.one.value = 'one'
	 *     // results.two.error = 'two'
	 *     // results.three.value = 'three'
	 * });
	 */
	function reflectAll(tasks) {
	    var results;
	    if (isArray(tasks)) {
	        results = arrayMap(tasks, reflect);
	    } else {
	        results = {};
	        baseForOwn(tasks, function (task, key) {
	            results[key] = reflect.call(this, task);
	        });
	    }
	    return results;
	}
	
	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name rejectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var rejectLimit = doParallelLimit(reject$1);
	
	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
	 *
	 * @name rejectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var rejectSeries = doLimit(rejectLimit, 1);
	
	/**
	 * Attempts to get a successful response from `task` no more than `times` times
	 * before returning an error. If the task is successful, the `callback` will be
	 * passed the result of the successful task. If all attempts fail, the callback
	 * will be passed the error and result (if any) of the final attempt.
	 *
	 * @name retry
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
	 * object with `times` and `interval` or a number.
	 * * `times` - The number of attempts to make before giving up.  The default
	 *   is `5`.
	 * * `interval` - The time to wait between retries, in milliseconds.  The
	 *   default is `0`. The interval may also be specified as a function of the
	 *   retry count (see example).
	 * * `errorFilter` - An optional synchronous function that is invoked on
	 *   erroneous result. If it returns `true` the retry attempts will continue;
	 *   if the function returns `false` the retry flow is aborted with the current
	 *   attempt's error and result being returned to the final callback.
	 *   Invoked with (err).
	 * * If `opts` is a number, the number specifies the number of times to retry,
	 *   with the default interval of `0`.
	 * @param {Function} task - A function which receives two arguments: (1) a
	 * `callback(err, result)` which must be called when finished, passing `err`
	 * (which can be `null`) and the `result` of the function's execution, and (2)
	 * a `results` object, containing the results of the previously executed
	 * functions (if nested inside another control flow). Invoked with
	 * (callback, results).
	 * @param {Function} [callback] - An optional callback which is called when the
	 * task has succeeded, or after the final failed attempt. It receives the `err`
	 * and `result` arguments of the last attempt at completing the `task`. Invoked
	 * with (err, results).
	 * @example
	 *
	 * // The `retry` function can be used as a stand-alone control flow by passing
	 * // a callback, as shown below:
	 *
	 * // try calling apiMethod 3 times
	 * async.retry(3, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod 3 times, waiting 200 ms between each retry
	 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod 10 times with exponential backoff
	 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
	 * async.retry({
	 *   times: 10,
	 *   interval: function(retryCount) {
	 *     return 50 * Math.pow(2, retryCount);
	 *   }
	 * }, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod the default 5 times no delay between each retry
	 * async.retry(apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod only when error condition satisfies, all other
	 * // errors will abort the retry control flow and return to final callback
	 * async.retry({
	 *   errorFilter: function(err) {
	 *     return err.message === 'Temporary error'; // only retry on a specific error
	 *   }
	 * }, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // It can also be embedded within other control flow functions to retry
	 * // individual methods that are not as reliable, like this:
	 * async.auto({
	 *     users: api.getUsers.bind(api),
	 *     payments: async.retry(3, api.getPayments.bind(api))
	 * }, function(err, results) {
	 *     // do something with the results
	 * });
	 *
	 */
	function retry(opts, task, callback) {
	    var DEFAULT_TIMES = 5;
	    var DEFAULT_INTERVAL = 0;
	
	    var options = {
	        times: DEFAULT_TIMES,
	        intervalFunc: constant(DEFAULT_INTERVAL)
	    };
	
	    function parseTimes(acc, t) {
	        if (typeof t === 'object') {
	            acc.times = +t.times || DEFAULT_TIMES;
	
	            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
	
	            acc.errorFilter = t.errorFilter;
	        } else if (typeof t === 'number' || typeof t === 'string') {
	            acc.times = +t || DEFAULT_TIMES;
	        } else {
	            throw new Error("Invalid arguments for async.retry");
	        }
	    }
	
	    if (arguments.length < 3 && typeof opts === 'function') {
	        callback = task || noop;
	        task = opts;
	    } else {
	        parseTimes(options, opts);
	        callback = callback || noop;
	    }
	
	    if (typeof task !== 'function') {
	        throw new Error("Invalid arguments for async.retry");
	    }
	
	    var attempt = 1;
	    function retryAttempt() {
	        task(function (err) {
	            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
	                setTimeout(retryAttempt, options.intervalFunc(attempt));
	            } else {
	                callback.apply(null, arguments);
	            }
	        });
	    }
	
	    retryAttempt();
	}
	
	/**
	 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method wraps a task and makes it
	 * retryable, rather than immediately calling it with retries.
	 *
	 * @name retryable
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.retry]{@link module:ControlFlow.retry}
	 * @category Control Flow
	 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
	 * options, exactly the same as from `retry`
	 * @param {Function} task - the asynchronous function to wrap
	 * @returns {Functions} The wrapped function, which when invoked, will retry on
	 * an error, based on the parameters specified in `opts`.
	 * @example
	 *
	 * async.auto({
	 *     dep1: async.retryable(3, getFromFlakyService),
	 *     process: ["dep1", async.retryable(3, function (results, cb) {
	 *         maybeProcessData(results.dep1, cb);
	 *     })]
	 * }, callback);
	 */
	var retryable = function (opts, task) {
	    if (!task) {
	        task = opts;
	        opts = null;
	    }
	    return initialParams(function (args, callback) {
	        function taskFn(cb) {
	            task.apply(null, args.concat([cb]));
	        }
	
	        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);
	    });
	};
	
	/**
	 * Run the functions in the `tasks` collection in series, each one running once
	 * the previous function has completed. If any functions in the series pass an
	 * error to its callback, no more functions are run, and `callback` is
	 * immediately called with the value of the error. Otherwise, `callback`
	 * receives an array of results when `tasks` have completed.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function, and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 *  results from {@link async.series}.
	 *
	 * **Note** that while many implementations preserve the order of object
	 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
	 * explicitly states that
	 *
	 * > The mechanics and order of enumerating the properties is not specified.
	 *
	 * So if you rely on the order in which your series of functions are executed,
	 * and want this to work on all platforms, consider using an array.
	 *
	 * @name series
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing functions to run, each
	 * function is passed a `callback(err, result)` it must call on completion with
	 * an error `err` (which can be `null`) and an optional `result` value.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed. This function gets a results array (or object)
	 * containing all the result arguments passed to the `task` callbacks. Invoked
	 * with (err, result).
	 * @example
	 * async.series([
	 *     function(callback) {
	 *         // do some stuff ...
	 *         callback(null, 'one');
	 *     },
	 *     function(callback) {
	 *         // do some more stuff ...
	 *         callback(null, 'two');
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // results is now equal to ['one', 'two']
	 * });
	 *
	 * async.series({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback){
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equal to: {one: 1, two: 2}
	 * });
	 */
	function series(tasks, callback) {
	  _parallel(eachOfSeries, tasks, callback);
	}
	
	/**
	 * Returns `true` if at least one element in the `coll` satisfies an async test.
	 * If any iteratee call returns `true`, the main `callback` is immediately
	 * called.
	 *
	 * @name some
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias any
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 * @example
	 *
	 * async.some(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then at least one of the files exists
	 * });
	 */
	var some = _createTester(eachOf, Boolean, identity);
	
	/**
	 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name someLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anyLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	var someLimit = _createTester(eachOfLimit, Boolean, identity);
	
	/**
	 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
	 *
	 * @name someSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anySeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in the array
	 * in parallel. The iteratee is passed a `callback(err, truthValue)` which must
	 * be called with a boolean argument once it has completed. Invoked with
	 * (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	var someSeries = doLimit(someLimit, 1);
	
	/**
	 * Sorts a list by the results of running each `coll` value through an async
	 * `iteratee`.
	 *
	 * @name sortBy
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item in `coll`.
	 * The iteratee is passed a `callback(err, sortValue)` which must be called once
	 * it has completed with an error (which can be `null`) and a value to use as
	 * the sort criteria. Invoked with (item, callback).
	 * @param {Function} callback - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is the items
	 * from the original `coll` sorted by the values returned by the `iteratee`
	 * calls. Invoked with (err, results).
	 * @example
	 *
	 * async.sortBy(['file1','file2','file3'], function(file, callback) {
	 *     fs.stat(file, function(err, stats) {
	 *         callback(err, stats.mtime);
	 *     });
	 * }, function(err, results) {
	 *     // results is now the original array of files sorted by
	 *     // modified date
	 * });
	 *
	 * // By modifying the callback parameter the
	 * // sorting order can be influenced:
	 *
	 * // ascending order
	 * async.sortBy([1,9,3,5], function(x, callback) {
	 *     callback(null, x);
	 * }, function(err,result) {
	 *     // result callback
	 * });
	 *
	 * // descending order
	 * async.sortBy([1,9,3,5], function(x, callback) {
	 *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
	 * }, function(err,result) {
	 *     // result callback
	 * });
	 */
	function sortBy(coll, iteratee, callback) {
	    map(coll, function (x, callback) {
	        iteratee(x, function (err, criteria) {
	            if (err) return callback(err);
	            callback(null, { value: x, criteria: criteria });
	        });
	    }, function (err, results) {
	        if (err) return callback(err);
	        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
	    });
	
	    function comparator(left, right) {
	        var a = left.criteria,
	            b = right.criteria;
	        return a < b ? -1 : a > b ? 1 : 0;
	    }
	}
	
	/**
	 * Sets a time limit on an asynchronous function. If the function does not call
	 * its callback within the specified milliseconds, it will be called with a
	 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
	 *
	 * @name timeout
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} asyncFn - The asynchronous function you want to set the
	 * time limit.
	 * @param {number} milliseconds - The specified time limit.
	 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
	 * to timeout Error for more information..
	 * @returns {Function} Returns a wrapped function that can be used with any of
	 * the control flow functions. Invoke this function with the same
	 * parameters as you would `asyncFunc`.
	 * @example
	 *
	 * function myFunction(foo, callback) {
	 *     doAsyncTask(foo, function(err, data) {
	 *         // handle errors
	 *         if (err) return callback(err);
	 *
	 *         // do some stuff ...
	 *
	 *         // return processed data
	 *         return callback(null, data);
	 *     });
	 * }
	 *
	 * var wrapped = async.timeout(myFunction, 1000);
	 *
	 * // call `wrapped` as you would `myFunction`
	 * wrapped({ bar: 'bar' }, function(err, data) {
	 *     // if `myFunction` takes < 1000 ms to execute, `err`
	 *     // and `data` will have their expected values
	 *
	 *     // else `err` will be an Error with the code 'ETIMEDOUT'
	 * });
	 */
	function timeout(asyncFn, milliseconds, info) {
	    var originalCallback, timer;
	    var timedOut = false;
	
	    function injectedCallback() {
	        if (!timedOut) {
	            originalCallback.apply(null, arguments);
	            clearTimeout(timer);
	        }
	    }
	
	    function timeoutCallback() {
	        var name = asyncFn.name || 'anonymous';
	        var error = new Error('Callback function "' + name + '" timed out.');
	        error.code = 'ETIMEDOUT';
	        if (info) {
	            error.info = info;
	        }
	        timedOut = true;
	        originalCallback(error);
	    }
	
	    return initialParams(function (args, origCallback) {
	        originalCallback = origCallback;
	        // setup timer and call original function
	        timer = setTimeout(timeoutCallback, milliseconds);
	        asyncFn.apply(null, args.concat(injectedCallback));
	    });
	}
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil;
	var nativeMax$1 = Math.max;
	
	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);
	
	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}
	
	/**
	 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name timesLimit
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.times]{@link module:ControlFlow.times}
	 * @category Control Flow
	 * @param {number} count - The number of times to run the function.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
	 */
	function timeLimit(count, limit, iteratee, callback) {
	  mapLimit(baseRange(0, count, 1), limit, iteratee, callback);
	}
	
	/**
	 * Calls the `iteratee` function `n` times, and accumulates results in the same
	 * manner you would use with [map]{@link module:Collections.map}.
	 *
	 * @name times
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 * @example
	 *
	 * // Pretend this is some complicated async factory
	 * var createUser = function(id, callback) {
	 *     callback(null, {
	 *         id: 'user' + id
	 *     });
	 * };
	 *
	 * // generate 5 users
	 * async.times(5, function(n, next) {
	 *     createUser(n, function(err, user) {
	 *         next(err, user);
	 *     });
	 * }, function(err, users) {
	 *     // we should now have 5 users
	 * });
	 */
	var times = doLimit(timeLimit, Infinity);
	
	/**
	 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
	 *
	 * @name timesSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.times]{@link module:ControlFlow.times}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {Function} iteratee - The function to call `n` times. Invoked with the
	 * iteration index and a callback (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 */
	var timesSeries = doLimit(timeLimit, 1);
	
	/**
	 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
	 * element in series, each step potentially mutating an `accumulator` value.
	 * The type of the accumulator defaults to the type of collection passed in.
	 *
	 * @name transform
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
	 * it will default to an empty Object or Array, depending on the type of `coll`
	 * @param {Function} iteratee - A function applied to each item in the
	 * collection that potentially modifies the accumulator. The `iteratee` is
	 * passed a `callback(err)` which accepts an optional error as its first
	 * argument. If an error is passed to the callback, the transform is stopped
	 * and the main `callback` is immediately called with the error.
	 * Invoked with (accumulator, item, key, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the transformed accumulator.
	 * Invoked with (err, result).
	 * @example
	 *
	 * async.transform([1,2,3], function(acc, item, index, callback) {
	 *     // pointless async:
	 *     process.nextTick(function() {
	 *         acc.push(item * 2)
	 *         callback(null)
	 *     });
	 * }, function(err, result) {
	 *     // result is now equal to [2, 4, 6]
	 * });
	 *
	 * @example
	 *
	 * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
	 *     setImmediate(function () {
	 *         obj[key] = val * 2;
	 *         callback();
	 *     })
	 * }, function (err, result) {
	 *     // result is equal to {a: 2, b: 4, c: 6}
	 * })
	 */
	function transform(coll, accumulator, iteratee, callback) {
	    if (arguments.length === 3) {
	        callback = iteratee;
	        iteratee = accumulator;
	        accumulator = isArray(coll) ? [] : {};
	    }
	    callback = once(callback || noop);
	
	    eachOf(coll, function (v, k, cb) {
	        iteratee(accumulator, v, k, cb);
	    }, function (err) {
	        callback(err, accumulator);
	    });
	}
	
	/**
	 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
	 * unmemoized form. Handy for testing.
	 *
	 * @name unmemoize
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.memoize]{@link module:Utils.memoize}
	 * @category Util
	 * @param {Function} fn - the memoized function
	 * @returns {Function} a function that calls the original unmemoized function
	 */
	function unmemoize(fn) {
	    return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	    };
	}
	
	/**
	 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
	 * stopped, or an error occurs.
	 *
	 * @name whilst
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} test - synchronous truth test to perform before each
	 * execution of `iteratee`. Invoked with ().
	 * @param {Function} iteratee - A function which is called each time `test` passes.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `iteratee` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `iteratee`'s
	 * callback. Invoked with (err, [results]);
	 * @returns undefined
	 * @example
	 *
	 * var count = 0;
	 * async.whilst(
	 *     function() { return count < 5; },
	 *     function(callback) {
	 *         count++;
	 *         setTimeout(function() {
	 *             callback(null, count);
	 *         }, 1000);
	 *     },
	 *     function (err, n) {
	 *         // 5 seconds have passed, n = 5
	 *     }
	 * );
	 */
	function whilst(test, iteratee, callback) {
	    callback = onlyOnce(callback || noop);
	    if (!test()) return callback(null);
	    var next = baseRest$1(function (err, args) {
	        if (err) return callback(err);
	        if (test()) return iteratee(next);
	        callback.apply(null, [null].concat(args));
	    });
	    iteratee(next);
	}
	
	/**
	 * Repeatedly call `fn` until `test` returns `true`. Calls `callback` when
	 * stopped, or an error occurs. `callback` will be passed an error and any
	 * arguments passed to the final `fn`'s callback.
	 *
	 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
	 *
	 * @name until
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {Function} test - synchronous truth test to perform before each
	 * execution of `fn`. Invoked with ().
	 * @param {Function} fn - A function which is called each time `test` fails.
	 * The function is passed a `callback(err)`, which must be called once it has
	 * completed with an optional `err` argument. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has passed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `fn`'s
	 * callback. Invoked with (err, [results]);
	 */
	function until(test, fn, callback) {
	    whilst(function () {
	        return !test.apply(this, arguments);
	    }, fn, callback);
	}
	
	/**
	 * Runs the `tasks` array of functions in series, each passing their results to
	 * the next in the array. However, if any of the `tasks` pass an error to their
	 * own callback, the next function is not executed, and the main `callback` is
	 * immediately called with the error.
	 *
	 * @name waterfall
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array} tasks - An array of functions to run, each function is passed
	 * a `callback(err, result1, result2, ...)` it must call on completion. The
	 * first argument is an error (which can be `null`) and any further arguments
	 * will be passed as arguments in order to the next task.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed. This will be passed the results of the last task's
	 * callback. Invoked with (err, [results]).
	 * @returns undefined
	 * @example
	 *
	 * async.waterfall([
	 *     function(callback) {
	 *         callback(null, 'one', 'two');
	 *     },
	 *     function(arg1, arg2, callback) {
	 *         // arg1 now equals 'one' and arg2 now equals 'two'
	 *         callback(null, 'three');
	 *     },
	 *     function(arg1, callback) {
	 *         // arg1 now equals 'three'
	 *         callback(null, 'done');
	 *     }
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 *
	 * // Or, with named functions:
	 * async.waterfall([
	 *     myFirstFunction,
	 *     mySecondFunction,
	 *     myLastFunction,
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 * function myFirstFunction(callback) {
	 *     callback(null, 'one', 'two');
	 * }
	 * function mySecondFunction(arg1, arg2, callback) {
	 *     // arg1 now equals 'one' and arg2 now equals 'two'
	 *     callback(null, 'three');
	 * }
	 * function myLastFunction(arg1, callback) {
	 *     // arg1 now equals 'three'
	 *     callback(null, 'done');
	 * }
	 */
	var waterfall = function (tasks, callback) {
	    callback = once(callback || noop);
	    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
	    if (!tasks.length) return callback();
	    var taskIndex = 0;
	
	    function nextTask(args) {
	        if (taskIndex === tasks.length) {
	            return callback.apply(null, [null].concat(args));
	        }
	
	        var taskCallback = onlyOnce(baseRest$1(function (err, args) {
	            if (err) {
	                return callback.apply(null, [err].concat(args));
	            }
	            nextTask(args);
	        }));
	
	        args.push(taskCallback);
	
	        var task = tasks[taskIndex++];
	        task.apply(null, args);
	    }
	
	    nextTask([]);
	};
	
	/**
	 * Async is a utility module which provides straight-forward, powerful functions
	 * for working with asynchronous JavaScript. Although originally designed for
	 * use with [Node.js](http://nodejs.org) and installable via
	 * `npm install --save async`, it can also be used directly in the browser.
	 * @module async
	 */
	
	/**
	 * A collection of `async` functions for manipulating collections, such as
	 * arrays and objects.
	 * @module Collections
	 */
	
	/**
	 * A collection of `async` functions for controlling the flow through a script.
	 * @module ControlFlow
	 */
	
	/**
	 * A collection of `async` utility functions.
	 * @module Utils
	 */
	var index = {
	  applyEach: applyEach,
	  applyEachSeries: applyEachSeries,
	  apply: apply$2,
	  asyncify: asyncify,
	  auto: auto,
	  autoInject: autoInject,
	  cargo: cargo,
	  compose: compose,
	  concat: concat,
	  concatSeries: concatSeries,
	  constant: constant$2,
	  detect: detect,
	  detectLimit: detectLimit,
	  detectSeries: detectSeries,
	  dir: dir,
	  doDuring: doDuring,
	  doUntil: doUntil,
	  doWhilst: doWhilst,
	  during: during,
	  each: eachLimit,
	  eachLimit: eachLimit$1,
	  eachOf: eachOf,
	  eachOfLimit: eachOfLimit,
	  eachOfSeries: eachOfSeries,
	  eachSeries: eachSeries,
	  ensureAsync: ensureAsync,
	  every: every,
	  everyLimit: everyLimit,
	  everySeries: everySeries,
	  filter: filter,
	  filterLimit: filterLimit,
	  filterSeries: filterSeries,
	  forever: forever,
	  log: log,
	  map: map,
	  mapLimit: mapLimit,
	  mapSeries: mapSeries,
	  mapValues: mapValues,
	  mapValuesLimit: mapValuesLimit,
	  mapValuesSeries: mapValuesSeries,
	  memoize: memoize,
	  nextTick: nextTick,
	  parallel: parallelLimit,
	  parallelLimit: parallelLimit$1,
	  priorityQueue: priorityQueue,
	  queue: queue$1,
	  race: race,
	  reduce: reduce,
	  reduceRight: reduceRight,
	  reflect: reflect,
	  reflectAll: reflectAll,
	  reject: reject,
	  rejectLimit: rejectLimit,
	  rejectSeries: rejectSeries,
	  retry: retry,
	  retryable: retryable,
	  seq: seq$1,
	  series: series,
	  setImmediate: setImmediate$1,
	  some: some,
	  someLimit: someLimit,
	  someSeries: someSeries,
	  sortBy: sortBy,
	  timeout: timeout,
	  times: times,
	  timesLimit: timeLimit,
	  timesSeries: timesSeries,
	  transform: transform,
	  unmemoize: unmemoize,
	  until: until,
	  waterfall: waterfall,
	  whilst: whilst,
	
	  // aliases
	  all: every,
	  any: some,
	  forEach: eachLimit,
	  forEachSeries: eachSeries,
	  forEachLimit: eachLimit$1,
	  forEachOf: eachOf,
	  forEachOfSeries: eachOfSeries,
	  forEachOfLimit: eachOfLimit,
	  inject: reduce,
	  foldl: reduce,
	  foldr: reduceRight,
	  select: filter,
	  selectLimit: filterLimit,
	  selectSeries: filterSeries,
	  wrapSync: asyncify
	};
	
	exports['default'] = index;
	exports.applyEach = applyEach;
	exports.applyEachSeries = applyEachSeries;
	exports.apply = apply$2;
	exports.asyncify = asyncify;
	exports.auto = auto;
	exports.autoInject = autoInject;
	exports.cargo = cargo;
	exports.compose = compose;
	exports.concat = concat;
	exports.concatSeries = concatSeries;
	exports.constant = constant$2;
	exports.detect = detect;
	exports.detectLimit = detectLimit;
	exports.detectSeries = detectSeries;
	exports.dir = dir;
	exports.doDuring = doDuring;
	exports.doUntil = doUntil;
	exports.doWhilst = doWhilst;
	exports.during = during;
	exports.each = eachLimit;
	exports.eachLimit = eachLimit$1;
	exports.eachOf = eachOf;
	exports.eachOfLimit = eachOfLimit;
	exports.eachOfSeries = eachOfSeries;
	exports.eachSeries = eachSeries;
	exports.ensureAsync = ensureAsync;
	exports.every = every;
	exports.everyLimit = everyLimit;
	exports.everySeries = everySeries;
	exports.filter = filter;
	exports.filterLimit = filterLimit;
	exports.filterSeries = filterSeries;
	exports.forever = forever;
	exports.log = log;
	exports.map = map;
	exports.mapLimit = mapLimit;
	exports.mapSeries = mapSeries;
	exports.mapValues = mapValues;
	exports.mapValuesLimit = mapValuesLimit;
	exports.mapValuesSeries = mapValuesSeries;
	exports.memoize = memoize;
	exports.nextTick = nextTick;
	exports.parallel = parallelLimit;
	exports.parallelLimit = parallelLimit$1;
	exports.priorityQueue = priorityQueue;
	exports.queue = queue$1;
	exports.race = race;
	exports.reduce = reduce;
	exports.reduceRight = reduceRight;
	exports.reflect = reflect;
	exports.reflectAll = reflectAll;
	exports.reject = reject;
	exports.rejectLimit = rejectLimit;
	exports.rejectSeries = rejectSeries;
	exports.retry = retry;
	exports.retryable = retryable;
	exports.seq = seq$1;
	exports.series = series;
	exports.setImmediate = setImmediate$1;
	exports.some = some;
	exports.someLimit = someLimit;
	exports.someSeries = someSeries;
	exports.sortBy = sortBy;
	exports.timeout = timeout;
	exports.times = times;
	exports.timesLimit = timeLimit;
	exports.timesSeries = timesSeries;
	exports.transform = transform;
	exports.unmemoize = unmemoize;
	exports.until = until;
	exports.waterfall = waterfall;
	exports.whilst = whilst;
	exports.all = every;
	exports.allLimit = everyLimit;
	exports.allSeries = everySeries;
	exports.any = some;
	exports.anyLimit = someLimit;
	exports.anySeries = someSeries;
	exports.find = detect;
	exports.findLimit = detectLimit;
	exports.findSeries = detectSeries;
	exports.forEach = eachLimit;
	exports.forEachSeries = eachSeries;
	exports.forEachLimit = eachLimit$1;
	exports.forEachOf = eachOf;
	exports.forEachOfSeries = eachOfSeries;
	exports.forEachOfLimit = eachOfLimit;
	exports.inject = reduce;
	exports.foldl = reduce;
	exports.foldr = reduceRight;
	exports.select = filter;
	exports.selectLimit = filterLimit;
	exports.selectSeries = filterSeries;
	exports.wrapSync = asyncify;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(175)(module), __webpack_require__(38).setImmediate, __webpack_require__(7)))

/***/ },
/* 96 */
/***/ function(module, exports) {

	"use strict";
	var ProcessableObject = (function () {
	    function ProcessableObject(sdk, collectionName) {
	        this.sdk = sdk;
	        this.collectionName = collectionName;
	    }
	    ProcessableObject.prototype.buildDataQuery = function (data, op, meta) {
	        return this.sdk.buildDataQuery(data, op, meta);
	    };
	    //TODO: these callbacks should be removed if I recall correctly, check after TS migration is ready
	    ProcessableObject.prototype.processDataQuery = function (query, success, error) {
	        return this.sdk.processDataQuery(query, this, success, error);
	    };
	    return ProcessableObject;
	}());
	exports.ProcessableObject = ProcessableObject;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var events_1 = __webpack_require__(17);
	var DataQuery = (function (_super) {
	    __extends(DataQuery, _super);
	    function DataQuery(config) {
	        _super.call(this);
	        this.config = config;
	        this.data = config.data;
	        this.query = config.query;
	        this.originalParameters = config.originalParameters;
	        this.operation = config.operation;
	        this.additionalOptions = config.additionalOptions;
	    }
	    return DataQuery;
	}(events_1.EventEmitter));
	exports.DataQuery = DataQuery;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var DataQuery_1 = __webpack_require__(97);
	var Query_1 = __webpack_require__(41);
	var DataQueryBuilder = (function () {
	    function DataQueryBuilder() {
	    }
	    DataQueryBuilder.prototype._getInitialDataQuery = function (operation, meta) {
	        return new DataQuery_1.DataQuery({ meta: meta, operation: operation });
	    };
	    DataQueryBuilder.prototype.buildDataQuery = function (data, op, meta) {
	        var dataQuery = this._getInitialDataQuery(op, meta);
	        if (data instanceof Query_1.Query) {
	            dataQuery.query = data;
	        }
	        if (data) {
	            dataQuery.additionalOptions = data.additionalOptions;
	        }
	        return _.extend(dataQuery, meta);
	    };
	    return DataQueryBuilder;
	}());
	exports.DataQueryBuilder = DataQueryBuilder;


/***/ },
/* 99 */
/***/ function(module, exports) {

	"use strict";
	var Errors = (function () {
	    function Errors() {
	    }
	    Errors.cancelled = {
	        code: 3000,
	        message: 'Query cancelled.'
	    };
	    return Errors;
	}());
	exports.Errors = Errors;


/***/ },
/* 100 */
/***/ function(module, exports) {

	/**
	 * @typedef Everlive.Callbacks
	 * @description Defines callback functions used throughout the SDK.
	 */
	/**
	 * A function that is called when [authentication.getAuthenticationStatus]{@link ../Authentication/Authentication.getAuthenticationStatus} is executed successfully.
	 * @function Everlive.Callbacks.authenticationStatusSuccess
	 * @param {Everlive.ResultTypes.authenticationStatusResult} authResult The authentication status success function result.
	 */
	/**
	 * A function that is called when an error occurs during the execution of [authentication.getAuthenticationStatus]{@link ../Authentication/Authentication.getAuthenticationStatus}.
	 * @function Everlive.Callbacks.authenticationStatusError
	 * @param {Everlive.ResultTypes.authenticationStatusError} authResult The error that occurred during authentication.
	 */ 


/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * @typedef Everlive.ResultTypes
	 * @description Defines result types returned by functions throughout the SDK.
	 */
	/**
	 * @typedef Everlive.ResultTypes.authenticationStatusResult
	 * @description An object containing information about the current authentication status.
	 * @property {Everlive.AuthStatus} result.status The current authentication status.
	 * @property {Everlive.User} [result.user] When the SDK is authenticated, the user is also returned.
	 */
	/**
	 * @typedef Users.ResultTypes
	 * @description Defines the result types that can be returned by users functions.
	 */
	/**
	 * @typedef Users.ResultTypes.currentUserResult
	 * @description An object containing information about the current user.
	 * @property {Date} CreatedAt
	 * @property {GUID} CreatedBy
	 * @property {GUID} Id
	 * @property {String} IdentityProvider
	 * @property {Boolean} IsVerified
	 * @property {Object} Meta
	 * @property {Date} ModifiedAt
	 * @property {Date} ModifiedBy
	 * @property {GUID} Owner
	 * @property {GUID} Role
	 * @property {String} Username
	 */


/***/ },
/* 102 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 103 */
102,
/* 104 */
102,
/* 105 */
102,
/* 106 */
102,
/* 107 */
102,
/* 108 */
102,
/* 109 */
102,
/* 110 */
102,
/* 111 */
102,
/* 112 */
102,
/* 113 */
102,
/* 114 */
102,
/* 115 */
102,
/* 116 */
102,
/* 117 */
102,
/* 118 */
102,
/* 119 */
102,
/* 120 */
102,
/* 121 */
102,
/* 122 */
102,
/* 123 */
102,
/* 124 */
102,
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 126 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This script gives you the zone info key representing your device's time zone setting.
	 *
	 * @name jsTimezoneDetect
	 * @version 1.0.5
	 * @author Jon Nylander
	 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
	 *
	 * For usage and examples, visit:
	 * http://pellepim.bitbucket.org/jstz/
	 *
	 * Copyright (c) Jon Nylander
	 */
	
	/*jslint undef: true */
	/*global console, exports*/
	
	(function(root) {
	  /**
	   * Namespace to hold all the code for timezone detection.
	   */
	  var jstz = (function () {
	      'use strict';
	      var HEMISPHERE_SOUTH = 's',
	          
	          /**
	           * Gets the offset in minutes from UTC for a certain date.
	           * @param {Date} date
	           * @returns {Number}
	           */
	          get_date_offset = function (date) {
	              var offset = -date.getTimezoneOffset();
	              return (offset !== null ? offset : 0);
	          },
	
	          get_date = function (year, month, date) {
	              var d = new Date();
	              if (year !== undefined) {
	                d.setFullYear(year);
	              }
	              d.setMonth(month);
	              d.setDate(date);
	              return d;
	          },
	
	          get_january_offset = function (year) {
	              return get_date_offset(get_date(year, 0 ,2));
	          },
	
	          get_june_offset = function (year) {
	              return get_date_offset(get_date(year, 5, 2));
	          },
	
	          /**
	           * Private method.
	           * Checks whether a given date is in daylight saving time.
	           * If the date supplied is after august, we assume that we're checking
	           * for southern hemisphere DST.
	           * @param {Date} date
	           * @returns {Boolean}
	           */
	          date_is_dst = function (date) {
	              var is_southern = date.getMonth() > 7,
	                  base_offset = is_southern ? get_june_offset(date.getFullYear()) : 
	                                              get_january_offset(date.getFullYear()),
	                  date_offset = get_date_offset(date),
	                  is_west = base_offset < 0,
	                  dst_offset = base_offset - date_offset;
	                  
	              if (!is_west && !is_southern) {
	                  return dst_offset < 0;
	              }
	
	              return dst_offset !== 0;
	          },
	
	          /**
	           * This function does some basic calculations to create information about
	           * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
	           * the script has been tested rather than depend on the year set by the
	           * client device.
	           *
	           * Returns a key that can be used to do lookups in jstz.olson.timezones.
	           * eg: "720,1,2". 
	           *
	           * @returns {String}
	           */
	
	          lookup_key = function () {
	              var january_offset = get_january_offset(),
	                  june_offset = get_june_offset(),
	                  diff = january_offset - june_offset;
	
	              if (diff < 0) {
	                  return january_offset + ",1";
	              } else if (diff > 0) {
	                  return june_offset + ",1," + HEMISPHERE_SOUTH;
	              }
	
	              return january_offset + ",0";
	          },
	
	          /**
	           * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
	           *
	           * Returns a primitive object on the format:
	           * {'timezone': TimeZone, 'key' : 'the key used to find the TimeZone object'}
	           *
	           * @returns Object
	           */
	          determine = function () {
	              var key = lookup_key();
	              return new jstz.TimeZone(jstz.olson.timezones[key]);
	          },
	
	          /**
	           * This object contains information on when daylight savings starts for
	           * different timezones.
	           *
	           * The list is short for a reason. Often we do not have to be very specific
	           * to single out the correct timezone. But when we do, this list comes in
	           * handy.
	           *
	           * Each value is a date denoting when daylight savings starts for that timezone.
	           */
	          dst_start_for = function (tz_name) {
	
	            var ru_pre_dst_change = new Date(2010, 6, 15, 1, 0, 0, 0), // In 2010 Russia had DST, this allows us to detect Russia :)
	                dst_starts = {
	                    'America/Denver': new Date(2011, 2, 13, 3, 0, 0, 0),
	                    'America/Mazatlan': new Date(2011, 3, 3, 3, 0, 0, 0),
	                    'America/Chicago': new Date(2011, 2, 13, 3, 0, 0, 0),
	                    'America/Mexico_City': new Date(2011, 3, 3, 3, 0, 0, 0),
	                    'America/Asuncion': new Date(2012, 9, 7, 3, 0, 0, 0),
	                    'America/Santiago': new Date(2012, 9, 3, 3, 0, 0, 0),
	                    'America/Campo_Grande': new Date(2012, 9, 21, 5, 0, 0, 0),
	                    'America/Montevideo': new Date(2011, 9, 2, 3, 0, 0, 0),
	                    'America/Sao_Paulo': new Date(2011, 9, 16, 5, 0, 0, 0),
	                    'America/Los_Angeles': new Date(2011, 2, 13, 8, 0, 0, 0),
	                    'America/Santa_Isabel': new Date(2011, 3, 5, 8, 0, 0, 0),
	                    'America/Havana': new Date(2012, 2, 10, 2, 0, 0, 0),
	                    'America/New_York': new Date(2012, 2, 10, 7, 0, 0, 0),
	                    'Europe/Helsinki': new Date(2013, 2, 31, 5, 0, 0, 0),
	                    'Pacific/Auckland': new Date(2011, 8, 26, 7, 0, 0, 0),
	                    'America/Halifax': new Date(2011, 2, 13, 6, 0, 0, 0),
	                    'America/Goose_Bay': new Date(2011, 2, 13, 2, 1, 0, 0),
	                    'America/Miquelon': new Date(2011, 2, 13, 5, 0, 0, 0),
	                    'America/Godthab': new Date(2011, 2, 27, 1, 0, 0, 0),
	                    'Europe/Moscow': ru_pre_dst_change,
	                    'Asia/Amman': new Date(2013, 2, 29, 1, 0, 0, 0),
	                    'Asia/Beirut': new Date(2013, 2, 31, 2, 0, 0, 0),
	                    'Asia/Damascus': new Date(2013, 3, 6, 2, 0, 0, 0),
	                    'Asia/Jerusalem': new Date(2013, 2, 29, 5, 0, 0, 0),
	                    'Asia/Yekaterinburg': ru_pre_dst_change,
	                    'Asia/Omsk': ru_pre_dst_change,
	                    'Asia/Krasnoyarsk': ru_pre_dst_change,
	                    'Asia/Irkutsk': ru_pre_dst_change,
	                    'Asia/Yakutsk': ru_pre_dst_change,
	                    'Asia/Vladivostok': ru_pre_dst_change,
	                    'Asia/Baku': new Date(2013, 2, 31, 4, 0, 0),
	                    'Asia/Yerevan': new Date(2013, 2, 31, 3, 0, 0),
	                    'Asia/Kamchatka': ru_pre_dst_change,
	                    'Asia/Gaza': new Date(2010, 2, 27, 4, 0, 0),
	                    'Africa/Cairo': new Date(2010, 4, 1, 3, 0, 0),
	                    'Europe/Minsk': ru_pre_dst_change,
	                    'Pacific/Apia': new Date(2010, 10, 1, 1, 0, 0, 0),
	                    'Pacific/Fiji': new Date(2010, 11, 1, 0, 0, 0),
	                    'Australia/Perth': new Date(2008, 10, 1, 1, 0, 0, 0)
	                };
	
	              return dst_starts[tz_name];
	          };
	
	      return {
	          determine: determine,
	          date_is_dst: date_is_dst,
	          dst_start_for: dst_start_for 
	      };
	  }());
	
	  /**
	   * Simple object to perform ambiguity check and to return name of time zone.
	   */
	  jstz.TimeZone = function (tz_name) {
	      'use strict';
	        /**
	         * The keys in this object are timezones that we know may be ambiguous after
	         * a preliminary scan through the olson_tz object.
	         *
	         * The array of timezones to compare must be in the order that daylight savings
	         * starts for the regions.
	         */
	      var AMBIGUITIES = {
	              'America/Denver':       ['America/Denver', 'America/Mazatlan'],
	              'America/Chicago':      ['America/Chicago', 'America/Mexico_City'],
	              'America/Santiago':     ['America/Santiago', 'America/Asuncion', 'America/Campo_Grande'],
	              'America/Montevideo':   ['America/Montevideo', 'America/Sao_Paulo'],
	              'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Asia/Beirut', 'Europe/Helsinki','Asia/Damascus'],
	              'Pacific/Auckland':     ['Pacific/Auckland', 'Pacific/Fiji'],
	              'America/Los_Angeles':  ['America/Los_Angeles', 'America/Santa_Isabel'],
	              'America/New_York':     ['America/Havana', 'America/New_York'],
	              'America/Halifax':      ['America/Goose_Bay', 'America/Halifax'],
	              'America/Godthab':      ['America/Miquelon', 'America/Godthab'],
	              'Asia/Dubai':           ['Europe/Moscow'],
	              'Asia/Dhaka':           ['Asia/Yekaterinburg'],
	              'Asia/Jakarta':         ['Asia/Omsk'],
	              'Asia/Shanghai':        ['Asia/Krasnoyarsk', 'Australia/Perth'],
	              'Asia/Tokyo':           ['Asia/Irkutsk'],
	              'Australia/Brisbane':   ['Asia/Yakutsk'],
	              'Pacific/Noumea':       ['Asia/Vladivostok'],
	              'Pacific/Tarawa':       ['Asia/Kamchatka', 'Pacific/Fiji'],
	              'Pacific/Tongatapu':    ['Pacific/Apia'],
	              'Asia/Baghdad':         ['Europe/Minsk'],
	              'Asia/Baku':            ['Asia/Yerevan','Asia/Baku'],
	              'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
	          },
	
	          timezone_name = tz_name,
	          
	          /**
	           * Checks if a timezone has possible ambiguities. I.e timezones that are similar.
	           *
	           * For example, if the preliminary scan determines that we're in America/Denver.
	           * We double check here that we're really there and not in America/Mazatlan.
	           *
	           * This is done by checking known dates for when daylight savings start for different
	           * timezones during 2010 and 2011.
	           */
	          ambiguity_check = function () {
	              var ambiguity_list = AMBIGUITIES[timezone_name],
	                  length = ambiguity_list.length,
	                  i = 0,
	                  tz = ambiguity_list[0];
	
	              for (; i < length; i += 1) {
	                  tz = ambiguity_list[i];
	
	                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {
	                      timezone_name = tz;
	                      return;
	                  }
	              }
	          },
	
	          /**
	           * Checks if it is possible that the timezone is ambiguous.
	           */
	          is_ambiguous = function () {
	              return typeof (AMBIGUITIES[timezone_name]) !== 'undefined';
	          };
	
	      if (is_ambiguous()) {
	          ambiguity_check();
	      }
	
	      return {
	          name: function () {
	              return timezone_name;
	          }
	      };
	  };
	
	  jstz.olson = {};
	
	  /*
	   * The keys in this dictionary are comma separated as such:
	   *
	   * First the offset compared to UTC time in minutes.
	   *
	   * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
	   * does.
	   *
	   * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
	   * only interesting for timezones with DST.
	   *
	   * The mapped arrays is used for constructing the jstz.TimeZone object from within
	   * jstz.determine_timezone();
	   */
	  jstz.olson.timezones = {
	      '-720,0'   : 'Pacific/Majuro',
	      '-660,0'   : 'Pacific/Pago_Pago',
	      '-600,1'   : 'America/Adak',
	      '-600,0'   : 'Pacific/Honolulu',
	      '-570,0'   : 'Pacific/Marquesas',
	      '-540,0'   : 'Pacific/Gambier',
	      '-540,1'   : 'America/Anchorage',
	      '-480,1'   : 'America/Los_Angeles',
	      '-480,0'   : 'Pacific/Pitcairn',
	      '-420,0'   : 'America/Phoenix',
	      '-420,1'   : 'America/Denver',
	      '-360,0'   : 'America/Guatemala',
	      '-360,1'   : 'America/Chicago',
	      '-360,1,s' : 'Pacific/Easter',
	      '-300,0'   : 'America/Bogota',
	      '-300,1'   : 'America/New_York',
	      '-270,0'   : 'America/Caracas',
	      '-240,1'   : 'America/Halifax',
	      '-240,0'   : 'America/Santo_Domingo',
	      '-240,1,s' : 'America/Santiago',
	      '-210,1'   : 'America/St_Johns',
	      '-180,1'   : 'America/Godthab',
	      '-180,0'   : 'America/Argentina/Buenos_Aires',
	      '-180,1,s' : 'America/Montevideo',
	      '-120,0'   : 'America/Noronha',
	      '-120,1'   : 'America/Noronha',
	      '-60,1'    : 'Atlantic/Azores',
	      '-60,0'    : 'Atlantic/Cape_Verde',
	      '0,0'      : 'UTC',
	      '0,1'      : 'Europe/London',
	      '60,1'     : 'Europe/Berlin',
	      '60,0'     : 'Africa/Lagos',
	      '60,1,s'   : 'Africa/Windhoek',
	      '120,1'    : 'Asia/Beirut',
	      '120,0'    : 'Africa/Johannesburg',
	      '180,0'    : 'Asia/Baghdad',
	      '180,1'    : 'Europe/Moscow',
	      '210,1'    : 'Asia/Tehran',
	      '240,0'    : 'Asia/Dubai',
	      '240,1'    : 'Asia/Baku',
	      '270,0'    : 'Asia/Kabul',
	      '300,1'    : 'Asia/Yekaterinburg',
	      '300,0'    : 'Asia/Karachi',
	      '330,0'    : 'Asia/Kolkata',
	      '345,0'    : 'Asia/Kathmandu',
	      '360,0'    : 'Asia/Dhaka',
	      '360,1'    : 'Asia/Omsk',
	      '390,0'    : 'Asia/Rangoon',
	      '420,1'    : 'Asia/Krasnoyarsk',
	      '420,0'    : 'Asia/Jakarta',
	      '480,0'    : 'Asia/Shanghai',
	      '480,1'    : 'Asia/Irkutsk',
	      '525,0'    : 'Australia/Eucla',
	      '525,1,s'  : 'Australia/Eucla',
	      '540,1'    : 'Asia/Yakutsk',
	      '540,0'    : 'Asia/Tokyo',
	      '570,0'    : 'Australia/Darwin',
	      '570,1,s'  : 'Australia/Adelaide',
	      '600,0'    : 'Australia/Brisbane',
	      '600,1'    : 'Asia/Vladivostok',
	      '600,1,s'  : 'Australia/Sydney',
	      '630,1,s'  : 'Australia/Lord_Howe',
	      '660,1'    : 'Asia/Kamchatka',
	      '660,0'    : 'Pacific/Noumea',
	      '690,0'    : 'Pacific/Norfolk',
	      '720,1,s'  : 'Pacific/Auckland',
	      '720,0'    : 'Pacific/Tarawa',
	      '765,1,s'  : 'Pacific/Chatham',
	      '780,0'    : 'Pacific/Tongatapu',
	      '780,1,s'  : 'Pacific/Apia',
	      '840,0'    : 'Pacific/Kiritimati'
	  };
	
	  if (true) {
	    exports.jstz = jstz;
	  } else {
	    root.jstz = jstz;
	  }
	})(this);
	


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var CryptoJS = __webpack_require__(12).CryptoJS;
	__webpack_require__(159);
	__webpack_require__(162);
	__webpack_require__(160);
	__webpack_require__(158);
	__webpack_require__(157);
	var JsonFormatter = __webpack_require__(161).JsonFormatter;
	
	exports.CryptoJS = CryptoJS;
	exports.JsonFormatter = JsonFormatter;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(92);
	
	/*<replacement>*/
	var util = __webpack_require__(26);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(91);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(88);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(17).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(37);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(17).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(24).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(85);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(26);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(192);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(164);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(14);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(131).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(14);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(131).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(24).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_132__;

/***/ },
/* 133 */
/***/ function(module, exports) {

	"use strict";
	var CommonSetup = (function () {
	    function CommonSetup() {
	    }
	    return CommonSetup;
	}());
	exports.CommonSetup = CommonSetup;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ProcessableObject_1 = __webpack_require__(96);
	var CommonData = (function (_super) {
	    __extends(CommonData, _super);
	    function CommonData(sdk, collectionName, settings) {
	        _super.call(this, sdk, collectionName);
	        this.collectionName = collectionName;
	        this.settings = settings;
	    }
	    return CommonData;
	}(ProcessableObject_1.ProcessableObject));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CommonData;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Processor_1 = __webpack_require__(136);
	var ErrorProcessor_1 = __webpack_require__(143);
	var DataQueryBuilder_1 = __webpack_require__(98);
	var EventEmitterExtended_1 = __webpack_require__(40);
	var MethodMustBeOverridenError = new Error('Method must be overriden');
	var Sdk = (function (_super) {
	    __extends(Sdk, _super);
	    function Sdk(options) {
	        _super.call(this);
	        this.options = options;
	        this.setup = this._getSetup(options);
	        this.dataQueryProcessor = this._getDataQueryProcessor();
	        this.dataQueryBuilder = this._getDataQueryBuilder();
	        this.authentication = this._getAuthentication();
	        this.registerErrorProcessor(new ErrorProcessor_1.default());
	    }
	    Sdk.prototype.registerDataQueryPreProcessor = function (processor) {
	        this.dataQueryProcessor.preProcessors.push(processor);
	    };
	    Sdk.prototype.registerDataQueryProcessor = function (processor) {
	        this.dataQueryProcessor.processors.push(processor);
	    };
	    Sdk.prototype.registerDataQueryPostProcessor = function (processor) {
	        this.dataQueryProcessor.postProcessors.push(processor);
	    };
	    Sdk.prototype.registerErrorProcessor = function (processor) {
	        this.dataQueryProcessor.errorProcessors.push(processor);
	    };
	    Sdk.prototype.processDataQuery = function (query, data, success, error) {
	        return this.dataQueryProcessor.process(query, data, success, error);
	    };
	    Sdk.prototype.buildDataQuery = function (data, op, meta) {
	        if (data === void 0) { data = {}; }
	        return this.dataQueryBuilder.buildDataQuery(data, op, meta);
	    };
	    Sdk.prototype.data = function (name) {
	        return this._getData(name);
	    };
	    Sdk.prototype._getDataQueryProcessor = function () {
	        return new Processor_1.DataQueryProcessor(this);
	    };
	    Sdk.prototype._getDataQueryBuilder = function () {
	        return new DataQueryBuilder_1.DataQueryBuilder();
	    };
	    Sdk.prototype._getSetup = function (options) {
	        throw MethodMustBeOverridenError;
	    };
	    Sdk.prototype._getData = function (name) {
	        throw MethodMustBeOverridenError;
	    };
	    Sdk.prototype._getAuthentication = function () {
	        throw MethodMustBeOverridenError;
	    };
	    return Sdk;
	}(EventEmitterExtended_1.EventEmitterExtended));
	exports.Sdk = Sdk;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var QueryProcessorIterator_1 = __webpack_require__(137);
	var errors_1 = __webpack_require__(99);
	var utils_1 = __webpack_require__(42);
	var DataQueryProcessor = (function () {
	    function DataQueryProcessor(sdk) {
	        this.sdk = sdk;
	        this.preProcessors = [];
	        this.processors = [];
	        this.postProcessors = [];
	        this.errorProcessors = [];
	    }
	    DataQueryProcessor.prototype._iterate = function (query, processors, data, value) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var iterator = new QueryProcessorIterator_1.QueryProcessorIterator(processors, query);
	            var iteratorTimeout = null;
	            var onNext = function (processor, value) {
	                clearTimeout(iteratorTimeout);
	                iteratorTimeout = setTimeout(function () {
	                    return iterator.error(new Error("Iterator timed out. Processor: " + processor.constructor.name + ". Value - " + JSON.stringify(value)));
	                }, 10 * 6000); //throw error if somewhere the chain hangs for more than 10 seconds
	                try {
	                    return processor.processDataQuery(query, iterator, data, value);
	                }
	                catch (e) {
	                    return iterator.error(e);
	                }
	            };
	            var cleanUp = function () {
	                iterator.removeListener('next', onNext);
	                clearTimeout(iteratorTimeout);
	            };
	            iterator
	                .on('next', onNext)
	                .once('end', function (value) {
	                cleanUp();
	                return resolve(value);
	            })
	                .once('error', function (err) {
	                cleanUp();
	                var processedError = _this._processError(query, data, err);
	                var error = processedError || err;
	                return reject(error);
	            })
	                .once('cancel', function (reason) {
	                cleanUp();
	                return reject({
	                    reason: reason,
	                    error: errors_1.Errors.cancelled
	                });
	            })
	                .start(value);
	        });
	    };
	    DataQueryProcessor.prototype._preProcess = function (query, data) {
	        return this._iterate(query, this.preProcessors, data);
	    };
	    DataQueryProcessor.prototype._process = function (query, data, value) {
	        return this._iterate(query, this.processors, data, value);
	    };
	    DataQueryProcessor.prototype._postProcess = function (query, data, value) {
	        return this._iterate(query, this.postProcessors, data, value);
	    };
	    DataQueryProcessor.prototype._processError = function (query, data, err) {
	        var error = err;
	        this.errorProcessors.forEach(function (p) {
	            error = p.processError(query, data, error);
	        });
	        return error;
	    };
	    DataQueryProcessor.prototype.process = function (query, data, success, error) {
	        var _this = this;
	        return utils_1.Utils.buildPromise(function (resolve, reject) {
	            return _this._preProcess(query, data)
	                .then(function (value) {
	                return _this._process(query, data, value);
	            })
	                .then(function (value) {
	                return _this._postProcess(query, data, value);
	            })
	                .then(function (res) {
	                resolve(res);
	            })
	                .catch(function (err) {
	                reject(err);
	            });
	        }, success, error);
	    };
	    return DataQueryProcessor;
	}());
	exports.DataQueryProcessor = DataQueryProcessor;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var underscore_1 = __webpack_require__(1);
	var EventEmitterExtended_1 = __webpack_require__(40);
	var QueryProcessorIterator = (function (_super) {
	    __extends(QueryProcessorIterator, _super);
	    function QueryProcessorIterator(processors, query) {
	        _super.call(this);
	        this.done = false;
	        this.position = -1;
	        this.processors = processors;
	        //helps with debugging
	        this.$id = underscore_1.random(0, 5000);
	        this.$query = query;
	        this.$operation = query.operation;
	        this._initialValue = null;
	    }
	    QueryProcessorIterator.prototype.restart = function (value) {
	        if (value === void 0) { value = this._initialValue; }
	        return this.start(value);
	    };
	    QueryProcessorIterator.prototype.start = function (value) {
	        this._initialValue = value;
	        this.position = -1;
	        this.done = false;
	        return this.next(value);
	    };
	    QueryProcessorIterator.prototype.next = function (value) {
	        this.position++;
	        if (this.position >= this.processors.length) {
	            return this.end(value);
	        }
	        var nextProcessor = this.processors[this.position];
	        return this.emit('next', nextProcessor, value);
	    };
	    QueryProcessorIterator.prototype.end = function (value) {
	        this.done = true;
	        return this.emit('end', value);
	    };
	    QueryProcessorIterator.prototype.cancel = function (reason) {
	        this.done = true;
	        return this.emit('cancel', reason);
	    };
	    QueryProcessorIterator.prototype.error = function (error) {
	        return this.emit('error', error);
	    };
	    return QueryProcessorIterator;
	}(EventEmitterExtended_1.EventEmitterExtended));
	exports.QueryProcessorIterator = QueryProcessorIterator;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// Registering underscore mixins:
	__webpack_require__(139);


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	var underscoreDeepExtend_1 = __webpack_require__(141);
	var underscoreCompactObject_1 = __webpack_require__(140);
	var underscoreIsObjectEmpty_1 = __webpack_require__(142);
	_.mixin({ 'deepExtend': underscoreDeepExtend_1.deepExtend });
	_.mixin({ 'compactObject': underscoreCompactObject_1.compactObject });
	_.mixin({ 'isEmptyObject': underscoreIsObjectEmpty_1.isEmpty });


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(1);
	//http://stackoverflow.com/questions/14058193/remove-empty-properties-falsy-values-from-object-with-underscore-js
	function compactObject(o) {
	    var newObject = {};
	    _.each(o, function (v, k) {
	        if (v !== null && v !== undefined) {
	            newObject[k] = v;
	        }
	    });
	    return newObject;
	}
	exports.compactObject = compactObject;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/*  Copyright (C) 2012-2014  Kurt Milam - http://xioup.com | Source: https://gist.github.com/1868955
	 *
	 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	 *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	 *
	 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 **/
	"use strict";
	// Based conceptually on the _.extend() function in underscore.js ( see http://documentcloud.github.com/underscore/#extend for more details )
	var _ = __webpack_require__(1);
	function deepExtend(obj) {
	    var parentRE = /#{\s*?_\s*?}/, slice = Array.prototype.slice;
	    _.each(slice.call(arguments, 1), function (source) {
	        for (var prop in source) {
	            if (_.isUndefined(obj[prop]) || _.isFunction(obj[prop]) || _.isNull(source[prop]) || _.isDate(source[prop])) {
	                obj[prop] = source[prop];
	            }
	            else if (_.isString(source[prop]) && parentRE.test(source[prop])) {
	                if (_.isString(obj[prop])) {
	                    obj[prop] = source[prop].replace(parentRE, obj[prop]);
	                }
	            }
	            else if (_.isArray(obj[prop]) || _.isArray(source[prop])) {
	                if (!_.isArray(obj[prop]) || !_.isArray(source[prop])) {
	                    throw new Error('Trying to combine an array with a non-array (' + prop + ')');
	                }
	                else {
	                    obj[prop] = _.reject(_.deepExtend(_.clone(obj[prop]), source[prop]), function (item) {
	                        return _.isNull(item);
	                    });
	                }
	            }
	            else if (_.isObject(obj[prop]) || _.isObject(source[prop])) {
	                if (!_.isObject(obj[prop]) || !_.isObject(source[prop])) {
	                    throw new Error('Trying to combine an object with a non-object (' + prop + ')');
	                }
	                else {
	                    obj[prop] = _.deepExtend(_.clone(obj[prop]), source[prop]);
	                }
	            }
	            else {
	                obj[prop] = source[prop];
	            }
	        }
	    });
	    return obj;
	}
	exports.deepExtend = deepExtend;
	;
	/**
	 * Dependency: underscore.js ( http://documentcloud.github.com/underscore/ )
	 *
	 * Mix it in with underscore.js:
	 * _.mixin({deepExtend: deepExtend});
	 *
	 * Call it like this:
	 * var myObj = _.deepExtend(grandparent, child, grandchild, greatgrandchild)
	 *
	 * Notes:
	 * Keep it DRY.
	 * This function is especially useful if you're working with JSON config documents. It allows you to create a default
	 * config document with the most common settings, then override those settings for specific cases. It accepts any
	 * number of objects as arguments, giving you fine-grained control over your config document hierarchy.
	 *
	 * Special Features and Considerations:
	 * - parentRE allows you to concatenate strings. example:
	 *   var obj = _.deepExtend({url: "www.example.com"}, {url: "http://#{_}/path/to/file.html"});
	 *   console.log(obj.url);
	 *   output: "http://www.example.com/path/to/file.html"
	 *
	 * - parentRE also acts as a placeholder, which can be useful when you need to change one value in an array, while
	 *   leaving the others untouched. example:
	 *   var arr = _.deepExtend([100,    {id: 1234}, true,  "foo",  [250, 500]],
	 *                          ["#{_}", "#{_}",     false, "#{_}", "#{_}"]);
	 *   console.log(arr);
	 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
	 *
	 * - The previous example can also be written like this:
	 *   var arr = _.deepExtend([100,    {id:1234},   true,  "foo",  [250, 500]],
	 *                          ["#{_}", {},          false, "#{_}", []]);
	 *   console.log(arr);
	 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
	 *
	 * - And also like this:
	 *   var arr = _.deepExtend([100,    {id:1234},   true,  "foo",  [250, 500]],
	 *                          ["#{_}", {},          false]);
	 *   console.log(arr);
	 *   output: [100, {id: 1234}, false, "foo", [250, 500]]
	 *
	 * - Array order is important. example:
	 *   var arr = _.deepExtend([1, 2, 3, 4], [1, 4, 3, 2]);
	 *   console.log(arr);
	 *   output: [1, 4, 3, 2]
	 *
	 * - You can remove an array element set in a parent object by setting the same index value to null in a child object.
	 *   example:
	 *   var obj = _.deepExtend({arr: [1, 2, 3, 4]}, {arr: ["#{_}", null]});
	 *   console.log(obj.arr);
	 *   output: [1, 3, 4]
	 *
	 **/ 


/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";
	// http://stackoverflow.com/questions/4994201/is-object-empty
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function isEmpty(obj) {
	    // null and undefined are "empty"
	    if (obj == null)
	        return true;
	    // Assume if it has a length property with a non-zero value
	    // that that property is correct.
	    if (obj.length > 0)
	        return false;
	    if (obj.length === 0)
	        return true;
	    // Otherwise, does it have any properties of its own?
	    // Note that this doesn't handle
	    // toString and valueOf enumeration bugs in IE < 9
	    for (var key in obj) {
	        if (hasOwnProperty.call(obj, key))
	            return false;
	    }
	    return true;
	}
	exports.isEmpty = isEmpty;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(42);
	var ErrorProcessor = (function () {
	    function ErrorProcessor() {
	    }
	    ErrorProcessor.prototype.processError = function (query, data, err) {
	        var setup = data.sdk.setup;
	        var parseOnlyCompleteDateTimeString = setup && setup.parseOnlyCompleteDateTimeObjects;
	        var reviver = utils_1.Utils.parseUtilities.getReviver(parseOnlyCompleteDateTimeString);
	        return utils_1.Utils.parseUtilities.parseXhrError(reviver, err);
	    };
	    return ErrorProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ErrorProcessor;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="typings/custom.d.ts" />
	"use strict";
	var es6_promise_1 = __webpack_require__(146);
	__webpack_require__(138); //initialize common sdk
	var index_1 = __webpack_require__(58);
	es6_promise_1.polyfill();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = index_1.Everlive;
	module.exports = index_1.Everlive;
	module.exports.default = index_1.Everlive;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug.debug = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(156);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting
	    args = exports.formatArgs.apply(self, args);
	
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */
	
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';
	
	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}
	
	function isFunction(x) {
	  return typeof x === 'function';
	}
	
	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}
	
	var isArray = _isArray;
	
	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;
	
	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};
	
	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}
	
	function setAsap(asapFn) {
	  asap = asapFn;
	}
	
	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';
	
	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}
	
	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	
	  return useSetTimeout();
	}
	
	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });
	
	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}
	
	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}
	
	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}
	
	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];
	
	    callback(arg);
	
	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }
	
	  len = 0;
	}
	
	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(191);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}
	
	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}
	
	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;
	
	  var parent = this;
	
	  var child = new this.constructor(noop);
	
	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }
	
	  var _state = parent._state;
	
	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }
	
	  return child;
	}
	
	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.resolve(1);
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }
	
	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}
	
	var PROMISE_ID = Math.random().toString(36).substring(16);
	
	function noop() {}
	
	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	
	var GET_THEN_ERROR = new ErrorObject();
	
	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}
	
	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}
	
	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}
	
	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}
	
	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	
	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}
	
	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}
	
	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}
	
	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}
	
	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }
	
	  publish(promise);
	}
	
	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	
	  promise._result = value;
	  promise._state = FULFILLED;
	
	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}
	
	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	
	  asap(publishRejection, promise);
	}
	
	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;
	
	  parent._onerror = null;
	
	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;
	
	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}
	
	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;
	
	  if (subscribers.length === 0) {
	    return;
	  }
	
	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;
	
	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];
	
	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }
	
	  promise._subscribers.length = 0;
	}
	
	function ErrorObject() {
	  this.error = null;
	}
	
	var TRY_CATCH_ERROR = new ErrorObject();
	
	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}
	
	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;
	
	  if (hasCallback) {
	    value = tryCatch(callback, detail);
	
	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }
	
	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }
	
	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}
	
	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}
	
	var id = 0;
	function nextId() {
	  return id++;
	}
	
	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}
	
	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);
	
	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }
	
	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;
	
	    this._result = new Array(this.length);
	
	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}
	
	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};
	
	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;
	
	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};
	
	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;
	
	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);
	
	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};
	
	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;
	
	  if (promise._state === PENDING) {
	    this._remaining--;
	
	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }
	
	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};
	
	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;
	
	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};
	
	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```
	
	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```
	
	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}
	
	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.
	
	  Example:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```
	
	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```
	
	  An example real-world use case is implementing timeouts:
	
	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```
	
	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}
	
	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}
	
	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}
	
	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}
	
	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.
	
	  Terminology
	  -----------
	
	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.
	
	  A promise can be in one of three states: pending, fulfilled, or rejected.
	
	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.
	
	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.
	
	
	  Basic Usage:
	  ------------
	
	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);
	
	    // on failure
	    reject(reason);
	  });
	
	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Advanced Usage:
	  ---------------
	
	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.
	
	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();
	
	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();
	
	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }
	
	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Unlike callbacks, promises are great composable primitives.
	
	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON
	
	    return values;
	  });
	  ```
	
	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];
	
	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}
	
	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;
	
	Promise.prototype = {
	  constructor: Promise,
	
	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,
	
	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};
	
	function polyfill() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }
	
	        if (promiseToString === '[object Object]' && !P.cast) {
	            return;
	        }
	    }
	
	    local.Promise = Promise;
	}
	
	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;
	
	return Promise;
	
	})));
	//# sourceMappingURL=es6-promise.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }())))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(148);
	
	module.exports = function (obj, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var space = opts.space || '';
	    if (typeof space === 'number') space = Array(space+1).join(' ');
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var replacer = opts.replacer || function(key, value) { return value; };
	
	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);
	
	    var seen = [];
	    return (function stringify (parent, key, node, level) {
	        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
	        var colonSeparator = space ? ': ' : ':';
	
	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }
	
	        node = replacer.call(parent, key, node);
	
	        if (node === undefined) {
	            return;
	        }
	        if (typeof node !== 'object' || node === null) {
	            return json.stringify(node);
	        }
	        if (isArray(node)) {
	            var out = [];
	            for (var i = 0; i < node.length; i++) {
	                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
	                out.push(indent + space + item);
	            }
	            return '[' + out.join(',') + indent + ']';
	        }
	        else {
	            if (seen.indexOf(node) !== -1) {
	                if (cycles) return json.stringify('__cycle__');
	                throw new TypeError('Converting circular structure to JSON');
	            }
	            else seen.push(node);
	
	            var keys = objectKeys(node).sort(cmp && cmp(node));
	            var out = [];
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                var value = stringify(node, key, node[key], level+1);
	
	                if(!value) continue;
	
	                var keyValue = json.stringify(key)
	                    + colonSeparator
	                    + value;
	                ;
	                out.push(indent + space + keyValue);
	            }
	            return '{' + out.join(',') + indent + '}';
	        }
	    })({ '': obj }, '', obj, 0);
	};
	
	var isArray = Array.isArray || function (x) {
	    return {}.toString.call(x) === '[object Array]';
	};
	
	var objectKeys = Object.keys || function (obj) {
	    var has = Object.prototype.hasOwnProperty || function () { return true };
	    var keys = [];
	    for (var key in obj) {
	        if (has.call(obj, key)) keys.push(key);
	    }
	    return keys;
	};


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	exports.parse = __webpack_require__(149);
	exports.stringify = __webpack_require__(150);


/***/ },
/* 149 */
/***/ function(module, exports) {

	var at, // The index of the current character
	    ch, // The current character
	    escapee = {
	        '"':  '"',
	        '\\': '\\',
	        '/':  '/',
	        b:    '\b',
	        f:    '\f',
	        n:    '\n',
	        r:    '\r',
	        t:    '\t'
	    },
	    text,
	
	    error = function (m) {
	        // Call error when something is wrong.
	        throw {
	            name:    'SyntaxError',
	            message: m,
	            at:      at,
	            text:    text
	        };
	    },
	    
	    next = function (c) {
	        // If a c parameter is provided, verify that it matches the current character.
	        if (c && c !== ch) {
	            error("Expected '" + c + "' instead of '" + ch + "'");
	        }
	        
	        // Get the next character. When there are no more characters,
	        // return the empty string.
	        
	        ch = text.charAt(at);
	        at += 1;
	        return ch;
	    },
	    
	    number = function () {
	        // Parse a number value.
	        var number,
	            string = '';
	        
	        if (ch === '-') {
	            string = '-';
	            next('-');
	        }
	        while (ch >= '0' && ch <= '9') {
	            string += ch;
	            next();
	        }
	        if (ch === '.') {
	            string += '.';
	            while (next() && ch >= '0' && ch <= '9') {
	                string += ch;
	            }
	        }
	        if (ch === 'e' || ch === 'E') {
	            string += ch;
	            next();
	            if (ch === '-' || ch === '+') {
	                string += ch;
	                next();
	            }
	            while (ch >= '0' && ch <= '9') {
	                string += ch;
	                next();
	            }
	        }
	        number = +string;
	        if (!isFinite(number)) {
	            error("Bad number");
	        } else {
	            return number;
	        }
	    },
	    
	    string = function () {
	        // Parse a string value.
	        var hex,
	            i,
	            string = '',
	            uffff;
	        
	        // When parsing for string values, we must look for " and \ characters.
	        if (ch === '"') {
	            while (next()) {
	                if (ch === '"') {
	                    next();
	                    return string;
	                } else if (ch === '\\') {
	                    next();
	                    if (ch === 'u') {
	                        uffff = 0;
	                        for (i = 0; i < 4; i += 1) {
	                            hex = parseInt(next(), 16);
	                            if (!isFinite(hex)) {
	                                break;
	                            }
	                            uffff = uffff * 16 + hex;
	                        }
	                        string += String.fromCharCode(uffff);
	                    } else if (typeof escapee[ch] === 'string') {
	                        string += escapee[ch];
	                    } else {
	                        break;
	                    }
	                } else {
	                    string += ch;
	                }
	            }
	        }
	        error("Bad string");
	    },
	
	    white = function () {
	
	// Skip whitespace.
	
	        while (ch && ch <= ' ') {
	            next();
	        }
	    },
	
	    word = function () {
	
	// true, false, or null.
	
	        switch (ch) {
	        case 't':
	            next('t');
	            next('r');
	            next('u');
	            next('e');
	            return true;
	        case 'f':
	            next('f');
	            next('a');
	            next('l');
	            next('s');
	            next('e');
	            return false;
	        case 'n':
	            next('n');
	            next('u');
	            next('l');
	            next('l');
	            return null;
	        }
	        error("Unexpected '" + ch + "'");
	    },
	
	    value,  // Place holder for the value function.
	
	    array = function () {
	
	// Parse an array value.
	
	        var array = [];
	
	        if (ch === '[') {
	            next('[');
	            white();
	            if (ch === ']') {
	                next(']');
	                return array;   // empty array
	            }
	            while (ch) {
	                array.push(value());
	                white();
	                if (ch === ']') {
	                    next(']');
	                    return array;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad array");
	    },
	
	    object = function () {
	
	// Parse an object value.
	
	        var key,
	            object = {};
	
	        if (ch === '{') {
	            next('{');
	            white();
	            if (ch === '}') {
	                next('}');
	                return object;   // empty object
	            }
	            while (ch) {
	                key = string();
	                white();
	                next(':');
	                if (Object.hasOwnProperty.call(object, key)) {
	                    error('Duplicate key "' + key + '"');
	                }
	                object[key] = value();
	                white();
	                if (ch === '}') {
	                    next('}');
	                    return object;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad object");
	    };
	
	value = function () {
	
	// Parse a JSON value. It could be an object, an array, a string, a number,
	// or a word.
	
	    white();
	    switch (ch) {
	    case '{':
	        return object();
	    case '[':
	        return array();
	    case '"':
	        return string();
	    case '-':
	        return number();
	    default:
	        return ch >= '0' && ch <= '9' ? number() : word();
	    }
	};
	
	// Return the json_parse function. It will have access to all of the above
	// functions and variables.
	
	module.exports = function (source, reviver) {
	    var result;
	    
	    text = source;
	    at = 0;
	    ch = ' ';
	    result = value();
	    white();
	    if (ch) {
	        error("Syntax error");
	    }
	
	    // If there is a reviver function, we recursively walk the new structure,
	    // passing each name/value pair to the reviver function for possible
	    // transformation, starting with a temporary root object that holds the result
	    // in an empty key. If there is not a reviver function, we simply return the
	    // result.
	
	    return typeof reviver === 'function' ? (function walk(holder, key) {
	        var k, v, value = holder[key];
	        if (value && typeof value === 'object') {
	            for (k in value) {
	                if (Object.prototype.hasOwnProperty.call(value, k)) {
	                    v = walk(value, k);
	                    if (v !== undefined) {
	                        value[k] = v;
	                    } else {
	                        delete value[k];
	                    }
	                }
	            }
	        }
	        return reviver.call(holder, key, value);
	    }({'': result}, '')) : result;
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    gap,
	    indent,
	    meta = {    // table of character substitutions
	        '\b': '\\b',
	        '\t': '\\t',
	        '\n': '\\n',
	        '\f': '\\f',
	        '\r': '\\r',
	        '"' : '\\"',
	        '\\': '\\\\'
	    },
	    rep;
	
	function quote(string) {
	    // If the string contains no control characters, no quote characters, and no
	    // backslash characters, then we can safely slap some quotes around it.
	    // Otherwise we must also replace the offending characters with safe escape
	    // sequences.
	    
	    escapable.lastIndex = 0;
	    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	        var c = meta[a];
	        return typeof c === 'string' ? c :
	            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    }) + '"' : '"' + string + '"';
	}
	
	function str(key, holder) {
	    // Produce a string from holder[key].
	    var i,          // The loop counter.
	        k,          // The member key.
	        v,          // The member value.
	        length,
	        mind = gap,
	        partial,
	        value = holder[key];
	    
	    // If the value has a toJSON method, call it to obtain a replacement value.
	    if (value && typeof value === 'object' &&
	            typeof value.toJSON === 'function') {
	        value = value.toJSON(key);
	    }
	    
	    // If we were called with a replacer function, then call the replacer to
	    // obtain a replacement value.
	    if (typeof rep === 'function') {
	        value = rep.call(holder, key, value);
	    }
	    
	    // What happens next depends on the value's type.
	    switch (typeof value) {
	        case 'string':
	            return quote(value);
	        
	        case 'number':
	            // JSON numbers must be finite. Encode non-finite numbers as null.
	            return isFinite(value) ? String(value) : 'null';
	        
	        case 'boolean':
	        case 'null':
	            // If the value is a boolean or null, convert it to a string. Note:
	            // typeof null does not produce 'null'. The case is included here in
	            // the remote chance that this gets fixed someday.
	            return String(value);
	            
	        case 'object':
	            if (!value) return 'null';
	            gap += indent;
	            partial = [];
	            
	            // Array.isArray
	            if (Object.prototype.toString.apply(value) === '[object Array]') {
	                length = value.length;
	                for (i = 0; i < length; i += 1) {
	                    partial[i] = str(i, value) || 'null';
	                }
	                
	                // Join all of the elements together, separated with commas, and
	                // wrap them in brackets.
	                v = partial.length === 0 ? '[]' : gap ?
	                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
	                    '[' + partial.join(',') + ']';
	                gap = mind;
	                return v;
	            }
	            
	            // If the replacer is an array, use it to select the members to be
	            // stringified.
	            if (rep && typeof rep === 'object') {
	                length = rep.length;
	                for (i = 0; i < length; i += 1) {
	                    k = rep[i];
	                    if (typeof k === 'string') {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            else {
	                // Otherwise, iterate through all of the keys in the object.
	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            
	        // Join all of the member texts together, separated with commas,
	        // and wrap them in braces.
	
	        v = partial.length === 0 ? '{}' : gap ?
	            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
	            '{' + partial.join(',') + '}';
	        gap = mind;
	        return v;
	    }
	}
	
	module.exports = function (value, replacer, space) {
	    var i;
	    gap = '';
	    indent = '';
	    
	    // If the space parameter is a number, make an indent string containing that
	    // many spaces.
	    if (typeof space === 'number') {
	        for (i = 0; i < space; i += 1) {
	            indent += ' ';
	        }
	    }
	    // If the space parameter is a string, it will be used as the indent string.
	    else if (typeof space === 'string') {
	        indent = space;
	    }
	
	    // If there is a replacer, it must be a function or an array.
	    // Otherwise, throw an error.
	    rep = replacer;
	    if (replacer && typeof replacer !== 'function'
	    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
	        throw new Error('JSON.stringify');
	    }
	    
	    // Make a fake root object containing our value under the key of ''.
	    // Return the result of stringifying the value.
	    return str('', {'': value});
	};


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	// Mingo.js 0.6.2
	// Copyright (c) 2015 Francis Asante <kofrasa@gmail.com>
	// MIT
	
	;
	(function (root, undefined) {
	
	  "use strict";
	
	  // global on the server, window in the browser
	  var Mingo = {}, previousMingo;
	  var _;
	
	  Mingo.VERSION = '0.6.2';
	
	  // backup previous Mingo
	  if (root != null) {
	    previousMingo = root.Mingo;
	  }
	
	  Mingo.noConflict = function () {
	    root.Mingo = previousMingo;
	    return Mingo;
	  };
	
	  var nativeScriptEnabled = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
	  || (typeof UIButton !== 'undefined' && UIButton)));
	
	  var nodeEnabled = ('undefined' !== typeof exports && 'undefined' !== "function" && 'undefined' === typeof window && !nativeScriptEnabled);
	
	  var browserifyEnabled = 'undefined' !== typeof exports && 'undefined' !== "function";
	
	  // Export the Mingo object for Node.js
	  if (nodeEnabled || nativeScriptEnabled || browserifyEnabled) {
	    if (true) {
	      module.exports = Mingo;
	    }
	    _ = __webpack_require__(1); // get a reference to underscore
	  } else {
	    root.Mingo = Mingo;
	    _ = root._; // get a reference to underscore
	  }
	
	  // quick reference for
	  var primitives = [
	    _.isString, _.isBoolean, _.isNumber, _.isDate, _.isNull, _.isRegExp
	  ];
	
	  function isPrimitive(value) {
	    for (var i = 0; i < primitives.length; i++) {
	      if (primitives[i](value)) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Simplify expression for easy evaluation with query operators map
	   * @param expr
	   * @returns {*}
	   */
	  function normalize(expr) {
	
	    // normalized primitives
	    if (isPrimitive(expr)) {
	      return _.isRegExp(expr) ? {"$regex": expr} : {"$eq": expr};
	    }
	
	    // normalize object expression
	    if (_.isObject(expr)) {
	      var keys = _.keys(expr);
	      var notQuery = _.intersection(ops(OP_QUERY), keys).length === 0;
	
	      // no valid query operator found, so we do simple comparison
	      if (notQuery) {
	        return {"$eq": expr};
	      }
	
	      // ensure valid regex
	      if (_.contains(keys, "$regex")) {
	        var regex = expr['$regex'];
	        var options = expr['$options'] || "";
	        var modifiers = "";
	        if (_.isString(regex)) {
	          modifiers += (regex.ignoreCase || options.indexOf("i") >= 0) ? "i" : "";
	          modifiers += (regex.multiline || options.indexOf("m") >= 0) ? "m" : "";
	          modifiers += (regex.global || options.indexOf("g") >= 0) ? "g" : "";
	          regex = new RegExp(regex, modifiers);
	        }
	        expr['$regex'] = regex;
	        delete expr['$options'];
	      }
	    }
	
	    return expr;
	  }
	
	  // Settings used by Mingo internally
	  var settings = {
	    key: "_id"
	  };
	
	  /**
	   * Setup default settings for Mingo
	   * @param options
	   */
	  Mingo.setup = function (options) {
	    _.extend(settings, options || {});
	  };
	
	
	  /**
	   * Query object to test collection elements with
	   * @param criteria the pass criteria for the query
	   * @param projection optional projection specifiers
	   * @constructor
	   */
	  Mingo.Query = function (criteria, projection) {
	    if (!(this instanceof Mingo.Query))
	      return new Mingo.Query(criteria, projection);
	
	    this._criteria = criteria;
	    this._projection = projection;
	    this._compiled = [];
	    this._compile();
	  };
	
	  Mingo.Query.prototype = {
	
	    _compile: function () {
	
	      if (_.isEmpty(this._criteria)) return;
	
	      if (_.isArray(this._criteria) || _.isFunction(this._criteria) || !_.isObject(this._criteria)) {
	        throw new Error("Invalid type for criteria");
	      }
	
	      for (var field in this._criteria) {
	        if (this._criteria.hasOwnProperty(field)) {
	          var expr = this._criteria[field];
	          if (_.contains(['$and', '$or', '$nor', '$where'], field)) {
	            this._processOperator(field, field, expr);
	          } else {
	            // normalize expression
	            expr = normalize(expr);
	            for (var op in expr) {
	              if (expr.hasOwnProperty(op)) {
	                this._processOperator(field, op, expr[op]);
	              }
	            }
	          }
	        }
	      }
	    },
	
	    _processOperator: function (field, operator, value) {
	      if (_.contains(ops(OP_QUERY), operator)) {
	        this._compiled.push(queryOperators[operator](field, value));
	      } else {
	        throw new Error("Invalid query operator '" + operator + "' detected");
	      }
	    },
	
	    /**
	     * Checks if the object passes the query criteria. Returns true if so, false otherwise.
	     * @param obj
	     * @returns {boolean}
	     */
	    test: function (obj) {
	      for (var i = 0; i < this._compiled.length; i++) {
	        if (!this._compiled[i].test(obj)) {
	          return false;
	        }
	      }
	      return true;
	    },
	
	    /**
	     * Performs a query on a collection and returns a cursor object.
	     * @param collection
	     * @param projection
	     * @returns {Mingo.Cursor}
	     */
	    find: function (collection, projection) {
	      return new Mingo.Cursor(collection, this, projection);
	    },
	
	    /**
	     * Remove matched documents from the collection returning the remainder
	     * @param collection
	     * @returns {Array}
	     */
	    remove: function (collection) {
	      var arr = [];
	      for (var i = 0; i < collection.length; i++) {
	        if (!this.test(collection[i])) {
	          arr.push(collection[i]);
	        }
	      }
	      return arr;
	    }
	  };
	
	  if (nodeEnabled) {
	
	    var Transform = __webpack_require__(37).Transform;
	    var util = __webpack_require__(173);
	
	    Mingo.Query.prototype.stream = function (options) {
	      return new Mingo.Stream(this, options);
	    };
	
	    /**
	     * Create a Transform class
	     * @param query
	     * @param options
	     * @returns {Mingo.Stream}
	     * @constructor
	     */
	    Mingo.Stream = function (query, options) {
	
	      if (!(this instanceof Mingo.Stream))
	        return new Mingo.Stream(query, options);
	
	      options = options || {};
	      _.extend(options, {objectMode: true});
	      Transform.call(this, options);
	      // query for this stream
	      this._query = query;
	    };
	    // extend Transform
	    util.inherits(Mingo.Stream, Transform);
	
	    Mingo.Stream.prototype._transform = function (chunk, encoding, done) {
	      if (_.isObject(chunk) && this._query.test(chunk)) {
	        if (_.isEmpty(this._query._projection)) {
	          this.push(chunk);
	        } else {
	          var cursor = new Mingo.Cursor([chunk], this._query);
	          if (cursor.hasNext()) {
	            this.push(cursor.next());
	          }
	        }
	      }
	      done();
	    };
	  }
	
	  /**
	   * Cursor to iterate and perform filtering on matched objects
	   * @param collection
	   * @param query
	   * @param projection
	   * @constructor
	   */
	  Mingo.Cursor = function (collection, query, projection) {
	
	    if (!(this instanceof Mingo.Cursor))
	      return new Mingo.Cursor(collection, query, projection);
	
	    this._query = query;
	    this._collection = collection;
	    this._projection = projection || query._projection;
	    this._operators = {};
	    this._result = false;
	    this._position = 0;
	  };
	
	  Mingo.Cursor.prototype = {
	
	    _fetch: function () {
	      var self = this;
	
	      if (this._result !== false) {
	        return this._result;
	      }
	
	      // inject projection operator
	      if (_.isObject(this._projection)) {
	        _.extend(this._operators, {"$project": this._projection});
	      }
	
	      // if (!_.isArray(this._collection) && !_.isObject(this._collection)) {
	      //   throw new Error("Input collection is not of valid type. Must be an Array.");
	      // }
	
	      // filter collection
	      this._result = _.filter(this._collection, this._query.test, this._query);
	      var pipeline = [];
	
	      _.each(['$sort', '$skip', '$limit', '$project'], function (op) {
	        if (_.has(self._operators, op)) {
	          pipeline.push(_.pick(self._operators, op));
	        }
	      });
	
	      if (pipeline.length > 0) {
	        var aggregator = new Mingo.Aggregator(pipeline);
	        this._result = aggregator.run(this._result, this._query);
	      }
	      return this._result;
	    },
	
	    /**
	     * Fetch and return all matched results
	     * @returns {Array}
	     */
	    all: function () {
	      return this._fetch();
	    },
	
	    /**
	     * Fetch and return the first matching result
	     * @returns {Object}
	     */
	    first: function () {
	      return this.count() > 0 ? this._fetch()[0] : null;
	    },
	
	    /**
	     * Fetch and return the last matching object from the result
	     * @returns {Object}
	     */
	    last: function () {
	      return this.count() > 0 ? this._fetch()[this.count() - 1] : null;
	    },
	
	    /**
	     * Counts the number of matched objects found
	     * @returns {Number}
	     */
	    count: function () {
	      return this._fetch().length;
	    },
	
	    /**
	     * Returns a cursor that begins returning results only after passing or skipping a number of documents.
	     * @param {Number} n the number of results to skip.
	     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
	     */
	    skip: function (n) {
	      _.extend(this._operators, {"$skip": n});
	      return this;
	    },
	
	    /**
	     * Constrains the size of a cursor's result set.
	     * @param {Number} n the number of results to limit to.
	     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
	     */
	    limit: function (n) {
	      _.extend(this._operators, {"$limit": n});
	      return this;
	    },
	
	    /**
	     * Returns results ordered according to a sort specification.
	     * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
	     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
	     */
	    sort: function (modifier) {
	      _.extend(this._operators, {"$sort": modifier});
	      return this;
	    },
	
	    /**
	     * Returns the next document in a cursor.
	     * @returns {Object | Boolean}
	     */
	    next: function () {
	      if (this.hasNext()) {
	        return this._fetch()[this._position++];
	      }
	      return null;
	    },
	
	    /**
	     * Returns true if the cursor has documents and can be iterated.
	     * @returns {boolean}
	     */
	    hasNext: function () {
	      return this.count() > this._position;
	    },
	
	    /**
	     * Specifies the exclusive upper bound for a specific field
	     * @param expr
	     * @returns {Number}
	     */
	    max: function (expr) {
	      return groupOperators.$max(this._fetch(), expr);
	    },
	
	    /**
	     * Specifies the inclusive lower bound for a specific field
	     * @param expr
	     * @returns {Number}
	     */
	    min: function (expr) {
	      return groupOperators.$min(this._fetch(), expr);
	    },
	
	    /**
	     * Applies a function to each document in a cursor and collects the return values in an array.
	     * @param callback
	     * @returns {Array}
	     */
	    map: function (callback) {
	      return _.map(this._fetch(), callback);
	    },
	
	    /**
	     * Applies a JavaScript function for every document in a cursor.
	     * @param callback
	     */
	    forEach: function (callback) {
	      _.each(this._fetch(), callback);
	    }
	
	  };
	
	  /**
	   * Aggregator for defining filter using mongoDB aggregation pipeline syntax
	   * @param operators an Array of pipeline operators
	   * @constructor
	   */
	  Mingo.Aggregator = function (operators) {
	    if (!(this instanceof Mingo.Aggregator))
	      return new Mingo.Aggregator(operators);
	
	    this._operators = operators;
	  };
	
	  Mingo.Aggregator.prototype = {
	
	    /**
	     * Apply the pipeline operations over the collection by order of the sequence added
	     * @param collection an array of objects to process
	     * @param query the `Mingo.Query` object to use as context
	     * @returns {Array}
	     */
	    run: function (collection, query) {
	      if (!_.isEmpty(this._operators)) {
	        // run aggregation pipeline
	        for (var i = 0; i < this._operators.length; i++) {
	          var operator = this._operators[i];
	          var key = _.keys(operator);
	          if (key.length == 1 && _.contains(ops(OP_PIPELINE), key[0])) {
	            key = key[0];
	            if (query instanceof Mingo.Query) {
	              collection = pipelineOperators[key].call(query, collection, operator[key]);
	            } else {
	              collection = pipelineOperators[key](collection, operator[key]);
	            }
	          } else {
	            throw new Error("Invalid aggregation operator '" + key + "'");
	          }
	        }
	      }
	      return collection;
	    }
	  };
	
	  /**
	   * Retrieve the value of a given key on an object
	   * @param obj
	   * @param field
	   * @returns {*}
	   * @private
	   */
	  function getValue(obj, field) {
	    return _.result(obj, field);
	  }
	
	  /**
	   * Resolve the value of the field (dot separated) on the given object
	   * @param obj
	   * @param field
	   * @returns {*}
	   */
	  function resolve(obj, field) {
	    if (!field) {
	      return undefined;
	    }
	    var names = field.split(".");
	    var value = obj;
	    var isText;
	
	    for (var i = 0; i < names.length; i++) {
	      isText = names[i].match(/^\d+$/) === null;
	
	      if (isText && _.isArray(value)) {
	        var res = [];
	        _.each(value, function (item) {
	          res.push(resolve(item, names[i]));
	        });
	        value = res;
	      } else {
	        value = getValue(value, names[i]);
	      }
	
	      if (value === undefined) {
	        break;
	      }
	    }
	
	    return value;
	  }
	
	  /**
	   * Performs a query on a collection and returns a cursor object.
	   * @param collection
	   * @param criteria
	   * @param projection
	   * @returns {Mingo.Cursor}
	   */
	  Mingo.find = function (collection, criteria, projection) {
	    return (new Mingo.Query(criteria)).find(collection, projection);
	  };
	
	  /**
	   * Returns a new array without objects which match the criteria
	   * @param collection
	   * @param criteria
	   * @returns {Array}
	   */
	  Mingo.remove = function (collection, criteria) {
	    return (new Mingo.Query(criteria)).remove(collection);
	  };
	
	  /**
	   * Return the result collection after running the aggregation pipeline for the given collection
	   * @param collection
	   * @param pipeline
	   * @returns {Array}
	   */
	  Mingo.aggregate = function (collection, pipeline) {
	    if (!_.isArray(pipeline)) {
	      throw new Error("Aggregation pipeline must be an array");
	    }
	    return (new Mingo.Aggregator(pipeline)).run(collection);
	  };
	
	  /**
	   * Add new operators
	   * @param type the operator type to extend
	   * @param f a function returning an object of new operators
	   */
	  Mingo.addOperators = function (type, f) {
	    var newOperators = f({
	      resolve: resolve,
	      computeValue: computeValue,
	      ops: ops,
	      key: function () {
	        return settings.key;
	      }
	    });
	
	    // ensure correct type specified
	    if (!_.contains([OP_AGGREGATE, OP_GROUP, OP_PIPELINE, OP_PROJECTION, OP_QUERY], type)) {
	      throw new Error("Could not identify type '" + type + "'");
	    }
	
	    var operators = ops(type);
	
	    // check for existing operators
	    _.each(_.keys(newOperators), function (op) {
	      if (!/^\$\w+$/.test(op)) {
	        throw new Error("Invalid operator name '" + op + "'");
	      }
	      if (_.contains(operators, op)) {
	        throw new Error("Operator " + op + " is already defined for " + type + " operators");
	      }
	    });
	
	    var wrapped = {};
	
	    switch (type) {
	      case OP_QUERY:
	        _.each(_.keys(newOperators), function (op) {
	          wrapped[op] = (function (f, ctx) {
	            return function (selector, value) {
	              return {
	                test: function (obj) {
	                  // value of field must be fully resolved.
	                  var lhs = resolve(obj, selector);
	                  var result = f.call(ctx, selector, lhs, value);
	                  if (_.isBoolean(result)) {
	                    return result;
	                  } else if (result instanceof Mingo.Query) {
	                    return result.test(obj);
	                  } else {
	                    throw new Error("Invalid return type for '" + op + "'. Must return a Boolean or Mingo.Query");
	                  }
	                }
	              };
	            }
	          }(newOperators[op], newOperators));
	        });
	        break;
	      case OP_PROJECTION:
	        _.each(_.keys(newOperators), function (op) {
	          wrapped[op] = (function (f, ctx) {
	            return function (obj, expr, selector) {
	              var lhs = resolve(obj, selector);
	              return f.call(ctx, selector, lhs, expr);
	            }
	          }(newOperators[op], newOperators));
	        });
	        break;
	      default:
	        _.each(_.keys(newOperators), function (op) {
	          wrapped[op] = (function (f, ctx) {
	            return function () {
	              var args = Array.prototype.slice.call(arguments);
	              return f.apply(ctx, args);
	            }
	          }(newOperators[op], newOperators));
	        });
	    }
	
	    // toss the operator salad :)
	    _.extend(OPERATORS[type], wrapped);
	
	  };
	
	  /**
	   * Mixin for Backbone.Collection objects
	   */
	  Mingo.CollectionMixin = {
	    /**
	     * Runs a query and returns a cursor to the result
	     * @param criteria
	     * @param projection
	     * @returns {Mingo.Cursor}
	     */
	    query: function (criteria, projection) {
	      return Mingo.find(this.toJSON(), criteria, projection);
	    },
	
	    /**
	     * Runs the given aggregation operators on this collection
	     * @params pipeline
	     * @returns {Array}
	     */
	    aggregate: function (pipeline) {
	      var args = [this.toJSON(), pipeline];
	      return Mingo.aggregate.apply(null, args);
	    }
	  };
	
	  var pipelineOperators = {
	
	    /**
	     * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.
	     *
	     * @param collection
	     * @param expr
	     * @returns {Array}
	     */
	    $group: function (collection, expr) {
	      // lookup key for grouping
	      var idKey = expr[settings.key];
	
	      var partitions = groupBy(collection, function (obj) {
	        return computeValue(obj, idKey, idKey);
	      });
	
	      var result = [];
	
	      // remove the group key
	      expr = _.omit(expr, settings.key);
	
	      _.each(partitions.keys, function (value, i) {
	        var obj = {};
	
	        // exclude undefined key value
	        if (!_.isUndefined(value)) {
	          obj[settings.key] = value;
	        }
	
	        // compute remaining keys in expression
	        for (var key in expr) {
	          if (expr.hasOwnProperty(key)) {
	            obj[key] = accumulate(partitions.groups[i], key, expr[key]);
	          }
	        }
	        result.push(obj);
	      });
	
	      return result;
	    },
	
	    /**
	     * Filters the document stream, and only allows matching documents to pass into the next pipeline stage.
	     * $match uses standard MongoDB queries.
	     *
	     * @param collection
	     * @param expr
	     * @returns {Array|*}
	     */
	    $match: function (collection, expr) {
	      return (new Mingo.Query(expr)).find(collection).all();
	    },
	
	    /**
	     * Reshapes a document stream.
	     * $project can rename, add, or remove fields as well as create computed values and sub-documents.
	     *
	     * @param collection
	     * @param expr
	     * @returns {Array}
	     */
	    $project: function (collection, expr) {
	
	      if (_.isEmpty(expr)) {
	        return collection;
	      }
	      var usesExclusion = false;
	      _.each(expr, function(val, key) {
	        if(val === 0 && key !== settings.key) {
	           usesExclusion = true;
	        }
	        if(val !== 0 && usesExclusion) {
	            throw new Error("You cannot mix including and excluding fields."); 
	        }
	      });
	
	      // result collection
	      var projected = [];
	      var objKeys = _.keys(expr);
	      var idOnlyExcludedExpression = false;
	
	      if (_.contains(objKeys, settings.key)) {
	        var id = expr[settings.key];
	        if (id === 0 || id === false) {
	          objKeys = _.without(objKeys, settings.key);
	          if (_.isEmpty(objKeys)) {
	            idOnlyExcludedExpression = true;
	          }
	        }
	      } else {
	        // if not specified the add the ID field
	        objKeys.push(settings.key);
	      }
	
	      for (var i = 0; i < collection.length; i++) {
	
	        var obj = collection[i];
	        var cloneObj = {};
	        var foundSlice = false;
	        var foundExclusion = false;
	        var dropKeys = [];
	        if (idOnlyExcludedExpression) {
	          dropKeys.push(settings.key);
	        }
	
	        _.each(objKeys, function (key) {
	
	          var subExpr = expr[key];
	          var newValue;
	          if (key !== settings.key && subExpr === 0) {
	            foundExclusion = true;
	          }
	
	          // tiny optimization here to skip over id
	          if (key === settings.key && _.isEmpty(subExpr)) {
	            newValue = obj[key];
	          } else if (_.isString(subExpr)) {
	            newValue = computeValue(obj, subExpr, key);
	          } else if (subExpr === 1 || subExpr === true) {
	            newValue = _.result(obj, key);
	          } else if (_.isObject(subExpr)) {
	            var operator = _.keys(subExpr);
	            operator = operator.length > 1 ? false : operator[0];
	            if (operator !== false && _.contains(ops(OP_PROJECTION), operator)) {
	              // apply the projection operator on the operator expression for the key
	              var temp = projectionOperators[operator](obj, subExpr[operator], key);
	              if (!_.isUndefined(temp)) {
	                newValue = temp;
	              }
	              if (operator == '$slice') {
	                foundSlice = true;
	              }
	            } else {
	              // compute the value for the sub expression for the key
	              newValue = computeValue(obj, subExpr, key);
	            }
	          } else {
	            dropKeys.push(key);
	          }
	
	          if (!_.isUndefined(newValue)) {
	            cloneObj[key] = newValue;
	          }
	        });
	        // if projection included $slice operator
	        // Also if exclusion fields are found or we want to exclude only the id field
	        // include keys that were not explicitly excluded
	        if (foundSlice || foundExclusion || idOnlyExcludedExpression) {
	          cloneObj = _.defaults(cloneObj, _.omit(obj, dropKeys));
	        }
	        projected.push(cloneObj);
	      }
	
	      return projected;
	    },
	
	    /**
	     * Restricts the number of documents in an aggregation pipeline.
	     *
	     * @param collection
	     * @param value
	     * @returns {Object|*}
	     */
	    $limit: function (collection, value) {
	      return _.first(collection, value);
	    },
	
	    /**
	     * Skips over a specified number of documents from the pipeline and returns the rest.
	     *
	     * @param collection
	     * @param value
	     * @returns {*}
	     */
	    $skip: function (collection, value) {
	      return _.rest(collection, value);
	    },
	
	    /**
	     * Takes an array of documents and returns them as a stream of documents.
	     *
	     * @param collection
	     * @param expr
	     * @returns {Array}
	     */
	    $unwind: function (collection, expr) {
	      var result = [];
	      var field = expr.substr(1);
	      for (var i = 0; i < collection.length; i++) {
	        var obj = collection[i];
	        // must throw an error if value is not an array
	        var value = getValue(obj, field);
	        if (_.isArray(value)) {
	          _.each(value, function (item) {
	            var tmp = _.clone(obj);
	            tmp[field] = item;
	            result.push(tmp);
	          });
	        } else {
	          throw new Error("Target field '" + field + "' is not of type Array.");
	        }
	      }
	      return result;
	    },
	
	    /**
	     * Takes all input documents and returns them in a stream of sorted documents.
	     *
	     * @param collection
	     * @param sortKeys
	     * @returns {*}
	     */
	    $sort: function (collection, sortKeys) {
	      if (!_.isEmpty(sortKeys) && _.isObject(sortKeys)) {
	        var modifiers = _.keys(sortKeys);
	        modifiers.reverse().forEach(function (key) {
	          var indexes = [];
	          var grouped = _.groupBy(collection, function (obj) {
	            var value = resolve(obj, key);
	            indexes.push(value);
	            return value;
	          });
	          indexes = _.sortBy(_.uniq(indexes), function (item) {
	            return item;
	          });
	          if (sortKeys[key] === -1) {
	            indexes.reverse();
	          }
	          collection = [];
	          _.each(indexes, function (item) {
	            Array.prototype.push.apply(collection, grouped[item]);
	          });
	        });
	      }
	      return collection;
	    }
	  };
	
	  ////////// QUERY OPERATORS //////////
	  var queryOperators = {};
	
	  var compoundOperators = {
	
	    /**
	     * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.
	     *
	     * @param selector
	     * @param value
	     * @returns {{test: Function}}
	     */
	    $and: function (selector, value) {
	      if (!_.isArray(value)) {
	        throw new Error("Invalid expression for $and criteria");
	      }
	      var queries = [];
	      _.each(value, function (expr) {
	        queries.push(new Mingo.Query(expr));
	      });
	
	      return {
	        test: function (obj) {
	          for (var i = 0; i < queries.length; i++) {
	            if (!queries[i].test(obj)) {
	              return false;
	            }
	          }
	          return true;
	        }
	      };
	    },
	
	    /**
	     * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.
	     *
	     * @param selector
	     * @param value
	     * @returns {{test: Function}}
	     */
	    $or: function (selector, value) {
	      if (!_.isArray(value)) {
	        throw new Error("Invalid expression for $or criteria");
	      }
	      var queries = [];
	      _.each(value, function (expr) {
	        queries.push(new Mingo.Query(expr));
	      });
	
	      return {
	        test: function (obj) {
	          for (var i = 0; i < queries.length; i++) {
	            if (queries[i].test(obj)) {
	              return true;
	            }
	          }
	          return false;
	        }
	      };
	    },
	
	    /**
	     * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.
	     *
	     * @param selector
	     * @param value
	     * @returns {{test: Function}}
	     */
	    $nor: function (selector, value) {
	      if (!_.isArray(value)) {
	        throw new Error("Invalid expression for $nor criteria");
	      }
	      var query = this.$or("$or", value);
	      return {
	        test: function (obj) {
	          return !query.test(obj);
	        }
	      };
	    },
	
	    /**
	     * Inverts the effect of a query expression and returns documents that do not match the query expression.
	     *
	     * @param selector
	     * @param value
	     * @returns {{test: Function}}
	     */
	    $not: function (selector, value) {
	      var criteria = {};
	      criteria[selector] = normalize(value);
	      var query = new Mingo.Query(criteria);
	      return {
	        test: function (obj) {
	          return !query.test(obj);
	        }
	      };
	    },
	
	    /**
	     * Matches documents that satisfy a JavaScript expression.
	     *
	     * @param selector
	     * @param value
	     * @returns {{test: test}}
	     */
	    $where: function (selector, value) {
	      if (!_.isFunction(value)) {
	        value = new Function("return " + value + ";");
	      }
	      return {
	        test: function (obj) {
	          return value.call(obj) === true;
	        }
	      };
	    }
	
	  };
	
	  // add compound query operators
	  _.extend(queryOperators, compoundOperators);
	
	  var simpleOperators = {
	
	    /**
	     * Checks that two values are equal. Pseudo operator introduced for convenience and consistency
	     *
	     * @param a
	     * @param b
	     * @returns {*}
	     */
	    $eq: function (a, b) {
	      // flatten to reach nested values. fix for https://github.com/kofrasa/mingo/issues/19
	      a = _.flatten(_.isArray(a) ? a : [a]);
	      a = _.find(a, function (val) {
	        return _.isEqual(val, b);
	      });
	      return a !== undefined;
	    },
	
	    /**
	     * Matches all values that are not equal to the value specified in the query.
	     *
	     * @param a
	     * @param b
	     * @returns {boolean}
	     */
	    $ne: function (a, b) {
	      return !this.$eq(a, b);
	    },
	
	    /**
	     * Matches any of the values that exist in an array specified in the query.
	     *
	     * @param a
	     * @param b
	     * @returns {*}
	     */
	    $in: function (a, b) {
	      a = _.isArray(a) ? a : [a];
	      return _.intersection(a, b).length > 0;
	    },
	
	    /**
	     * Matches values that do not exist in an array specified to the query.
	     *
	     * @param a
	     * @param b
	     * @returns {*|boolean}
	     */
	    $nin: function (a, b) {
	      return _.isUndefined(a) || !this.$in(a, b);
	    },
	
	    /**
	     * Matches values that are less than the value specified in the query.
	     *
	     * @param a
	     * @param b
	     * @returns {boolean}
	     */
	    $lt: function (a, b) {
	      a = _.isArray(a) ? a : [a];
	      a = _.find(a, function (val) {
	        return val < b
	      });
	      return a !== undefined;
	    },
	
	    /**
	     * Matches values that are less than or equal to the value specified in the query.
	     *
	     * @param a
	     * @param b
	     * @returns {boolean}
	     */
	    $lte: function (a, b) {
	      a = _.isArray(a) ? a : [a];
	      a = _.find(a, function (val) {
	        return val <= b
	      });
	      return a !== undefined;
	    },
	
	    /**
	     * Matches values that are greater than the value specified in the query.
	     *
	     * @param a
	     * @param b
	     * @returns {boolean}
	     */
	    $gt: function (a, b) {
	      a = _.isArray(a) ? a : [a];
	      a = _.find(a, function (val) {
	        return val > b
	      });
	      return a !== undefined;
	    },
	
	    /**
	     * Matches values that are greater than or equal to the value specified in the query.
	     *
	     * @param a
	     * @param b
	     * @returns {boolean}
	     */
	    $gte: function (a, b) {
	      a = _.isArray(a) ? a : [a];
	      a = _.find(a, function (val) {
	        return val >= b
	      });
	      return a !== undefined;
	    },
	
	    /**
	     * Performs a modulo operation on the value of a field and selects documents with a specified result.
	     *
	     * @param a
	     * @param b
	     * @returns {*|boolean|boolean}
	     */
	    $mod: function (a, b) {
	      a = _.isArray(a) ? a : [a];
	      a = _.find(a, function (val) {
	        return _.isNumber(val) && _.isArray(b) && b.length === 2 && (val % b[0]) === b[1];
	      });
	      return a !== undefined;
	    },
	
	    /**
	     * Selects documents where values match a specified regular expression.
	     *
	     * @param a
	     * @param b
	     * @returns {*|boolean}
	     */
	    $regex: function (a, b) {
	      a = _.isArray(a) ? a : [a];
	      a = _.find(a, function (val) {
	        return _.isString(val) && _.isRegExp(b) && (!!val.match(b));
	      });
	      return a !== undefined;
	    },
	
	    /**
	     * Matches documents that have the specified field.
	     *
	     * @param a
	     * @param b
	     * @returns {boolean|*|boolean}
	     */
	    $exists: function (a, b) {
	      return (b === false && _.isUndefined(a)) || (b === true && !_.isUndefined(a));
	    },
	
	    /**
	     * Matches arrays that contain all elements specified in the query.
	     *
	     * @param a
	     * @param b
	     * @returns boolean
	     */
	    $all: function (a, b) {
	      var self = this;
	      var matched = false;
	      if (_.isArray(a) && _.isArray(b)) {
	        for (var i = 0; i < b.length; i++) {
	          if (_.isObject(b[i]) && _.contains(_.keys(b[i]), "$elemMatch")) {
	            matched = matched || self.$elemMatch(a, b[i].$elemMatch);
	          } else {
	            // order of arguments matter. underscore maintains order after intersection
	            return _.intersection(b, a).length === b.length;
	          }
	        }
	      }
	      return matched;
	    },
	
	    /**
	     * Selects documents if the array field is a specified size.
	     *
	     * @param a
	     * @param b
	     * @returns {*|boolean}
	     */
	    $size: function (a, b) {
	      return _.isArray(a) && _.isNumber(b) && (a.length === b);
	    },
	
	    /**
	     * Selects documents if element in the array field matches all the specified $elemMatch condition.
	     *
	     * @param a
	     * @param b
	     */
	    $elemMatch: function (a, b) {
	      if (_.isArray(a) && !_.isEmpty(a)) {
	        var query = new Mingo.Query(b);
	        for (var i = 0; i < a.length; i++) {
	          if (query.test(a[i])) {
	            return true;
	          }
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Selects documents if a field is of the specified type.
	     *
	     * @param a
	     * @param b
	     * @returns {boolean}
	     */
	    $type: function (a, b) {
	      switch (b) {
	        case 1:
	          return _.isNumeric(a) && (a + "").indexOf(".") !== -1;
	        case 2:
	        case 5:
	          return _.isString(a);
	        case 3:
	          return _.isObject(a);
	        case 4:
	          return _.isArray(a);
	        case 8:
	          return _.isBoolean(a);
	        case 9:
	          return _.isDate(a);
	        case 10:
	          return _.isNull(a);
	        case 11:
	          return _.isRegExp(a);
	        case 16:
	          return _.isNumeric(a) && a <= 2147483647 && (a + "").indexOf(".") === -1;
	        case 18:
	          return _.isNumeric(a) && a > 2147483647 && a <= 9223372036854775807 && (a + "").indexOf(".") === -1;
	        default:
	          return false;
	      }
	    }
	  };
	  // add simple query operators
	  _.each(_.keys(simpleOperators), function (op) {
	    queryOperators[op] = (function (f, ctx) {
	      return function (selector, value) {
	        return {
	          test: function (obj) {
	            // value of field must be fully resolved.
	            var lhs = resolve(obj, selector);
	            return f.call(ctx, lhs, value);
	          }
	        };
	      }
	    }(simpleOperators[op], simpleOperators));
	  });
	
	  var projectionOperators = {
	
	    /**
	     * Projects the first element in an array that matches the query condition.
	     *
	     * @param obj
	     * @param field
	     * @param expr
	     */
	    $: function (obj, expr, field) {
	      throw new Error("$ not implemented");
	    },
	
	    /**
	     * Projects only the first element from an array that matches the specified $elemMatch condition.
	     *
	     * @param obj
	     * @param field
	     * @param expr
	     * @returns {*}
	     */
	    $elemMatch: function (obj, expr, field) {
	      var array = resolve(obj, field);
	      var query = new Mingo.Query(expr);
	
	      if (_.isUndefined(array) || !_.isArray(array)) {
	        return undefined;
	      }
	
	      for (var i = 0; i < array.length; i++) {
	        if (query.test(array[i])) {
	          return [array[i]];
	        }
	      }
	
	      return undefined;
	    },
	
	    /**
	     * Limits the number of elements projected from an array. Supports skip and limit slices.
	     *
	     * @param obj
	     * @param field
	     * @param expr
	     */
	    $slice: function (obj, expr, field) {
	      var array = resolve(obj, field);
	
	      if (!_.isArray(array)) {
	        return array;
	      }
	      if (!_.isArray(expr)) {
	        if (!_.isNumber(expr)) {
	          throw new Error("Invalid type for $slice operator");
	        }
	        expr = expr < 0 ? [expr] : [0, expr];
	      } else {
	        // MongoDB $slice works a bit differently from Array.slice
	        // Uses single argument for 'limit' and array argument [skip, limit]
	        var skip = (expr[0] < 0) ? array.length + expr[0] : expr;
	        var limit = skip + expr[1];
	        expr = [skip, limit];
	      }
	
	      return Array.prototype.slice.apply(array, expr);
	    }
	  };
	
	  var groupOperators = {
	
	    /**
	     * Returns an array of all the unique values for the selected field among for each document in that group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {*}
	     */
	    $addToSet: function (collection, expr) {
	      var result = _.map(collection, function (obj) {
	        return computeValue(obj, expr, null);
	      });
	      return _.uniq(result);
	    },
	
	    /**
	     * Returns the sum of all the values in a group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {*}
	     */
	    $sum: function (collection, expr) {
	      if (!_.isArray(collection)) {
	        return 0;
	      }
	      if (_.isNumber(expr)) {
	        // take a short cut if expr is number literal
	        return collection.length * expr;
	      }
	      return _.reduce(collection, function (acc, obj) {
	        // pass empty field to avoid naming conflicts with fields on documents
	        return acc + computeValue(obj, expr, null);
	      }, 0);
	    },
	
	    /**
	     * Returns the highest value in a group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {*}
	     */
	    $max: function (collection, expr) {
	      var obj = _.max(collection, function (obj) {
	        return computeValue(obj, expr, null);
	      });
	      return computeValue(obj, expr, null);
	    },
	
	    /**
	     * Returns the lowest value in a group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {*}
	     */
	    $min: function (collection, expr) {
	      var obj = _.min(collection, function (obj) {
	        return computeValue(obj, expr, null);
	      });
	      return computeValue(obj, expr, null);
	    },
	
	    /**
	     * Returns an average of all the values in a group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {number}
	     */
	    $avg: function (collection, expr) {
	      return this.$sum(collection, expr) / (collection.length || 1);
	    },
	
	    /**
	     * Returns an array of all values for the selected field among for each document in that group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {Array|*}
	     */
	    $push: function (collection, expr) {
	      return _.map(collection, function (obj) {
	        return computeValue(obj, expr, null);
	      });
	    },
	
	    /**
	     * Returns the first value in a group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {*}
	     */
	    $first: function (collection, expr) {
	      return (collection.length > 0) ? computeValue(collection[0], expr) : undefined;
	    },
	
	    /**
	     * Returns the last value in a group.
	     *
	     * @param collection
	     * @param expr
	     * @returns {*}
	     */
	    $last: function (collection, expr) {
	      return (collection.length > 0) ? computeValue(collection[collection.length - 1], expr) : undefined;
	    }
	  };
	
	
	  /////////// Aggregation Operators ///////////
	
	  var arithmeticOperators = {
	
	    /**
	     * Computes the sum of an array of numbers.
	     *
	     * @param obj
	     * @param expr
	     * @returns {Object}
	     */
	    $add: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return _.reduce(args, function (memo, num) {
	        return memo + num;
	      }, 0);
	    },
	
	    /**
	     * Takes an array that contains two numbers or two dates and subtracts the second value from the first.
	     *
	     * @param obj
	     * @param expr
	     * @returns {number}
	     */
	    $subtract: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return args[0] - args[1];
	    },
	
	    /**
	     * Takes two numbers and divides the first number by the second.
	     *
	     * @param obj
	     * @param expr
	     * @returns {number}
	     */
	    $divide: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return args[0] / args[1];
	    },
	
	    /**
	     * Computes the product of an array of numbers.
	     *
	     * @param obj
	     * @param expr
	     * @returns {Object}
	     */
	    $multiply: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return _.reduce(args, function (memo, num) {
	        return memo * num;
	      }, 1);
	    },
	
	    /**
	     * Takes two numbers and calculates the modulo of the first number divided by the second.
	     *
	     * @param obj
	     * @param expr
	     * @returns {number}
	     */
	    $mod: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return args[0] % args[1];
	    }
	  };
	
	  var stringOperators = {
	
	    /**
	     * Concatenates two strings.
	     *
	     * @param obj
	     * @param expr
	     * @returns {string|*}
	     */
	    $concat: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      // does not allow concatenation with nulls
	      if (_.contains(args, null) || _.contains(args, undefined)) {
	        return null;
	      }
	      return args.join("");
	    },
	
	    /**
	     * Compares two strings and returns an integer that reflects the comparison.
	     *
	     * @param obj
	     * @param expr
	     * @returns {number}
	     */
	    $strcasecmp: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      args[0] = _.isEmpty(args[0]) ? "" : args[0].toUpperCase();
	      args[1] = _.isEmpty(args[1]) ? "" : args[1].toUpperCase();
	      if (args[0] > args[1]) {
	        return 1;
	      }
	      return (args[0] < args[1]) ? -1 : 0;
	    },
	
	    /**
	     * Returns a substring of a string, starting at a specified index position and including the specified number of characters.
	     * The index is zero-based.
	     *
	     * @param obj
	     * @param expr
	     * @returns {string}
	     */
	    $substr: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      if (_.isString(args[0])) {
	        if (args[1] < 0) {
	          return "";
	        } else if (args[2] < 0) {
	          return args[0].substr(args[1]);
	        } else {
	          return args[0].substr(args[1], args[2]);
	        }
	      }
	      return "";
	    },
	
	    /**
	     * Converts a string to lowercase.
	     *
	     * @param obj
	     * @param expr
	     * @returns {string}
	     */
	    $toLower: function (obj, expr) {
	      var value = computeValue(obj, expr, null);
	      return _.isEmpty(value) ? "" : value.toLowerCase();
	    },
	
	    /**
	     * Converts a string to uppercase.
	     *
	     * @param obj
	     * @param expr
	     * @returns {string}
	     */
	    $toUpper: function (obj, expr) {
	      var value = computeValue(obj, expr, null);
	      return _.isEmpty(value) ? "" : value.toUpperCase();
	    }
	  };
	
	  var dateOperators = {
	    /**
	     * Returns the day of the year for a date as a number between 1 and 366 (leap year).
	     * @param obj
	     * @param expr
	     */
	    $dayOfYear: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      if (_.isDate(d)) {
	        var start = new Date(d.getFullYear(), 0, 0);
	        var diff = d - start;
	        var oneDay = 1000 * 60 * 60 * 24;
	        return Math.round(diff / oneDay);
	      }
	      return undefined;
	    },
	
	    /**
	     * Returns the day of the month for a date as a number between 1 and 31.
	     * @param obj
	     * @param expr
	     */
	    $dayOfMonth: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getDate() : undefined;
	    },
	
	    /**
	     * Returns the day of the week for a date as a number between 1 (Sunday) and 7 (Saturday).
	     * @param obj
	     * @param expr
	     */
	    $dayOfWeek: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getDay() + 1 : undefined;
	    },
	
	    /**
	     * Returns the year for a date as a number (e.g. 2014).
	     * @param obj
	     * @param expr
	     */
	    $year: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getFullYear() : undefined;
	    },
	
	    /**
	     * Returns the month for a date as a number between 1 (January) and 12 (December).
	     * @param obj
	     * @param expr
	     */
	    $month: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getMonth() + 1 : undefined;
	    },
	
	    /**
	     * Returns the week number for a date as a number between 0
	     * (the partial week that precedes the first Sunday of the year) and 53 (leap year).
	     * @param obj
	     * @param expr
	     */
	    $week: function (obj, expr) {
	      // source: http://stackoverflow.com/a/6117889/1370481
	      var d = computeValue(obj, expr, null);
	
	      // Copy date so don't modify original
	      d = new Date(+d);
	      d.setHours(0, 0, 0);
	      // Set to nearest Thursday: current date + 4 - current day number
	      // Make Sunday's day number 7
	      d.setDate(d.getDate() + 4 - (d.getDay() || 7));
	      // Get first day of year
	      var yearStart = new Date(d.getFullYear(), 0, 1);
	      // Calculate full weeks to nearest Thursday
	      return Math.floor(( ( (d - yearStart) / 8.64e7) + 1) / 7);
	    },
	
	    /**
	     * Returns the hour for a date as a number between 0 and 23.
	     * @param obj
	     * @param expr
	     */
	    $hour: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getHours() : undefined;
	    },
	
	    /**
	     * Returns the minute for a date as a number between 0 and 59.
	     * @param obj
	     * @param expr
	     */
	    $minute: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getMinutes() : undefined;
	    },
	
	    /**
	     * Returns the seconds for a date as a number between 0 and 60 (leap seconds).
	     * @param obj
	     * @param expr
	     */
	    $second: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getSeconds() : undefined;
	    },
	
	    /**
	     * Returns the milliseconds of a date as a number between 0 and 999.
	     * @param obj
	     * @param expr
	     */
	    $millisecond: function (obj, expr) {
	      var d = computeValue(obj, expr, null);
	      return _.isDate(d) ? d.getMilliseconds() : undefined;
	    },
	
	    /**
	     * Returns the date as a formatted string.
	     *
	     * %Y  Year (4 digits, zero padded)  0000-9999
	     * %m  Month (2 digits, zero padded)  01-12
	     * %d  Day of Month (2 digits, zero padded)  01-31
	     * %H  Hour (2 digits, zero padded, 24-hour clock)  00-23
	     * %M  Minute (2 digits, zero padded)  00-59
	     * %S  Second (2 digits, zero padded)  00-60
	     * %L  Millisecond (3 digits, zero padded)  000-999
	     * %j  Day of year (3 digits, zero padded)  001-366
	     * %w  Day of week (1-Sunday, 7-Saturday)  1-7
	     * %U  Week of year (2 digits, zero padded)  00-53
	     * %%  Percent Character as a Literal  %
	     *
	     * @param obj current object
	     * @param expr operator expression
	     */
	    $dateToString: function (obj, expr) {
	
	      var fmt = expr['format'];
	      var date = computeValue(obj, expr['date'], null);
	      var matches = fmt.match(/(%%|%Y|%m|%d|%H|%M|%S|%L|%j|%w|%U)/g);
	
	      for (var i = 0, len = matches.length; i < len; i++) {
	        var hdlr = DATE_SYM_TABLE[matches[i]];
	        var value = hdlr;
	
	        if (_.isArray(hdlr)) {
	          // reuse date operators
	          var fn = this[hdlr[0]];
	          var pad = hdlr[1];
	          value = padDigits(fn.call(this, obj, date), pad);
	        }
	        // replace the match with resolved value
	        fmt = fmt.replace(matches[i], value);
	      }
	
	      return fmt;
	    }
	  };
	
	  var setOperators = {
	    /**
	     * Returns true if two sets have the same elements.
	     * @param obj
	     * @param expr
	     */
	    $setEquals: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      var first = _.uniq(args[0]);
	      var second = _.uniq(args[1]);
	      if (first.length !== second.length) {
	        return false;
	      }
	      return _.difference(first, second).length == 0;
	    },
	
	    /**
	     * Returns the common elements of the input sets.
	     * @param obj
	     * @param expr
	     */
	    $setIntersection: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return _.intersection(args[0], args[1]);
	    },
	
	    /**
	     * Returns elements of a set that do not appear in a second set.
	     * @param obj
	     * @param expr
	     */
	    $setDifference: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return _.difference(args[0], args[1]);
	    },
	
	    /**
	     * Returns a set that holds all elements of the input sets.
	     * @param obj
	     * @param expr
	     */
	    $setUnion: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return _.union(args[0], args[1]);
	    },
	
	    /**
	     * Returns true if all elements of a set appear in a second set.
	     * @param obj
	     * @param expr
	     */
	    $setIsSubset: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return _.intersection(args[0], args[1]).length === args[0].length;
	    },
	
	    /**
	     * Returns true if any elements of a set evaluate to true, and false otherwise.
	     * @param obj
	     * @param expr
	     */
	    $anyElementTrue: function (obj, expr) {
	      // mongodb nests the array expression in another
	      var args = computeValue(obj, expr, null)[0];
	      for (var i = 0; i < args.length; i++) {
	        if (!!args[i])
	          return true;
	      }
	      return false;
	    },
	
	    /**
	     * Returns true if all elements of a set evaluate to true, and false otherwise.
	     * @param obj
	     * @param expr
	     */
	    $allElementsTrue: function (obj, expr) {
	      // mongodb nests the array expression in another
	      var args = computeValue(obj, expr, null)[0];
	      for (var i = 0; i < args.length; i++) {
	        if (!args[i])
	          return false;
	      }
	      return true;
	    }
	  };
	
	  var conditionalOperators = {
	
	    /**
	     * A ternary operator that evaluates one expression,
	     * and depending on the result returns the value of one following expressions.
	     *
	     * @param obj
	     * @param expr
	     */
	    $cond: function (obj, expr) {
	      var ifExpr, thenExpr, elseExpr;
	      if (_.isArray(expr)) {
	        if (expr.length != 3) {
	          throw new Error("Invalid arguments for $cond operator");
	        }
	        ifExpr = expr[0];
	        thenExpr = expr[1];
	        elseExpr = expr[2];
	      } else if (_.isObject(expr)) {
	        ifExpr = expr['if'];
	        thenExpr = expr['then'];
	        elseExpr = expr['else'];
	      }
	      var condition = computeValue(obj, ifExpr, null);
	      return condition ? computeValue(obj, thenExpr, null) : computeValue(obj, elseExpr, null);
	    },
	
	    /**
	     * Evaluates an expression and returns the first expression if it evaluates to a non-null value.
	     * Otherwise, $ifNull returns the second expression's value.
	     *
	     * @param obj
	     * @param expr
	     * @returns {*}
	     */
	    $ifNull: function (obj, expr) {
	      if (!_.isArray(expr) || expr.length != 2) {
	        throw new Error("Invalid arguments for $ifNull operator");
	      }
	      var args = computeValue(obj, expr, null);
	      return (args[0] === null || args[0] === undefined) ? args[1] : args[0];
	    }
	  };
	
	  var comparisonOperators = {
	    /**
	     * Compares two values and returns the result of the comparison as an integer.
	     *
	     * @param obj
	     * @param expr
	     * @returns {number}
	     */
	    $cmp: function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      if (args[0] > args[1]) {
	        return 1;
	      }
	      return (args[0] < args[1]) ? -1 : 0;
	    }
	  };
	  // mixin comparison operators
	  _.each(["$eq", "$ne", "$gt", "$gte", "$lt", "$lte"], function (op) {
	    comparisonOperators[op] = function (obj, expr) {
	      var args = computeValue(obj, expr, null);
	      return simpleOperators[op](args[0], args[1]);
	    };
	  });
	
	  var arrayOperators = {
	    /**
	     * Counts and returns the total the number of items in an array.
	     * @param obj
	     * @param expr
	     */
	    $size: function (obj, expr) {
	      var value = computeValue(obj, expr, null);
	      return _.isArray(value) ? value.length : undefined;
	    }
	  };
	
	  var literalOperators = {
	    /**
	     * Return a value without parsing.
	     * @param obj
	     * @param expr
	     */
	    $literal: function (obj, expr) {
	      return expr;
	    }
	  };
	
	
	  var variableOperators = {
	    /**
	     * Applies a subexpression to each element of an array and returns the array of resulting values in order.
	     * @param obj
	     * @param expr
	     * @returns {Array|*}
	     */
	    $map: function (obj, expr) {
	      var inputExpr = computeValue(obj, expr["input"], null);
	      if (!_.isArray(inputExpr)) {
	        throw new Error("Input expression for $map must resolve to an array");
	      }
	      var asExpr = expr["as"];
	      var inExpr = expr["in"];
	
	      // HACK: add the "as" expression as a value on the object to take advantage of "resolve()"
	      // which will reduce to that value when invoked. The reference to the as expression will be prefixed with "$$".
	      // But since a "$" is stripped of before passing the name to "resolve()" we just need to prepend "$" to the key.
	      var tempKey = "$" + asExpr;
	      // let's save any value that existed, kinda useless but YOU CAN NEVER BE TOO SURE, CAN YOU :)
	      var original = obj[tempKey];
	      return _.map(inputExpr, function (item) {
	        obj[tempKey] = item;
	        var value = computeValue(obj, inExpr, null);
	        // cleanup and restore
	        if (_.isUndefined(original)) {
	          delete obj[tempKey];
	        } else {
	          obj[tempKey] = original;
	        }
	        return value;
	      });
	
	    },
	
	    /**
	     * Defines variables for use within the scope of a subexpression and returns the result of the subexpression.
	     * @param obj
	     * @param expr
	     * @returns {*}
	     */
	    $let: function (obj, expr) {
	      var varsExpr = expr["vars"];
	      var inExpr = expr["in"];
	
	      // resolve vars
	      var originals = {};
	      var varsKeys = _.keys(varsExpr);
	      _.each(varsKeys, function (key) {
	        var val = computeValue(obj, varsExpr[key], null);
	        var tempKey = "$" + key;
	        // set value on object using same technique as in "$map"
	        originals[tempKey] = obj[tempKey];
	        obj[tempKey] = val;
	      });
	
	      var value = computeValue(obj, inExpr, null);
	
	      // cleanup and restore
	      _.each(varsKeys, function (key) {
	        var tempKey = "$" + key;
	        if (_.isUndefined(originals[tempKey])) {
	          delete obj[tempKey];
	        } else {
	          obj[tempKey] = originals[tempKey];
	        }
	      });
	
	      return value;
	    }
	  };
	
	  var booleanOperators = {
	    /**
	     * Returns true only when all its expressions evaluate to true. Accepts any number of argument expressions.
	     * @param obj
	     * @param expr
	     * @returns {boolean}
	     */
	    $and: function (obj, expr) {
	      var value = computeValue(obj, expr, null);
	      return _.every(value);
	    },
	
	    /**
	     * Returns true when any of its expressions evaluates to true. Accepts any number of argument expressions.
	     * @param obj
	     * @param expr
	     * @returns {boolean}
	     */
	    $or: function (obj, expr) {
	      var value = computeValue(obj, expr, null);
	      return _.some(value);
	    },
	
	    /**
	     * Returns the boolean value that is the opposite of its argument expression. Accepts a single argument expression.
	     * @param obj
	     * @param expr
	     * @returns {boolean}
	     */
	    $not: function (obj, expr) {
	      return !computeValue(obj, expr[0], null);
	    }
	  };
	
	  // combine aggregate operators
	  var aggregateOperators = _.extend(
	    {},
	    arrayOperators,
	    arithmeticOperators,
	    booleanOperators,
	    comparisonOperators,
	    conditionalOperators,
	    dateOperators,
	    literalOperators,
	    setOperators,
	    stringOperators,
	    variableOperators
	  );
	
	  var OP_QUERY = Mingo.OP_QUERY = 'query',
	    OP_GROUP = Mingo.OP_GROUP = 'group',
	    OP_AGGREGATE = Mingo.OP_AGGREGATE = 'aggregate',
	    OP_PIPELINE = Mingo.OP_PIPELINE = 'pipeline',
	    OP_PROJECTION = Mingo.OP_PROJECTION = 'projection';
	
	  // operator definitions
	  var OPERATORS = {
	    'aggregate': aggregateOperators,
	    'group': groupOperators,
	    'pipeline': pipelineOperators,
	    'projection': projectionOperators,
	    'query': queryOperators
	  };
	
	  // used for formatting dates in $dateToString operator
	  var DATE_SYM_TABLE = {
	    '%Y': ['$year', 4],
	    '%m': ['$month', 2],
	    '%d': ['$dayOfMonth', 2],
	    '%H': ['$hour', 2],
	    '%M': ['$minute', 2],
	    '%S': ['$second', 2],
	    '%L': ['$millisecond', 3],
	    '%j': ['$dayOfYear', 3],
	    '%w': ['$dayOfWeek', 1],
	    '%U': ['$week', 2],
	    '%%': '%'
	  };
	
	  function padDigits(number, digits) {
	    return new Array(Math.max(digits - String(number).length + 1, 0)).join('0') + number;
	  }
	
	  /**
	   * Return the registered operators on the given operator category
	   * @param type catgory of operators
	   * @returns {*}
	   */
	  function ops(type) {
	    return _.keys(OPERATORS[type]);
	  }
	
	  /**
	   * Groups the collection into sets by the returned key
	   *
	   * @param collection
	   * @param fn
	   */
	  function groupBy(collection, fn) {
	
	    var result = {
	      'keys': [],
	      'groups': []
	    };
	
	    _.each(collection, function (obj) {
	
	      var key = fn(obj);
	      var index = -1;
	
	      if (_.isObject(key)) {
	        for (var i = 0; i < result.keys.length; i++) {
	          if (_.isEqual(key, result.keys[i])) {
	            index = i;
	            break;
	          }
	        }
	      } else {
	        index = _.indexOf(result.keys, key);
	      }
	
	      if (index > -1) {
	        result.groups[index].push(obj);
	      } else {
	        result.keys.push(key);
	        result.groups.push([obj]);
	      }
	    });
	
	    // assert this
	    if (result.keys.length !== result.groups.length) {
	      throw new Error("assert groupBy(): keys.length !== groups.length");
	    }
	
	    return result;
	  }
	
	  /**
	   * Returns the result of evaluating a $group operation over a collection
	   *
	   * @param collection
	   * @param field the name of the aggregate operator or field
	   * @param expr the expression of the aggregate operator for the field
	   * @returns {*}
	   */
	  function accumulate(collection, field, expr) {
	    if (_.contains(ops(OP_GROUP), field)) {
	      return groupOperators[field](collection, expr);
	    }
	
	    if (_.isObject(expr)) {
	      var result = {};
	      for (var key in expr) {
	        if (expr.hasOwnProperty(key)) {
	          result[key] = accumulate(collection, key, expr[key]);
	          // must run ONLY one group operator per expression
	          // if so, return result of the computed value
	          if (_.contains(ops(OP_GROUP), key)) {
	            result = result[key];
	            // if there are more keys in expression this is bad
	            if (_.keys(expr).length > 1) {
	              throw new Error("Invalid $group expression '" + JSON.stringify(expr) + "'");
	            }
	            break;
	          }
	        }
	      }
	      return result;
	    }
	
	    return undefined;
	  }
	
	  /**
	   * Computes the actual value of the expression using the given object as context
	   *
	   * @param obj the current object from the collection
	   * @param expr the expression for the given field
	   * @param field the field name (may also be an aggregate operator)
	   * @returns {*}
	   */
	  function computeValue(obj, expr, field) {
	
	    // if the field of the object is a valid operator
	    if (_.contains(ops(OP_AGGREGATE), field)) {
	      return aggregateOperators[field](obj, expr);
	    }
	
	    // if expr is a variable for an object field
	    // field not used in this case
	    if (_.isString(expr) && expr.length > 0 && expr[0] === "$") {
	      return resolve(obj, expr.slice(1));
	    }
	
	    var result;
	
	    // check and return value if already in a resolved state
	    if (isPrimitive(expr)) {
	      return expr;
	    } else if (_.isArray(expr)) {
	      result = _.map(expr, function (item) {
	        return computeValue(obj, item, null);
	      });
	    } else if (_.isObject(expr)) {
	      result = {};
	      for (var key in expr) {
	        if (expr.hasOwnProperty(key)) {
	          result[key] = computeValue(obj, expr[key], key);
	
	          // must run ONLY one aggregate operator per expression
	          // if so, return result of the computed value
	          if (_.contains(ops(OP_AGGREGATE), key)) {
	            result = result[key];
	            // if there are more keys in expression this is bad
	            if (_.keys(expr).length > 1) {
	              throw new Error("Invalid aggregation expression '" + JSON.stringify(expr) + "'");
	            }
	            break;
	          }
	        }
	      }
	    }
	
	    return result;
	  }
	
	}(this));


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var ops = __webpack_require__(155);
	var eql = __webpack_require__(89);
	var dot = __webpack_require__(87);
	var type = __webpack_require__(25);
	var object = __webpack_require__(90);
	var debug = __webpack_require__(86)('mongo-query');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = filter;
	exports.ops = ops;
	
	/**
	 * Filters an `obj` by the given `query` for subdocuments.
	 *
	 * @return {Object|Boolean} false if no match, or matched subdocs
	 * @api public
	 */
	
	function filter(obj, query){
	  obj = obj || {};
	  var ret = {};
	
	  for (var key in query) {
	    if (!query.hasOwnProperty(key)) continue;
	
	    // search value
	    var val = query[key];
	
	    // split the key into prefix and suffix
	    var keys = key.split('.');
	    var target = obj;
	    var prefix, search;
	    var matches = [];
	
	    walk_keys:
	    for (var i = 0; i < keys.length; i++) {
	      target = target[keys[i]];
	
	      switch (type(target)) {
	        case 'array':
	          // if it's an array subdocument search we stop here
	          prefix = keys.slice(0, i + 1).join('.');
	          search = keys.slice(i + 1).join('.');
	
	          debug('searching array "%s"', prefix);
	
	          // we special case operators that don't walk the array
	          if (val.$size && !search.length) {
	            return compare(val, target);
	          }
	
	          // walk subdocs
	          var subset = ret[prefix] || target;
	
	          for (var ii = 0; ii < subset.length; ii++) {
	            if (search.length) {
	              var q = {};
	              q[search] = val;
	              if ('object' == type(subset[ii])) {
	                debug('attempting subdoc search with query %j', q);
	                if (filter(subset[ii], q)) {
	                  // we ignore the ret value of filter
	                  if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
	                    matches.push(subset[ii]);
	                  }
	                }
	              }
	            } else {
	              debug('performing simple array item search');
	              if (compare(val, subset[ii])) {
	                if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
	                  matches.push(subset[ii]);
	                }
	              }
	            }
	          }
	
	          if (matches.length) {
	            ret[prefix] = ret[prefix] || [];
	            ret[prefix].push.apply(ret[prefix], matches);
	          }
	
	          // we don't continue the key search
	          break walk_keys;
	
	        case 'undefined':
	          // if we can't find the key
	          return false;
	
	        case 'object':
	          if (null != keys[i + 1]) {
	            continue;
	          } else if (!compare(val, target)) {
	            return false;
	          }
	          break;
	
	        default:
	          if (!compare(val, target)) return false;
	      }
	    }
	  }
	
	  return ret;
	}
	
	/**
	 * Compares the given matcher with the document value.
	 *
	 * @param {Mixed} matcher
	 * @param {Mixed} value
	 * @api private
	 */
	
	function compare(matcher, val){
	  if ('object' != type(matcher)) {
	    return eql(matcher, val);
	  }
	
	  var keys = object.keys(matcher);
	  if ('$' == keys[0][0]) {
	    for (var i = 0; i < keys.length; i++) {
	      // special case for sub-object matching
	      if ('$elemMatch' == keys[i]) {
	        return false !== filter(val, matcher.$elemMatch);
	      } else {
	        if (!ops[keys[i]](matcher[keys[i]], val)) return false;
	      }
	    }
	    return true;
	  } else {
	    return eql(matcher, val);
	  }
	}


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var mods = __webpack_require__(154);
	var filter = __webpack_require__(152);
	var dot = __webpack_require__(87);
	var type = __webpack_require__(25);
	var object = __webpack_require__(90);
	var debug = __webpack_require__(86)('mongo-query');
	
	/**
	 * Module exports.
	 */
	
	module.exports = exports = query;
	
	/**
	 * Export filter helper.
	 */
	
	exports.filter = filter;
	
	/**
	 * Export modifiers.
	 */
	
	exports.mods = mods;
	
	/**
	 * Execute a query.
	 *
	 * Options:
	 *  - `strict` only modify if query matches
	 *
	 * @param {Object} object to alter
	 * @param {Object} query to filter modifications by
	 * @param {Object} update object
	 * @param {Object} options
	 */
	
	function query(obj, query, update, opts){
	  obj = obj || {};
	  opts = opts || {};
	  query = query || {};
	  update = update || {};
	
	  // strict mode
	  var strict = !!opts.strict;
	
	  var match;
	  var log = [];
	
	  if (object.length(query)) {
	    match = filter(obj, query);
	  }
	
	  if (!strict || false !== match) {
	    var keys = object.keys(update);
	    var transactions = [];
	
	    for (var i = 0, l = keys.length; i < l; i++) {
	      if (mods[keys[i]]) {
	        debug('found modifier "%s"', keys[i]);
	        for (var key in update[keys[i]]) {
	          var pos = key.indexOf('.$.');
	
	          if (~pos) {
	            var prefix = key.substr(0, pos);
	            var suffix = key.substr(pos + 3);
	
	            if (match[prefix]) {
	              debug('executing "%s" %s on first match within "%s"', key, keys[i], prefix);
	              var fn = mods[keys[i]](match[prefix][0], suffix, update[keys[i]][key]);
	              if (fn) {
	                // produce a key name replacing $ with the actual index
	                // TODO: this is unnecessarily expensive
	                var index = dot.get(obj, prefix).indexOf(match[prefix][0]);
	                fn.key = prefix + '.' + index + '.' + suffix;
	                fn.op = keys[i];
	                transactions.push(fn);
	              }
	            } else {
	              debug('ignoring "%s" %s - no matches within "%s"', key, keys[i], prefix);
	            }
	          } else {
	            var fn = mods[keys[i]](obj, key, update[keys[i]][key]);
	            if (fn) {
	              fn.key = key;
	              fn.op = keys[i];
	              transactions.push(fn);
	            }
	          }
	        }
	      } else {
	        debug('skipping unknown modifier "%s"', keys[i]);
	      }
	    }
	
	    if (transactions.length) {
	      // if we got here error free we process all transactions
	      for (var i = 0; i < transactions.length; i++) {
	        var fn = transactions[i];
	        var val = fn();
	        log.push({ op: fn.op, key: fn.key, value: val });
	      }
	    }
	  } else {
	    debug('no matches for query %j', query);
	  }
	
	  return log;
	}


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var eql = __webpack_require__(89);
	var dot = __webpack_require__(87);
	var type = __webpack_require__(25);
	var keys = __webpack_require__(90).keys;
	var debug = __webpack_require__(86)('mongo-query');
	
	/**
	 * Performs a `$set`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {String} value to set
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$set = function $set(obj, path, val){
	  var key = path.split('.').pop();
	  obj = dot.parent(obj, path, true);
	
	  switch (type(obj)) {
	    case 'object':
	      if (!eql(obj[key], val)) {
	        return function(){
	          obj[key] = val;
	          return val;
	        };
	      }
	      break;
	
	    case 'array':
	      if (numeric(key)) {
	        if (!eql(obj[key], val)) {
	          return function(){
	            obj[key] = val;
	            return val;
	          };
	        }
	      } else {
	        throw new Error('can\'t append to array using string field name [' + key + ']');
	      }
	      break;
	
	    default:
	      throw new Error('$set only supports object not ' + type(obj));
	  }
	};
	
	/**
	 * Performs an `$unset`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {String} value to set
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$unset = function $unset(obj, path){
	  var key = path.split('.').pop();
	  obj = dot.parent(obj, path);
	
	  switch (type(obj)) {
	    case 'array':
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        return function(){
	          // reminder: `delete arr[1]` === `delete arr['1']` [!]
	          delete obj[key];
	        };
	      } else {
	        // we fail silently
	        debug('ignoring unset of inexisting key');
	      }
	  }
	};
	
	/**
	 * Performs a `$rename`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {String} value to set
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$rename = function $rename(obj, path, newKey){
	  // target = source
	  if (path == newKey) {
	    throw new Error('$rename source must differ from target');
	  }
	
	  // target is parent of source
	  if (0 === path.indexOf(newKey + '.')) {
	    throw new Error('$rename target may not be a parent of source');
	  }
	
	  var p = dot.parent(obj, path);
	  var t = type(p);
	
	  if ('object' == t) {
	    var key = path.split('.').pop();
	
	    if (p.hasOwnProperty(key)) {
	      return function(){
	        var val = p[key];
	        delete p[key];
	
	        // target does initialize the path
	        var newp = dot.parent(obj, newKey, true);
	
	        // and also fails silently upon type mismatch
	        if ('object' == type(newp)) {
	          newp[newKey.split('.').pop()] = val;
	        } else {
	          debug('invalid $rename target path type');
	        }
	
	        // returns the name of the new key
	        return newKey;
	      };
	    } else {
	      debug('ignoring rename from inexisting source');
	    }
	  } else if ('undefined' != t) {
	    throw new Error('$rename source field invalid');
	  }
	};
	
	/**
	 * Performs an `$inc`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {String} value to set
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$inc = function $inc(obj, path, inc){
	  if ('number' != type(inc)) {
	    throw new Error('Modifier $inc allowed for numbers only');
	  }
	
	  obj = dot.parent(obj, path, true);
	  var key = path.split('.').pop();
	
	  switch (type(obj)) {
	    case 'array':
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        if ('number' != type(obj[key])) {
	          throw new Error('Cannot apply $inc modifier to non-number');
	        }
	
	        return function(){
	          obj[key] += inc;
	          return inc;
	        };
	      } else if('object' == type(obj) || numeric(key)){
	        return function(){
	          obj[key] = inc;
	          return inc;
	        };
	      } else {
	        throw new Error('can\'t append to array using string field name [' + key + ']');
	      }
	      break;
	
	    default:
	      throw new Error('Cannot apply $inc modifier to non-number');
	  }
	};
	
	/**
	 * Performs an `$pop`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {String} value to set
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$pop = function $pop(obj, path, val){
	  obj = dot.parent(obj, path);
	  var key = path.split('.').pop();
	
	  // we make sure the array is not just the parent of the main key
	  switch (type(obj)) {
	    case 'array':
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        switch (type(obj[key])) {
	          case 'array':
	            if (obj[key].length) {
	              return function(){
	                if (-1 == val) {
	                  return obj[key].shift();
	                } else {
	                  // mongodb allows any value to pop
	                  return obj[key].pop();
	                }
	              };
	            }
	            break;
	
	          case 'undefined':
	            debug('ignoring pop to inexisting key');
	            break;
	
	          default:
	            throw new Error('Cannot apply $pop modifier to non-array');
	        }
	      } else {
	        debug('ignoring pop to inexisting key');
	      }
	      break;
	
	    case 'undefined':
	      debug('ignoring pop to inexisting key');
	      break;
	  }
	};
	
	/**
	 * Performs a `$push`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {Object} value to push
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$push = function $push(obj, path, val){
	  obj = dot.parent(obj, path, true);
	  var key = path.split('.').pop();
	
	  switch (type(obj)) {
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          return function(){
	            obj[key].push(val);
	            return val;
	          };
	        } else {
	          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
	        }
	      } else {
	        return function(){
	          obj[key] = [val];
	          return val;
	        };
	      }
	      break;
	
	    case 'array':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          return function(){
	            obj[key].push(val);
	            return val;
	          };
	        } else {
	          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
	        }
	      } else if (numeric(key)) {
	        return function(){
	          obj[key] = [val];
	          return val;
	        };
	      } else {
	        throw new Error('can\'t append to array using string field name [' + key + ']');
	      }
	      break;
	  }
	};
	
	/**
	 * Performs a `$pushAll`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {Array} values to push
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$pushAll = function $pushAll(obj, path, val){
	  if ('array' != type(val)) {
	    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
	  }
	
	  obj = dot.parent(obj, path, true);
	  var key = path.split('.').pop();
	
	  switch (type(obj)) {
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          return function(){
	            obj[key].push.apply(obj[key], val);
	            return val;
	          };
	        } else {
	          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
	        }
	      } else {
	        return function(){
	          obj[key] = val;
	          return val;
	        };
	      }
	      break;
	
	    case 'array':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          return function(){
	            obj[key].push.apply(obj[key], val);
	            return val;
	          };
	        } else {
	          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
	        }
	      } else if (numeric(key)) {
	        return function(){
	          obj[key] = val;
	          return val;
	        };
	      } else {
	        throw new Error('can\'t append to array using string field name [' + key + ']');
	      }
	      break;
	  }
	};
	
	/**
	 * Performs a `$pull`.
	 */
	
	exports.$pull = function $pull(obj, path, val){
	  obj = dot.parent(obj, path, true);
	  var key = path.split('.').pop();
	  var t = type(obj);
	
	  switch (t) {
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          var pulled = [];
	          var splice = pull(obj[key], [val], pulled);
	          if (pulled.length) {
	            return function(){
	              splice();
	              return pulled;
	            };
	          }
	        } else {
	          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
	        }
	      }
	      break;
	
	    case 'array':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          var pulled = [];
	          var splice = pull(obj[key], [val], pulled);
	          if (pulled.length) {
	            return function(){
	              splice();
	              return pulled;
	            };
	          }
	        } else {
	          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
	        }
	      } else {
	        debug('ignoring pull to non array');
	      }
	      break;
	
	    default:
	      if ('undefined' != t) {
	        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
	      }
	  }
	};
	
	/**
	 * Performs a `$pullAll`.
	 */
	
	exports.$pullAll = function $pullAll(obj, path, val){
	  if ('array' != type(val)) {
	    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
	  }
	
	  obj = dot.parent(obj, path, true);
	  var key = path.split('.').pop();
	  var t = type(obj);
	
	  switch (t) {
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          var pulled = [];
	          var splice = pull(obj[key], val, pulled);
	          if (pulled.length) {
	            return function(){
	              splice();
	              return pulled;
	            };
	          }
	        } else {
	          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
	        }
	      }
	      break;
	
	    case 'array':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          var pulled = [];
	          var splice = pull(obj[key], val, pulled);
	          if (pulled.length) {
	            return function(){
	              splice();
	              return pulled;
	            };
	          }
	        } else {
	          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
	        }
	      } else {
	        debug('ignoring pull to non array');
	      }
	      break;
	
	    default:
	      if ('undefined' != t) {
	        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
	      }
	  }
	};
	
	/**
	 * Performs a `$addToSet`.
	 *
	 * @param {Object} object to modify
	 * @param {String} path to alter
	 * @param {Object} value to push
	 * @param {Boolean} internal, true if recursing
	 * @return {Function} transaction (unless noop)
	 */
	
	exports.$addToSet = function $addToSet(obj, path, val, recursing){
	  if (!recursing && 'array' == type(val.$each)) {
	    var fns = [];
	    for (var i = 0, l = val.$each.length; i < l; i++) {
	      var fn = $addToSet(obj, path, val.$each[i], true);
	      if (fn) fns.push(fn);
	    }
	    if (fns.length) {
	      return function(){
	        var values = [];
	        for (var i = 0; i < fns.length; i++) values.push(fns[i]());
	        return values;
	      };
	    } else {
	      return;
	    }
	  }
	
	  obj = dot.parent(obj, path, true);
	  var key = path.split('.').pop();
	
	  switch (type(obj)) {
	    case 'object':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          if (!has(obj[key], val)) {
	            return function(){
	              obj[key].push(val);
	              return val;
	            };
	          }
	        } else {
	          throw new Error('Cannot apply $addToSet modifier to non-array');
	        }
	      } else {
	        return function(){
	          obj[key] = [val];
	          return val;
	        };
	      }
	      break;
	
	    case 'array':
	      if (obj.hasOwnProperty(key)) {
	        if ('array' == type(obj[key])) {
	          if (!has(obj[key], val)) {
	            return function(){
	              obj[key].push(val);
	              return val;
	            };
	          }
	        } else {
	          throw new Error('Cannot apply $addToSet modifier to non-array');
	        }
	      } else if (numeric(key)) {
	        return function(){
	          obj[key] = [val];
	          return val;
	        };
	      } else {
	        throw new Error('can\'t append to array using string field name [' + key + ']');
	      }
	      break;
	  }
	};
	
	/**
	 * Helper for determining if an array has the given value.
	 *
	 * @param {Array} array
	 * @param {Object} value to check
	 * @return {Boolean}
	 */
	
	function has(array, val){
	  for (var i = 0, l = array.length; i < l; i++) {
	    if (eql(val, array[i])) return true;
	  }
	  return false;
	}
	
	/**
	 * Array#filter function generator for `$pull`/`$pullAll` operations.
	 *
	 * @param {Array} array of values to match
	 * @param {Array} array to populate with results
	 * @return {Function} that splices the array
	 */
	
	function pull(arr, vals, pulled){
	  var indexes = [];
	
	  for (var a = 0; a < arr.length; a++) {
	    var val = arr[a];
	
	    for (var i = 0; i < vals.length; i++) {
	      var matcher = vals[i];
	      if ('object' == type(matcher)) {
	        // we only are only interested in obj <-> obj comparisons
	        if ('object' == type(val)) {
	          var match = false;
	
	          if (keys(matcher).length) {
	            for (var i in matcher) {
	              if (matcher.hasOwnProperty(i)) {
	                // we need at least one matching key to pull
	                if (eql(matcher[i], val[i])) {
	                  match = true;
	                } else {
	                  // if a single key doesn't match we move on
	                  match = false;
	                  break;
	                }
	              }
	            }
	          } else if (!keys(val).length) {
	            // pull `{}` matches [{}]
	            match = true;
	          }
	
	          if (match) {
	            indexes.push(a);
	            pulled.push(val);
	            continue;
	          }
	        } else {
	          debug('ignoring pull match against object');
	        }
	      } else {
	        if (eql(matcher, val)) {
	          indexes.push(a);
	          pulled.push(val);
	          continue;
	        }
	      }
	    }
	  }
	
	  return function(){
	    for (var i = 0; i < indexes.length; i++) {
	      var index = indexes[i];
	      arr.splice(index - i, 1);
	    }
	  };
	}
	
	/**
	 * Helper to determine if a value is numeric.
	 *
	 * @param {String|Number} value
	 * @return {Boolean} true if numeric
	 * @api private
	 */
	
	function numeric(val){
	  return 'number' == type(val) || Number(val) == val;
	}


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var eql = __webpack_require__(89);
	var type = __webpack_require__(25);
	
	/**
	 * $ne: not equal.
	 */
	
	exports.$ne = function $ne(matcher, val){
	  return !eql(matcher, val);
	};
	
	/**
	 * $gt: greater than.
	 */
	
	exports.$gt = function $gt(matcher, val){
	  return type(matcher) === 'number' && val > matcher;
	};
	
	/**
	 * $gte: greater than equal.
	 */
	
	exports.$gte = function $gte(matcher, val){
	  return type(matcher) === 'number' && val >= matcher;
	};
	
	/**
	 * $lt: less than.
	 */
	
	exports.$lt = function $lt(matcher, val){
	  return type(matcher) === 'number' && val < matcher;
	};
	
	/**
	 * $lte: less than equal.
	 */
	
	exports.$lte = function $lte(matcher, val){
	  return type(matcher) === 'number' && val <= matcher;
	};
	
	/**
	 * $regex: supply a regular expression as a string.
	 */
	
	exports.$regex = function $regex(matcher, val){
	  // TODO: add $options support
	  if ('regexp' != type('matcher')) matcher = new RegExp(matcher);
	  return matcher.test(val);
	};
	
	/**
	 * $exists: key exists.
	 */
	
	exports.$exists = function $exists(matcher, val){
	  if (matcher) {
	    return undefined !== val;
	  } else {
	    return undefined === val;
	  }
	};
	
	/**
	 * $in: value in array.
	 */
	
	exports.$in = function $in(matcher, val){
	  if ('array' != type(matcher)) return false;
	  for (var i = 0; i < matcher.length; i++) {
	    if (eql(matcher[i], val)) return true;
	  }
	  return false;
	};
	
	/**
	 * $nin: value not in array.
	 */
	
	exports.$nin = function $nin(matcher, val){
	  return !exports.$in(matcher, val);
	};
	
	/**
	 * @size: array length
	 */
	
	exports.$size = function(matcher, val){
	  return Array.isArray(val) && matcher == val.length;
	};


/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var CryptoJS = __webpack_require__(12).CryptoJS;
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;
	
	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];
	
	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }
	
	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;
	
	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];
	
	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;
	
	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;
	
	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());
	
	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	
	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;
	
	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6
	
	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;
	
	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];
	
	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);
	
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	
	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }
	
	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }
	
	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;
	
	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }
	
	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },
	
	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },
	
	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	
	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
	
	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },
	
	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;
	
	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];
	
	            // Key schedule row counter
	            var ksRow = 4;
	
	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];
	
	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }
	
	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
	
	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },
	
	        keySize: 256/32
	    });
	
	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var CryptoJS = __webpack_require__(12).CryptoJS;
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;
	
	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),
	
	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },
	
	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },
	
	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);
	
	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;
	
	            // Set initial values
	            this.reset();
	        },
	
	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);
	
	            // Perform concrete-cipher logic
	            this._doReset();
	        },
	
	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);
	
	            // Process available blocks
	            return this._process();
	        },
	
	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }
	
	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();
	
	            return finalProcessedData;
	        },
	
	        keySize: 128/32,
	
	        ivSize: 128/32,
	
	        _ENC_XFORM_MODE: 1,
	
	        _DEC_XFORM_MODE: 2,
	
	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }
	
	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },
	
	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });
	
	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');
	
	            return finalProcessedBlocks;
	        },
	
	        blockSize: 1
	    });
	
	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};
	
	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },
	
	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },
	
	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });
	
	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();
	
	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;
	
	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);
	
	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });
	
	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;
	
	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);
	
	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);
	
	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });
	
	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;
	
	            // Choose mixing block
	            if (iv) {
	                var block = iv;
	
	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }
	
	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }
	
	        return CBC;
	    }());
	
	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};
	
	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;
	
	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
	
	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;
	
	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);
	
	            // Add padding
	            data.concat(padding);
	        },
	
	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
	
	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };
	
	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),
	
	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);
	
	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;
	
	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }
	            this._mode = modeCreator.call(mode, this, iv && iv.words);
	        },
	
	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },
	
	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;
	
	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);
	
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	
	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }
	
	            return finalProcessedBlocks;
	        },
	
	        blockSize: 128/32
	    });
	
	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },
	
	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });
	
	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};
	
	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;
	
	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }
	
	            return wordArray.toString(Base64);
	        },
	
	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);
	
	            // Shortcut
	            var ciphertextWords = ciphertext.words;
	
	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));
	
	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }
	
	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };
	
	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),
	
	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);
	
	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);
	
	            // Shortcut
	            var cipherCfg = encryptor.cfg;
	
	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },
	
	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);
	
	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);
	
	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
	
	            return plaintext;
	        },
	
	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });
	
	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};
	
	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }
	
	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
	
	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;
	
	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };
	
	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),
	
	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);
	
	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
	
	            // Add IV to config
	            cfg.iv = derivedParams.iv;
	
	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
	
	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);
	
	            return ciphertext;
	        },
	
	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);
	
	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);
	
	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
	
	            // Add IV to config
	            cfg.iv = derivedParams.iv;
	
	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
	
	            return plaintext;
	        }
	    });
	}());


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var CryptoJS = __webpack_require__(12).CryptoJS;
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;
	
	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;
	
	            // Clamp excess bits
	            wordArray.clamp();
	
	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
	
	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
	
	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }
	
	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }
	
	            return base64Chars.join('');
	        },
	
	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	
	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex != -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }
	
	            // Convert
	            var words = [];
	            var nBytes = 0;
	            for (var i = 0; i < base64StrLength; i++) {
	                if (i % 4) {
	                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
	                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
	                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	                    nBytes++;
	                }
	            }
	
	            return WordArray.create(words, nBytes);
	        },
	
	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };
	}());


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var CryptoJS = __webpack_require__(12).CryptoJS;
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;
	
	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),
	
	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },
	
	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;
	
	            // Init hasher
	            var hasher = cfg.hasher.create();
	
	            // Initial values
	            var derivedKey = WordArray.create();
	
	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;
	
	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();
	
	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }
	
	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;
	
	            return derivedKey;
	        }
	    });
	
	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var CryptoJS = __webpack_require__(12).CryptoJS;
	
	// create custom json serialization format
	var JsonFormatter = {
		stringify: function (cipherParams) {
			// create json object with ciphertext
			var jsonObj = {
				ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
			};
			
			// optionally add iv and salt
			if (cipherParams.iv) {
				jsonObj.iv = cipherParams.iv.toString();
			}
			
			if (cipherParams.salt) {
				jsonObj.s = cipherParams.salt.toString();
			}
	
			// stringify json object
			return JSON.stringify(jsonObj)
		},
	
		parse: function (jsonStr) {
			// parse json string
			var jsonObj = JSON.parse(jsonStr);
			
			// extract ciphertext from json object, and create cipher params object
			var cipherParams = CryptoJS.lib.CipherParams.create({
				ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
			});
			
			// optionally extract iv and salt
			if (jsonObj.iv) {
				cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv);
			}
	            
			if (jsonObj.s) {
				cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s);
			}
			
			return cipherParams;
		}
	};
	
	exports.JsonFormatter = JsonFormatter;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var CryptoJS = __webpack_require__(12).CryptoJS;
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;
	
	    // Constants table
	    var T = [];
	
	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());
	
	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },
	
	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];
	
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	
	            // Shortcuts
	            var H = this._hash.words;
	
	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];
	
	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	
	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
	
	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
	
	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);
	
	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);
	
	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },
	
	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	
	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	
	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );
	
	            data.sigBytes = (dataWords.length + 1) * 4;
	
	            // Hash final blocks
	            this._process();
	
	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;
	
	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];
	
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }
	
	            // Return final computed hash
	            return hash;
	        },
	
	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();
	
	            return clone;
	        }
	    });
	
	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }
	
	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }
	
	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }
	
	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }
	
	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);
	
	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(14)


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(24).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(85);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(129)


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(37); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(130);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(93);
	exports.Duplex = __webpack_require__(14);
	exports.Transform = __webpack_require__(92);
	exports.PassThrough = __webpack_require__(129);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(92)


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(93)


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  * Reqwest! A general purpose XHR connection manager
	  * license MIT (c) Dustin Diaz 2014
	  * https://github.com/ded/reqwest
	  */
	
	!function (name, context, definition) {
	  if (typeof module != 'undefined' && module.exports) module.exports = definition()
	  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  else context[name] = definition()
	}('reqwest', this, function () {
	
	  var win = window
	    , doc = document
	    , httpsRe = /^http/
	    , protocolRe = /(^\w+):\/\//
	    , twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
	    , byTag = 'getElementsByTagName'
	    , readyState = 'readyState'
	    , contentType = 'Content-Type'
	    , requestedWith = 'X-Requested-With'
	    , head = doc[byTag]('head')[0]
	    , uniqid = 0
	    , callbackPrefix = 'reqwest_' + (+new Date())
	    , lastValue // data stored by the most recent JSONP callback
	    , xmlHttpRequest = 'XMLHttpRequest'
	    , xDomainRequest = 'XDomainRequest'
	    , noop = function () {}
	
	    , isArray = typeof Array.isArray == 'function'
	        ? Array.isArray
	        : function (a) {
	            return a instanceof Array
	          }
	
	    , defaultHeaders = {
	          'contentType': 'application/x-www-form-urlencoded'
	        , 'requestedWith': xmlHttpRequest
	        , 'accept': {
	              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
	            , 'xml':  'application/xml, text/xml'
	            , 'html': 'text/html'
	            , 'text': 'text/plain'
	            , 'json': 'application/json, text/javascript'
	            , 'js':   'application/javascript, text/javascript'
	          }
	      }
	
	    , xhr = function(o) {
	        // is it x-domain
	        if (o['crossOrigin'] === true) {
	          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
	          if (xhr && 'withCredentials' in xhr) {
	            return xhr
	          } else if (win[xDomainRequest]) {
	            return new XDomainRequest()
	          } else {
	            throw new Error('Browser does not support cross-origin requests')
	          }
	        } else if (win[xmlHttpRequest]) {
	          return new XMLHttpRequest()
	        } else {
	          return new ActiveXObject('Microsoft.XMLHTTP')
	        }
	      }
	    , globalSetupOptions = {
	        dataFilter: function (data) {
	          return data
	        }
	      }
	
	  function succeed(r) {
	    var protocol = protocolRe.exec(r.url);
	    protocol = (protocol && protocol[1]) || window.location.protocol;
	    return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
	  }
	
	  function handleReadyState(r, success, error) {
	    return function () {
	      // use _aborted to mitigate against IE err c00c023f
	      // (can't read props on aborted request objects)
	      if (r._aborted) return error(r.request)
	      if (r._timedOut) return error(r.request, 'Request is aborted: timeout')
	      if (r.request && r.request[readyState] == 4) {
	        r.request.onreadystatechange = noop
	        if (succeed(r)) success(r.request)
	        else
	          error(r.request)
	      }
	    }
	  }
	
	  function setHeaders(http, o) {
	    var headers = o['headers'] || {}
	      , h
	
	    headers['Accept'] = headers['Accept']
	      || defaultHeaders['accept'][o['type']]
	      || defaultHeaders['accept']['*']
	
	    var isAFormData = typeof FormData === 'function' && (o['data'] instanceof FormData);
	    // breaks cross-origin requests with legacy browsers
	    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
	    if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
	    for (h in headers)
	      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
	  }
	
	  function setCredentials(http, o) {
	    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
	      http.withCredentials = !!o['withCredentials']
	    }
	  }
	
	  function generalCallback(data) {
	    lastValue = data
	  }
	
	  function urlappend (url, s) {
	    return url + (/\?/.test(url) ? '&' : '?') + s
	  }
	
	  function handleJsonp(o, fn, err, url) {
	    var reqId = uniqid++
	      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
	      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
	      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
	      , match = url.match(cbreg)
	      , script = doc.createElement('script')
	      , loaded = 0
	      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1
	
	    if (match) {
	      if (match[3] === '?') {
	        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
	      } else {
	        cbval = match[3] // provided callback func name
	      }
	    } else {
	      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
	    }
	
	    win[cbval] = generalCallback
	
	    script.type = 'text/javascript'
	    script.src = url
	    script.async = true
	    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
	      // need this for IE due to out-of-order onreadystatechange(), binding script
	      // execution to an event listener gives us control over when the script
	      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
	      script.htmlFor = script.id = '_reqwest_' + reqId
	    }
	
	    script.onload = script.onreadystatechange = function () {
	      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
	        return false
	      }
	      script.onload = script.onreadystatechange = null
	      script.onclick && script.onclick()
	      // Call the user callback with the last value stored and clean up values and scripts.
	      fn(lastValue)
	      lastValue = undefined
	      head.removeChild(script)
	      loaded = 1
	    }
	
	    // Add the script to the DOM head
	    head.appendChild(script)
	
	    // Enable JSONP timeout
	    return {
	      abort: function () {
	        script.onload = script.onreadystatechange = null
	        err({}, 'Request is aborted: timeout', {})
	        lastValue = undefined
	        head.removeChild(script)
	        loaded = 1
	      }
	    }
	  }
	
	  function getRequest(fn, err) {
	    var o = this.o
	      , method = (o['method'] || 'GET').toUpperCase()
	      , url = typeof o === 'string' ? o : o['url']
	      // convert non-string objects to query-string form unless o['processData'] is false
	      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
	        ? reqwest.toQueryString(o['data'])
	        : (o['data'] || null)
	      , http
	      , sendWait = false
	
	    // if we're working on a GET request and we have data then we should append
	    // query string to end of URL and not post data
	    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
	      url = urlappend(url, data)
	      data = null
	    }
	
	    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)
	
	    // get the xhr from the factory if passed
	    // if the factory returns null, fall-back to ours
	    http = (o.xhr && o.xhr(o)) || xhr(o)
	
	    http.open(method, url, o['async'] === false ? false : true)
	    setHeaders(http, o)
	    setCredentials(http, o)
	    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
	        http.onload = fn
	        http.onerror = err
	        // NOTE: see
	        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
	        http.onprogress = function() {}
	        sendWait = true
	    } else {
	      http.onreadystatechange = handleReadyState(this, fn, err)
	    }
	    o['before'] && o['before'](http)
	    if (sendWait) {
	      setTimeout(function () {
	        http.send(data)
	      }, 200)
	    } else {
	      http.send(data)
	    }
	    return http
	  }
	
	  function Reqwest(o, fn) {
	    this.o = o
	    this.fn = fn
	
	    init.apply(this, arguments)
	  }
	
	  function setType(header) {
	    // json, javascript, text/plain, text/html, xml
	    if (header.match('json')) return 'json'
	    if (header.match('javascript')) return 'js'
	    if (header.match('text')) return 'html'
	    if (header.match('xml')) return 'xml'
	  }
	
	  function init(o, fn) {
	
	    this.url = typeof o == 'string' ? o : o['url']
	    this.timeout = null
	
	    // whether request has been fulfilled for purpose
	    // of tracking the Promises
	    this._fulfilled = false
	    // success handlers
	    this._successHandler = function(){}
	    this._fulfillmentHandlers = []
	    // error handlers
	    this._errorHandlers = []
	    // complete (both success and fail) handlers
	    this._completeHandlers = []
	    this._erred = false
	    this._responseArgs = {}
	
	    var self = this
	
	    fn = fn || function () {}
	
	    if (o['timeout']) {
	      this.timeout = setTimeout(function () {
	        timedOut()
	      }, o['timeout'])
	    }
	
	    if (o['success']) {
	      this._successHandler = function () {
	        o['success'].apply(o, arguments)
	      }
	    }
	
	    if (o['error']) {
	      this._errorHandlers.push(function () {
	        o['error'].apply(o, arguments)
	      })
	    }
	
	    if (o['complete']) {
	      this._completeHandlers.push(function () {
	        o['complete'].apply(o, arguments)
	      })
	    }
	
	    function complete (resp) {
	      o['timeout'] && clearTimeout(self.timeout)
	      self.timeout = null
	      while (self._completeHandlers.length > 0) {
	        self._completeHandlers.shift()(resp)
	      }
	    }
	
	    function success (resp) {
	      var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE
	      resp = (type !== 'jsonp') ? self.request : resp
	      // use global data filter on response text
	      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
	        , r = filteredResponse
	      try {
	        resp.responseText = r
	      } catch (e) {
	        // can't assign this in IE<=8, just ignore
	      }
	      if (r) {
	        switch (type) {
	        case 'json':
	          try {
	            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
	          } catch (err) {
	            return error(resp, 'Could not parse JSON in response', err)
	          }
	          break
	        case 'js':
	          resp = eval(r)
	          break
	        case 'html':
	          resp = r
	          break
	        case 'xml':
	          resp = resp.responseXML
	              && resp.responseXML.parseError // IE trololo
	              && resp.responseXML.parseError.errorCode
	              && resp.responseXML.parseError.reason
	            ? null
	            : resp.responseXML
	          break
	        }
	      }
	
	      self._responseArgs.resp = resp
	      self._fulfilled = true
	      fn(resp)
	      self._successHandler(resp)
	      while (self._fulfillmentHandlers.length > 0) {
	        resp = self._fulfillmentHandlers.shift()(resp)
	      }
	
	      complete(resp)
	    }
	
	    function timedOut() {
	      self._timedOut = true
	      self.request.abort()      
	    }
	
	    function error(resp, msg, t) {
	      resp = self.request
	      self._responseArgs.resp = resp
	      self._responseArgs.msg = msg
	      self._responseArgs.t = t
	      self._erred = true
	      while (self._errorHandlers.length > 0) {
	        self._errorHandlers.shift()(resp, msg, t)
	      }
	      complete(resp)
	    }
	
	    this.request = getRequest.call(this, success, error)
	  }
	
	  Reqwest.prototype = {
	    abort: function () {
	      this._aborted = true
	      this.request.abort()
	    }
	
	  , retry: function () {
	      init.call(this, this.o, this.fn)
	    }
	
	    /**
	     * Small deviation from the Promises A CommonJs specification
	     * http://wiki.commonjs.org/wiki/Promises/A
	     */
	
	    /**
	     * `then` will execute upon successful requests
	     */
	  , then: function (success, fail) {
	      success = success || function () {}
	      fail = fail || function () {}
	      if (this._fulfilled) {
	        this._responseArgs.resp = success(this._responseArgs.resp)
	      } else if (this._erred) {
	        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
	      } else {
	        this._fulfillmentHandlers.push(success)
	        this._errorHandlers.push(fail)
	      }
	      return this
	    }
	
	    /**
	     * `always` will execute whether the request succeeds or fails
	     */
	  , always: function (fn) {
	      if (this._fulfilled || this._erred) {
	        fn(this._responseArgs.resp)
	      } else {
	        this._completeHandlers.push(fn)
	      }
	      return this
	    }
	
	    /**
	     * `fail` will execute when the request fails
	     */
	  , fail: function (fn) {
	      if (this._erred) {
	        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
	      } else {
	        this._errorHandlers.push(fn)
	      }
	      return this
	    }
	  , 'catch': function (fn) {
	      return this.fail(fn)
	    }
	  }
	
	  function reqwest(o, fn) {
	    return new Reqwest(o, fn)
	  }
	
	  // normalize newline variants according to spec -> CRLF
	  function normalize(s) {
	    return s ? s.replace(/\r?\n/g, '\r\n') : ''
	  }
	
	  function serial(el, cb) {
	    var n = el.name
	      , t = el.tagName.toLowerCase()
	      , optCb = function (o) {
	          // IE gives value="" even where there is no value attribute
	          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
	          if (o && !o['disabled'])
	            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
	        }
	      , ch, ra, val, i
	
	    // don't serialize elements that are disabled or without a name
	    if (el.disabled || !n) return
	
	    switch (t) {
	    case 'input':
	      if (!/reset|button|image|file/i.test(el.type)) {
	        ch = /checkbox/i.test(el.type)
	        ra = /radio/i.test(el.type)
	        val = el.value
	        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
	        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
	      }
	      break
	    case 'textarea':
	      cb(n, normalize(el.value))
	      break
	    case 'select':
	      if (el.type.toLowerCase() === 'select-one') {
	        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
	      } else {
	        for (i = 0; el.length && i < el.length; i++) {
	          el.options[i].selected && optCb(el.options[i])
	        }
	      }
	      break
	    }
	  }
	
	  // collect up all form elements found from the passed argument elements all
	  // the way down to child elements; pass a '<form>' or form fields.
	  // called with 'this'=callback to use for serial() on each element
	  function eachFormElement() {
	    var cb = this
	      , e, i
	      , serializeSubtags = function (e, tags) {
	          var i, j, fa
	          for (i = 0; i < tags.length; i++) {
	            fa = e[byTag](tags[i])
	            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
	          }
	        }
	
	    for (i = 0; i < arguments.length; i++) {
	      e = arguments[i]
	      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
	      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
	    }
	  }
	
	  // standard query string style serialization
	  function serializeQueryString() {
	    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
	  }
	
	  // { 'name': 'value', ... } style serialization
	  function serializeHash() {
	    var hash = {}
	    eachFormElement.apply(function (name, value) {
	      if (name in hash) {
	        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
	        hash[name].push(value)
	      } else hash[name] = value
	    }, arguments)
	    return hash
	  }
	
	  // [ { name: 'name', value: 'value' }, ... ] style serialization
	  reqwest.serializeArray = function () {
	    var arr = []
	    eachFormElement.apply(function (name, value) {
	      arr.push({name: name, value: value})
	    }, arguments)
	    return arr
	  }
	
	  reqwest.serialize = function () {
	    if (arguments.length === 0) return ''
	    var opt, fn
	      , args = Array.prototype.slice.call(arguments, 0)
	
	    opt = args.pop()
	    opt && opt.nodeType && args.push(opt) && (opt = null)
	    opt && (opt = opt.type)
	
	    if (opt == 'map') fn = serializeHash
	    else if (opt == 'array') fn = reqwest.serializeArray
	    else fn = serializeQueryString
	
	    return fn.apply(null, args)
	  }
	
	  reqwest.toQueryString = function (o, trad) {
	    var prefix, i
	      , traditional = trad || false
	      , s = []
	      , enc = encodeURIComponent
	      , add = function (key, value) {
	          // If value is a function, invoke it and return its value
	          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
	          s[s.length] = enc(key) + '=' + enc(value)
	        }
	    // If an array was passed in, assume that it is an array of form elements.
	    if (isArray(o)) {
	      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
	    } else {
	      // If traditional, encode the "old" way (the way 1.3.2 or older
	      // did it), otherwise encode params recursively.
	      for (prefix in o) {
	        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
	      }
	    }
	
	    // spaces should be + according to spec
	    return s.join('&').replace(/%20/g, '+')
	  }
	
	  function buildParams(prefix, obj, traditional, add) {
	    var name, i, v
	      , rbracket = /\[\]$/
	
	    if (isArray(obj)) {
	      // Serialize array item.
	      for (i = 0; obj && i < obj.length; i++) {
	        v = obj[i]
	        if (traditional || rbracket.test(prefix)) {
	          // Treat each array item as a scalar.
	          add(prefix, v)
	        } else {
	          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
	        }
	      }
	    } else if (obj && obj.toString() === '[object Object]') {
	      // Serialize object item.
	      for (name in obj) {
	        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
	      }
	
	    } else {
	      // Serialize scalar item.
	      add(prefix, obj)
	    }
	  }
	
	  reqwest.getcallbackPrefix = function () {
	    return callbackPrefix
	  }
	
	  // jQuery and Zepto compatibility, differences can be remapped here so you can call
	  // .ajax.compat(options, callback)
	  reqwest.compat = function (o, fn) {
	    if (o) {
	      o['type'] && (o['method'] = o['type']) && delete o['type']
	      o['dataType'] && (o['type'] = o['dataType'])
	      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
	      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
	    }
	    return new Reqwest(o, fn)
	  }
	
	  reqwest.ajaxSetup = function (options) {
	    options = options || {}
	    for (var k in options) {
	      globalSetupOptions[k] = options[k]
	    }
	  }
	
	  return reqwest
	});


/***/ },
/* 170 */
/***/ function(module, exports) {

	
	/**
	 * toString ref.
	 */
	
	var toString = Object.prototype.toString;
	
	/**
	 * Return the type of `val`.
	 *
	 * @param {Mixed} val
	 * @return {String}
	 * @api public
	 */
	
	module.exports = function(val){
	  switch (toString.call(val)) {
	    case '[object Function]': return 'function';
	    case '[object Date]': return 'date';
	    case '[object RegExp]': return 'regexp';
	    case '[object Arguments]': return 'arguments';
	    case '[object Array]': return 'array';
	  }
	
	  if (val === null) return 'null';
	  if (val === undefined) return 'undefined';
	  if (val === Object(val)) return 'object';
	
	  return typeof val;
	};


/***/ },
/* 171 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(172);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(11);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)))

/***/ },
/* 174 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 175 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./AutoQueue": 43,
		"./AutoQueue.ts": 43,
		"./Everlive": 27,
		"./Everlive.ts": 27,
		"./EverliveError": 3,
		"./EverliveError.ts": 3,
		"./ExpandProcessor": 44,
		"./ExpandProcessor.ts": 44,
		"./Expression": 18,
		"./Expression.ts": 18,
		"./GeoPoint": 28,
		"./GeoPoint.ts": 28,
		"./Push": 45,
		"./Push.ts": 45,
		"./Request": 9,
		"./Request.ts": 9,
		"./Setup": 46,
		"./Setup.ts": 46,
		"./auth/Authentication": 47,
		"./auth/Authentication.ts": 47,
		"./auth/AuthenticationSetup": 48,
		"./auth/AuthenticationSetup.ts": 48,
		"./business-logic/BusinessLogic": 49,
		"./business-logic/BusinessLogic.ts": 49,
		"./caching/CacheModule": 50,
		"./caching/CacheModule.ts": 50,
		"./caching/caching": 51,
		"./caching/caching.ts": 51,
		"./constants": 2,
		"./constants.ts": 2,
		"./dataQuery/DataQuery": 15,
		"./dataQuery/DataQuery.ts": 15,
		"./dataQuery/DataQueryBuilder": 52,
		"./dataQuery/DataQueryBuilder.ts": 52,
		"./docs/callbacks": 100,
		"./docs/callbacks.ts": 100,
		"./docs/resultTypes": 101,
		"./docs/resultTypes.ts": 101,
		"./encryption/CryptographicProvider": 53,
		"./encryption/CryptographicProvider.ts": 53,
		"./helpers/helpers": 54,
		"./helpers/helpers.ts": 54,
		"./helpers/html/htmlHelper": 55,
		"./helpers/html/htmlHelper.ts": 55,
		"./helpers/html/htmlHelperOfflineModule": 56,
		"./helpers/html/htmlHelperOfflineModule.ts": 56,
		"./helpers/html/htmlHelperResponsiveModule": 57,
		"./helpers/html/htmlHelperResponsiveModule.ts": 57,
		"./index": 58,
		"./index.ts": 58,
		"./interfaces/AuthInfoResult": 102,
		"./interfaces/AuthInfoResult.ts": 102,
		"./interfaces/CloudFunctionInvocationParameters": 103,
		"./interfaces/CloudFunctionInvocationParameters.ts": 103,
		"./interfaces/CordovaFileEntry": 104,
		"./interfaces/CordovaFileEntry.ts": 104,
		"./interfaces/CordovaFileUploadOptions": 105,
		"./interfaces/CordovaFileUploadOptions.ts": 105,
		"./interfaces/CreateItemResult": 106,
		"./interfaces/CreateItemResult.ts": 106,
		"./interfaces/ErrorCallback": 107,
		"./interfaces/ErrorCallback.ts": 107,
		"./interfaces/File": 108,
		"./interfaces/File.ts": 108,
		"./interfaces/FileContent": 109,
		"./interfaces/FileContent.ts": 109,
		"./interfaces/Item": 110,
		"./interfaces/Item.ts": 110,
		"./interfaces/MultipleResult": 111,
		"./interfaces/MultipleResult.ts": 111,
		"./interfaces/RequestOptions": 112,
		"./interfaces/RequestOptions.ts": 112,
		"./interfaces/SaveItemResult": 113,
		"./interfaces/SaveItemResult.ts": 113,
		"./interfaces/SetUserPasswordByResetCodePayload": 114,
		"./interfaces/SetUserPasswordByResetCodePayload.ts": 114,
		"./interfaces/SetUserPasswordBySecretAnswerPayload": 115,
		"./interfaces/SetUserPasswordBySecretAnswerPayload.ts": 115,
		"./interfaces/SingleResult": 116,
		"./interfaces/SingleResult.ts": 116,
		"./interfaces/SocialLoginResult": 117,
		"./interfaces/SocialLoginResult.ts": 117,
		"./interfaces/SuccessCallback": 118,
		"./interfaces/SuccessCallback.ts": 118,
		"./interfaces/UpdateItemResult": 119,
		"./interfaces/UpdateItemResult.ts": 119,
		"./interfaces/User": 120,
		"./interfaces/User.ts": 120,
		"./interfaces/UserInfo": 121,
		"./interfaces/UserInfo.ts": 121,
		"./interfaces/UserLoginResult": 122,
		"./interfaces/UserLoginResult.ts": 122,
		"./interfaces/UserSocialIdentity": 123,
		"./interfaces/UserSocialIdentity.ts": 123,
		"./kendo/kendo.everlive": 59,
		"./kendo/kendo.everlive.ts": 59,
		"./offline/OfflineFilesModule": 60,
		"./offline/OfflineFilesModule.ts": 60,
		"./offline/OfflineFilesProcessor": 61,
		"./offline/OfflineFilesProcessor.ts": 61,
		"./offline/OfflineQueryProcessor": 62,
		"./offline/OfflineQueryProcessor.ts": 62,
		"./offline/OfflineStorageModule": 63,
		"./offline/OfflineStorageModule.ts": 63,
		"./offline/offline": 29,
		"./offline/offline.ts": 29,
		"./offline/offlinePersisters": 19,
		"./offline/offlinePersisters.ts": 19,
		"./offline/offlineTransformations": 30,
		"./offline/offlineTransformations.ts": 30,
		"./offline/persisters/BasePersister": 20,
		"./offline/persisters/BasePersister.ts": 20,
		"./offline/persisters/FileSystemPersister": 64,
		"./offline/persisters/FileSystemPersister.ts": 64,
		"./offline/persisters/LocalStoragePersister": 65,
		"./offline/persisters/LocalStoragePersister.ts": 65,
		"./offline/persisters/Persister": 124,
		"./offline/persisters/Persister.ts": 124,
		"./push/CordovaCurrentDevice": 31,
		"./push/CordovaCurrentDevice.ts": 31,
		"./push/CurrentDevice": 66,
		"./push/CurrentDevice.ts": 66,
		"./push/NativeScriptCurrentDevice": 32,
		"./push/NativeScriptCurrentDevice.ts": 32,
		"./query/AggregateQuery": 21,
		"./query/AggregateQuery.ts": 21,
		"./query/EventQuery": 67,
		"./query/EventQuery.ts": 67,
		"./query/Query": 6,
		"./query/Query.ts": 6,
		"./query/QueryBuilder": 22,
		"./query/QueryBuilder.ts": 22,
		"./query/RequestOptionsBuilder": 33,
		"./query/RequestOptionsBuilder.ts": 33,
		"./query/WhereQuery": 68,
		"./query/WhereQuery.ts": 68,
		"./reqwest.everlive": 23,
		"./reqwest.everlive.ts": 23,
		"./reqwest.nativescript": 69,
		"./reqwest.nativescript.ts": 69,
		"./reqwest.nodejs": 70,
		"./reqwest.nodejs.ts": 70,
		"./response/ResponseParserProcessor": 71,
		"./response/ResponseParserProcessor.ts": 71,
		"./response/ResponseTransformProcessor": 72,
		"./response/ResponseTransformProcessor.ts": 72,
		"./services/RequestService": 10,
		"./services/RequestService.ts": 10,
		"./storages/FileStore": 34,
		"./storages/FileStore.ts": 34,
		"./storages/LocalStore": 35,
		"./storages/LocalStore.ts": 35,
		"./storages/NativeScriptFileStore": 73,
		"./storages/NativeScriptFileStore.ts": 73,
		"./storages/WebFileStore": 74,
		"./storages/WebFileStore.ts": 74,
		"./types/Data": 16,
		"./types/Data.ts": 16,
		"./types/Files": 75,
		"./types/Files.ts": 75,
		"./types/Users": 76,
		"./types/Users.ts": 76,
		"./types/preProcessors/DataPreprocessor": 77,
		"./types/preProcessors/DataPreprocessor.ts": 77,
		"./types/preProcessors/OfflineQueryPreprocessor": 78,
		"./types/preProcessors/OfflineQueryPreprocessor.ts": 78,
		"./types/processors/AuthenticationProcessor": 79,
		"./types/processors/AuthenticationProcessor.ts": 79,
		"./types/processors/BusinessLogicQueryProcessor": 80,
		"./types/processors/BusinessLogicQueryProcessor.ts": 80,
		"./types/processors/CacheQueryProcessor": 81,
		"./types/processors/CacheQueryProcessor.ts": 81,
		"./types/processors/EventQueryProcessor": 82,
		"./types/processors/EventQueryProcessor.ts": 82,
		"./types/processors/OfflineQueryProcessor": 83,
		"./types/processors/OfflineQueryProcessor.ts": 83,
		"./types/processors/OnlineQueryProcessor": 84,
		"./types/processors/OnlineQueryProcessor.ts": 84,
		"./utils": 4,
		"./utils.ts": 4
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 176;


/***/ },
/* 177 */
/***/ function(module, exports) {

	'use strict';
	
	var AggregationTranslator = {};
	
	function getFieldAggregation(aggregationDefinition) {
	    var result;
	
	    if (aggregationDefinition.hasOwnProperty('count')) {
	        result = {'$sum': 1};
	    } else if (aggregationDefinition.min) {
	        result = {'$min': '$' + aggregationDefinition.min};
	    } else if (aggregationDefinition.max) {
	        result = {'$max': '$' + aggregationDefinition.max};
	    } else if (aggregationDefinition.avg) {
	        result = {'$avg': '$' + aggregationDefinition.avg};
	    } else if (aggregationDefinition.sum) {
	        result = {'$sum': '$' + aggregationDefinition.sum};
	    } else {
	        throw new Error('The aggregating function was not recognized or is not supported: ' + JSON.stringify(aggregationDefinition));
	    }
	
	    return result;
	};
	
	function addGroupingField(fieldName, _idObject, $project) {
	    //Add the field in the _id object
	    _idObject[fieldName] = '$' + fieldName;
	
	    //Add projection so that the result contains the actual field e.g. is { fieldName: fieldValue } instead of { _id: { fieldName: fieldValue } }
	    $project[fieldName] = '$_id.' + fieldName;
	}
	
	
	/*
	 * aggregateDefinition = {
	 *		Filter: object|null,
	 *		GroupBy: string|array|null,
	 *		Aggregate: object|null
	 * }
	 */
	AggregationTranslator.translate = function (aggregateDefinition, options) {
	    var $match;     //$match clause for the pipeline
	    var $group;     //$group clause for the pipeline
	    var $project;   //$project clause for the pipeline
	
	    options = options || {};
	
	    //Process the filter
	    if (aggregateDefinition.Filter) {
	        $match = aggregateDefinition.Filter;
	    }
	
	    //Process the GroupBy clause
	    var _id;	//The required _id clause in the Mongo $group clause
	    var groupByDefinition = aggregateDefinition.GroupBy;
	    if (groupByDefinition) {
	        //Mongo returns all the values of the grouping fields in an _id field, but we use projection to put the values of grouping fields on first level, thus we do not want the _id
	        $project = {_id: 0};
	
	        _id = {};
	        if (Array.isArray(groupByDefinition)) {
	            //The GroupBy value is an array of fields to group by
	            var groupingFields = groupByDefinition;
	
	            //Process each grouping field
	            for (var i = 0; i < groupingFields.length; i++) {
	                var groupingField = groupingFields[i];
	                addGroupingField(groupingField, _id, $project);
	            }
	        } else {
	            //TODO: check if the value is string, and if not - throw error
	
	            //The GroupBy value is the name of the field to group by
	            var groupingField = groupByDefinition;
	
	            //Process the grouping field
	            addGroupingField(groupingField, _id, $project);
	        }
	    } else {
	        //No GroupBy clause, meaning we apply the aggregation to the whole resultset
	        _id = null;
	
	        //Adjust the $project definition so that the '_id' returned by Mongo is not included in the result.
	        $project = {_id: 0};
	    }
	    $group = {'_id': _id};
	
	    //Process the Aggregate clause
	    var aggregateDefinition = aggregateDefinition.Aggregate;
	    if (aggregateDefinition) {
	        for (var outputFieldName in aggregateDefinition) {
	            if (aggregateDefinition.hasOwnProperty(outputFieldName)) {
	                var fieldAggregation = aggregateDefinition[outputFieldName];
	
	                //Add the field aggregation to the Mongo $group clause
	                $group[outputFieldName] = getFieldAggregation(fieldAggregation);
	
	                //Add the field to the projection, so that it is included in the result
	                $project[outputFieldName] = 1;
	            }
	        }
	    }
	
	    //Construct the pipeline
	    var pipeline = [];
	
	    if ($match) pipeline.push({$match: $match});
	
	    if (options.maxDocumentsCount) {
	        pipeline.push({$limit: options.maxDocumentsCount});
	    }
	
	    if ($group) pipeline.push({$group: $group});
	
	    if ($project) pipeline.push({$project: $project});
	
	    return pipeline;
	};
	
	module.exports = AggregationTranslator;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Constants = __webpack_require__(39);
	
	/**
	 * A class that is used to get all required information in order to process a set of relations.
	 * @param parent - An ExecutionNode instance used to supply the tree like data structure.
	 * @param relationNode - The relation node used to created the ExecutionNode instance (ExecutionNode instance should contain one or many relations
	 * if they can be combined for batch execution).
	 * @constructor
	 */
	var ExecutionNode = function (parentNode, relationNode) {
	    var parentPath = '';
	    if (parentNode) {
	        parentPath = parentNode.path;
	    }
	    this.parent = parentPath;
	    this.relations = [relationNode.path];
	    this.name = relationNode.path;
	    this.targetTypeName = relationNode.targetTypeName;
	    this.canAddOtherRelations = !relationNode.filterExpression && !relationNode.sortExpression && !relationNode.aggregateExpression && !relationNode.take && !relationNode.skip;
	    this.children = [];
	    var path = '';
	    if (parentPath) {
	        path += parentPath + '.';
	    }
	    path += relationNode.targetTypeName;
	    this.path = path;
	};
	
	/**
	 * Inserts a RelationNode to an ExecutionNode.
	 * @param relation - A RelationNode instance.
	 */
	ExecutionNode.prototype._insertRelationNode = function (relation) {
	    this.relations.push(relation.path);
	};
	
	/**
	 * Inserts a child node (which relations) depends from parent node result.
	 * @param child - ExecutionNode instance representing child node.
	 */
	ExecutionNode.prototype._insertChildNode = function (child) {
	    this.children.push(child.name);
	};
	
	/**
	 * Helper method that checks if some relations could be combined (for example have same TargetType).
	 * @param relation
	 * @returns {boolean}
	 */
	ExecutionNode.prototype.canCombineWithRelation = function (relation) {
	    if (!this.canAddOtherRelations) {
	        return false;
	    }
	
	    return this.targetTypeName === relation.targetTypeName && !relation.filterExpression && !relation.sortExpression && !relation.aggregateExpression && !relation.take && !relation.skip;
	};
	
	/** ExecutionTree
	 * Class that allows the creation of an execution tree from a RelationTree object. Used to process all queries (master and child) in a correct order.
	 * @param relationTree - An instance of RelationTree.
	 * @constructor
	 */
	var ExecutionTree = function (relationTree) {
	    this._relationTree = relationTree;
	    this._map = {};
	};
	
	/**
	 * Adds execution node to the ExecutionTree.
	 * @param executionNode
	 */
	ExecutionTree.prototype.addExecutionNode = function (executionNode) {
	    this._map[executionNode.name] = executionNode;
	};
	
	/**
	 * Finds the ExecutionNode which contains the requested relation.
	 * @param relation - A Relation instance.
	 * @returns {*}
	 */
	ExecutionTree.prototype.getExecutionNodeOfRelation = function (relation) {
	    for (var execNode in this._map) {
	        if (this._map.hasOwnProperty(execNode)) {
	            if (this._map[execNode].relations.indexOf(relation) > -1) {
	                return this._map[execNode];
	            }
	        }
	    }
	    return null;
	};
	
	ExecutionTree.prototype.getRelationTree = function () {
		return this._relationTree;
	};
	
	/**
	 * Finds a RelationNode within the RelationTree.
	 * @param relationNodePath - String that represents the relation within the RelationTree (for example: Activities.Likes.Role).
	 * @returns {*}
	 */
	ExecutionTree.prototype.getRelationNode = function (relationNodePath) {
	    if (relationNodePath) {
	        return this._relationTree.map[relationNodePath] || null;
	    } else {
	        return null;
	    }
	};
	
	ExecutionTree.prototype.getRootRelationNode = function () {
	    return this._relationTree.map[this._relationTree.map.$root] || null;
	};
	
	ExecutionTree.prototype.getRootNode = function () {
		var executionTreeMap = this._map;
	    var executionTreeRoot = null;
	    for (var exNode in executionTreeMap) {
	        if (executionTreeMap.hasOwnProperty(exNode)) {
	            if (executionTreeMap[exNode].parent === '') {
	                executionTreeRoot = executionTreeMap[exNode];
	                break;
	            }
	        }
	    }
	    return executionTreeRoot;
	};
	
	ExecutionTree.prototype.getNode = function (nodeName) {
		return this._map[nodeName];
	};
	
	/**
	 * Builds the ExecutionTree from a RelationTree.
	 */
	ExecutionTree.prototype.build = function () {
	    //build beginning from the root
	    var relationRoot = this.getRelationNode(this._relationTree.map.$root);
	    //Setup the root of the execution tree.
	    var rootExecutionNode = new ExecutionNode(null, relationRoot);//no parent node
	    this.addExecutionNode(rootExecutionNode);
	    this.buildInternal(relationRoot);
	};
	
	/**
	 * Traverse the relation tree and build the execution tree.
	 * @param relationRoot - The root node of the RelationTree.
	 */
	ExecutionTree.prototype.buildInternal = function (relationRoot) {
	    relationRoot.children.forEach(function (child) {
	        var childRelationNode = this.getRelationNode(child);
	        this.insertRelationNodeInExecutionTree(childRelationNode);
	        this.buildInternal(childRelationNode);
	    }, this);
	};
	
	/**
	 * Inserts a relation node within the execution tree (based on its dependencies).
	 * @param relation - The relation that will be inserted.
	 */
	ExecutionTree.prototype.insertRelationNodeInExecutionTree = function (relation) {
	    var rootExecutionNode = this.getExecutionNodeOfRelation(relation.parentPath);
	    var childToCombine = this.tryGetChildNodeToCombine(rootExecutionNode, relation);
	    if (childToCombine) {//if there is a child that we combine the relation
	        childToCombine._insertRelationNode(relation);
	    } else {
	        var newExecutionNode = new ExecutionNode(rootExecutionNode, relation);//create a separate execution node that will host the relation
	        rootExecutionNode._insertChildNode(newExecutionNode);
	        this.addExecutionNode(newExecutionNode);
	    }
	};
	
	/**
	 * Tries to find an ExecutionNode which could be combined with a relation.
	 * @param rootExecutionNode - The root node of the ExecutionTree.
	 * @param relation - Relation that will be added to the ExecutionTree.
	 * @returns {*}
	 */
	ExecutionTree.prototype.tryGetChildNodeToCombine = function (rootExecutionNode, relation) {
	    if (rootExecutionNode.canCombineWithRelation(relation)) {
	        return rootExecutionNode;
	    }
	    var children = rootExecutionNode.children;
	    for (var i = 0; i < children.length; i++) {
	        var child = this._map[children[i]];
	        var childToCombine = this.tryGetChildNodeToCombine(child, relation);
	        if (childToCombine) {
	            return childToCombine;
	        }
	    }
	    return null;
	};
	
	/**
	 * Gets the filter expression from all relations inside an ExecutionNode.
	 * @param executionNode - The ExecutionNode instance.
	 * @returns {{}}
	 */
	ExecutionTree.prototype.getFilterFromExecutionNode = function (executionNode, includeArrays) {
	    var filter = {};
	    var subRelationsFilter = [];
	    for (var i = 0; i < executionNode.relations.length; i++) {
	        var innerFilter = this.getFilterFromSingleRelation(this._relationTree.map[executionNode.relations[i]], includeArrays);
	        if (innerFilter) {
	            subRelationsFilter.push(innerFilter);
	        }
	    }
	
	    if (subRelationsFilter.length > 1) {
	        filter.$or = subRelationsFilter;
	    } else if (subRelationsFilter.length > 0) {
	        filter = subRelationsFilter[0];
	    } else {
	        filter = null;
	    }
	    return filter;
	};
	
	
	
	/**
	 * Gets filter expression from a single relation. Traverse the relation tree in order to get the "Id"s from the result of parent relation
	 * along with user defined filters.
	 * @param relation - A Relation instance.
	 * @returns {*}
	 */
	ExecutionTree.prototype.getFilterFromSingleRelation = function (relation, includeArrays) {
	    var userDefinedFilter = relation.filterExpression;
	    var parentRelationFilter = {};
	    var parentRelationIds = this.getRelationFieldValues(relation, includeArrays);
	    var parentRelationFieldName = (relation.isInvertedRelation ? relation.relationField : Constants.IdFieldNameClient);
	
	    if (parentRelationIds.length > 0) {
	        parentRelationFilter[parentRelationFieldName] = {'$in': parentRelationIds};
	    } else {
	        return null;
	    }
	
	    if (userDefinedFilter !== undefined) {
	        var filters = [];
	        filters.push(parentRelationFilter);
	        filters.push(userDefinedFilter);
	        return {'$and': filters};
	    } else {
	        return parentRelationFilter;
	    }
	};
	
	/**
	 * Get relation field values of parent relation in order to construct a proper filter (to create a relation).
	 * @param relation - A RelationNode instance which will get the filter.
	 * @param includeArrays - Whether to include array values of the parent items when calculating the items that will be expanded on the current level.
	 * @returns {Array} - An array of relation field values.
	 */
	ExecutionTree.prototype.getRelationFieldValues = function (relation, includeArrays) {
	    var parentRelationIds = [];
	    var parentRelation = this._relationTree.map[relation.parentPath];
	    // parentRelationResult actually is an Activity or Array of Activities
	    var parentRelationResult = Array.isArray(parentRelation.result) ? parentRelation.result : [parentRelation.result];
	    if (relation.isInvertedRelation) {
	        for (var p = 0; p < parentRelationResult.length; p++) {
	            parentRelationIds.push(parentRelationResult[p][relation.parentRelationField]);
	        }
	    } else {
	        // all comments are related to expand of type content type Activities expand: {"Likes": true}
	        if (parentRelation && parentRelation.result) {
	            relation.parentRelationIds = relation.parentRelationIds || {};
	            for (var i = 0; i < parentRelationResult.length; i++) {
	                // itemFromParentRelation is single Activity
	                var itemFromParentRelation = parentRelationResult[i];
	
	                // parentRelationFieldValue is Activity.Likes
	                var parentRelationFieldValue = itemFromParentRelation[relation.relationField];
	                if (Array.isArray(parentRelationFieldValue)) {
	                    relation.hasArrayValues = true;
	                    if (includeArrays) {
	                        for (var j = 0; j < parentRelationFieldValue.length; j++) {
	                            // itemToExpandId is current value in Activity.Likes array or just a single "Id"
	                            var itemToExpandId = parentRelationFieldValue[j];
	                            if(itemToExpandId !== undefined && itemToExpandId !== null) {
	                                parentRelationIds.push(itemToExpandId);
	                                // we set any value just to create a map of Ids
	                                relation.parentRelationIds[itemToExpandId] = 1;
	                            }
	                        }
	                    }
	                } else {
	                    if(parentRelationFieldValue !== undefined && parentRelationFieldValue !== null) {
	                        parentRelationIds.push(parentRelationFieldValue);
	                        relation.parentRelationIds[parentRelationFieldValue] = 1;
	                    }
	                }
	            }
	        }
	    }
	
	    return parentRelationIds;
	};
	
	module.exports = ExecutionTree;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var async = __webpack_require__(95);
	var RelationTreeBuilder = __webpack_require__(181);
	var ExecutionTree = __webpack_require__(178);
	var Constants = __webpack_require__(39);
	var ExpandError = __webpack_require__(94);
	
	function Processor(options) {
	    this._executionNodeFunction = options.executionNodeFunction;
	    this._metadataProviderFunction = options.metadataProviderFunction;
	}
	
	Processor.prototype._createExecuteNodeExecutor = function (relationsTree, executionTree, executionNode, expandContext) {
	    var self = this;
	    return function (done) {
	        var relationNode = executionTree.getRelationNode(executionNode.relations[0]);//get the relation node for the only relation of the execution node.
	        var parentRelationNode = executionTree.getRelationNode(relationNode.parentPath);
	        var includeArrays = !(parentRelationNode.parentPath && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
	        var filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);
	
	        var errorMessage = RelationTreeBuilder.validateSingleRelation(relationNode);
	        if (errorMessage) {
	            return done(new ExpandError(errorMessage));
	        }
	
	        // if we have such options executionNode should have only one relation.
	        var node = {};
	        node.select = relationNode.fieldsExpression;
	        node.sort = relationNode.sortExpression;
	        node.skip = relationNode.skip;
	        node.take = relationNode.take;
	        node.filter = filter;
	        node.targetTypeName = relationNode.targetTypeName;
			node.returnItemsCount = relationNode.returnItemsCount;
			node.aggregate = relationNode.aggregateExpression;
	
	        self._executionNodeFunction.call(null, node, expandContext, function onProcessExecutionNode(err, result) {
	            if (err) {
	                return done(err);
	            }
				
				var childRelationNode;
	
	            for (var i = 0; i < executionNode.relations.length; i++) {
	                childRelationNode = executionTree.getRelationNode(executionNode.relations[i]);
	                childRelationNode.result = self._extractResultForRelation(childRelationNode, result);
	            }
	            executionNode.result = childRelationNode.result;
				
	            var arr = [];
	            for (var j = 0; j < executionNode.children.length; j++) {
	                var executionTreeMap = executionTree._map;
	                arr.push(self._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionNode.children[j]], expandContext));
	            }
	            async.parallel(arr, done);
	        });
	    };
	};
	
	Processor.prototype._getSingleResult = function (relationsTree, relation, singleObject, singleObjectIndex) {
	    if (!singleObject) {
	        return null;
	    }
	
	    var childRelation;
	    var childItem;
	
	    // if relation has singleFieldName option we just replace the parent id with a single value
	    if (relation.singleFieldName) {
	        if (relation.children && relation.children.length > 0) {
	            childRelation = relationsTree[relation.children[0]];
	            childItem = this._getObjectByIdFromArray(childRelation.result, singleObject[relation.singleFieldName]);
	            return this._getSingleResult(relationsTree, childRelation, childItem, 0);
	        }
	        return singleObject[relation.singleFieldName];
	    }
	
	    var result = {};
	    var passedProperties = {};
	
	    if (relation.children && relation.children.length > 0) {
	        for (var j = 0; j < relation.children.length; j++) {
	            childRelation = relationsTree[relation.children[j]];
	            var childRelationField = childRelation.relationField;
	            var userDefinedRelName = childRelation.userDefinedName;
	            if (!childRelation.isInvertedRelation && childRelationField === userDefinedRelName) {
	                passedProperties[childRelationField] = 1;
	            }
	
	            var innerRelationResult = childRelation.result;
	
	            if (childRelation.isInvertedRelation) {
					if (childRelation.aggregateExpression) {
						result[userDefinedRelName] = innerRelationResult[singleObjectIndex];
					} else if (childRelation.returnItemsCount) {
						result[userDefinedRelName] = innerRelationResult;
					} else {
						for (var k = 0; k < innerRelationResult.length; k++) {
							var singleResult = this._getSingleResult(relationsTree, childRelation, innerRelationResult[k], k);
							if (singleResult) {
								result[userDefinedRelName] = result[userDefinedRelName] || [];
								if (Array.isArray(relation.result)) {
									//Insert the related items in their proper place in the parent item
									if (singleResult[childRelation.relationField] === singleObject.Id) {
										result[userDefinedRelName].push(singleResult);
									}
								} else {
									result[userDefinedRelName].push(singleResult);
								}
							}
						}
					}
	            } else {
	                result[userDefinedRelName] = childRelation.isArray() ? [] : null;
	
	                if (singleObject[childRelationField]) {
	                    if (Array.isArray(singleObject[childRelationField])) {
							if (childRelation.aggregateExpression) {
								result[userDefinedRelName] = innerRelationResult[singleObjectIndex];
	                        } else if (childRelation.sortExpression) {
	                            // if there is a sorting we replace items using order of the query result
	                            for (var p = 0; p < innerRelationResult.length; p++) {
	                                if (singleObject[childRelationField].indexOf(innerRelationResult[p].Id) > -1) {
	                                    childItem = innerRelationResult[p];
	                                    this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
	                                }
	                            }
	                        } else {
								// we just replace items getting them by id which we have
								for (var i = 0; i < singleObject[childRelationField].length; i++) {
									childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField][i]);
									this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
								}
	                        }
	                    } else {
	                        childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField]);
	                        result[userDefinedRelName] = this._getSingleResult(relationsTree, childRelation, childItem, 0);
	                    }
	                }
	            }
	        }
	    }
	
	    // add all other fields to the result (except the relation fields which we have already replaced).
	    for (var prop in singleObject) {
			if (singleObject.hasOwnProperty(prop)) {
				var propertyShouldBeAddedToResult = !passedProperties[prop] && this._fieldExistInFieldsExpression(prop, relation.originalFieldsExpression);
				if (propertyShouldBeAddedToResult) {
					result[prop] = singleObject[prop];
				}
			}
	    }
	
	    return result;
	};
	
	Processor.prototype._addSingleResultToParentArray = function (relationsTree, childRelation, childItem, result, userDefinedRelName) {
	    var singleResult = this._getSingleResult(relationsTree, childRelation, childItem, 0);
	    result[userDefinedRelName] = result[userDefinedRelName] || [];
	    if (singleResult) {
	        result[userDefinedRelName].push(singleResult);
	    }
	};
	
	/**
	 * Checks if a field will be returned via given fields expression.
	 * @param field - The name of the field.
	 * @param fieldsExpression - The Fields expression which is checked.
	 * @returns {*}
	 */
	Processor.prototype._fieldExistInFieldsExpression = function (field, fieldsExpression) {
	    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
	        return true;
	    }
	
	    if (field === Constants.IdFieldNameClient) {
	        if (fieldsExpression[field] === undefined) {
	            return true;
	        }
	        return fieldsExpression[field];
	    }
	
	    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);
	
	    if (isExclusive === undefined) {
	        return true;
	    }
	
	    if (isExclusive) {
	        return !fieldsExpression.hasOwnProperty(field);
	    } else {
	        return fieldsExpression.hasOwnProperty(field);
	    }
	};
	
	/**
	 * Extracts the result for a single relation (in cases when ExecutionNode contains more than one relations).
	 * @param relation - The relation object.
	 * @param queryResult - Result of the combined query.
	 * @returns {Array}
	 */
	Processor.prototype._extractResultForRelation = function (relation, queryResult) {
		if (relation.returnItemsCount || relation.aggregateExpression) {
			return queryResult;
		} else {
			var result = [];
			for (var i = 0; i < queryResult.length; i++) {
				if (relation.parentRelationIds) {
					if (relation.parentRelationIds.hasOwnProperty(queryResult[i].Id)) {
						result.push(queryResult[i]);
					}
				}
				if (relation.isInvertedRelation) {
					result.push(queryResult[i]);
				}
			}
			return result;
		}
	};
	
	/**
	 * Gets an object with a given Id from Array.
	 * @param array
	 * @param id
	 * @returns {*}
	 */
	Processor.prototype._getObjectByIdFromArray = function (array, id) {
	    if (array) {
	        for (var i = 0; i < array.length; i++) {
	            if (array[i].Id === id) {
	                return array[i];
	            }
	        }
	    }
	    return null;
	};
	
	/**
	 * @public
	 * @param expandExpression
	 * @param mainTypeName
	 * @param isArray
	 * @param fieldsExpression
	 * @param maxTakeValue
	 * @param prepareContext
	 * @param done
	 */
	Processor.prototype.prepare = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, prepareContext, done) {
	    var rtb = new RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, this._metadataProviderFunction, prepareContext);
	    rtb.build(function (err, map) {
	        var mainQueryFieldsExpression;
	        if (map) {
	            mainQueryFieldsExpression = map[map.$root].fieldsExpression;
	            var prepareResult = {
	                relationsTree: rtb,
	                mainQueryFieldsExpression: mainQueryFieldsExpression
	            }
	        }
	        done(err, prepareResult);
	    });
	};
	
	/**
	 * @public
	 * @param relationsTree
	 * @param mainQueryResult
	 * @param expandContext
	 * @param done
	 */
	Processor.prototype.expand = function (relationsTree, mainQueryResult, expandContext, done) {
	    var relationsTreeMap = relationsTree.map;
	    var self = this;
		
		//Build the execution tree
	    var executionTree = new ExecutionTree(relationsTree);
	    executionTree.build();
	    relationsTreeMap[relationsTreeMap.$root].result = mainQueryResult;
		
	    var executionTreeMap = executionTree._map;
	    var rootExecutionNode = executionTree.getRootNode();
	    if (!rootExecutionNode) return;
	
		//Get a list of execute definitions(queries) to execute against the DB
		var executionList = this._getExecutionList(executionTree, rootExecutionNode, expandContext);
		
		//Check for the max queries limit
	    var maxQueriesCount = 25;
	    if (executionList.length > maxQueriesCount) {
	        done(new ExpandError('Expand expression results in more than ' + maxQueriesCount + ' inner queries!'));
	    }
		
		//Execute them in series, since the result of the parent relation is used to get correct filter.
		async.forEachSeries(
			executionList,
			function(executeDefinition, callback) {
				var executeOptions = executeDefinition.executeOptions;
				var relationNode = executeDefinition.relationNode;
				
				//Adjust the filter for the execute definition, as it sometimes uses the result of the parent relation, which is only available after execution
				self._adjustFilterForExecuteDefinition(executionTree, executeDefinition);
				
				//Apply the restrictions for expand
				var errorMessage = RelationTreeBuilder.validateSingleRelation(relationNode, relationsTree);
				if (errorMessage) {
					return callback(new ExpandError(errorMessage));
				}
				
				//Execute the query and set the result
				self._executionNodeFunction.call(null, executeOptions, expandContext, function onProcessExecutionNode(err, result) {
					if (err) {
						return callback(err);
					}
					
					var relationResult;
					
					if (executeDefinition.dataItem) {
						relationResult = self._extractResultForRelation(relationNode, result);
						if (!relationNode.result) relationNode.result = [];
						relationNode.result.push(relationResult);
					} else {
						var executionNode = executeDefinition.executionNode;
						var childRelationNode;
						for (var i = 0; i < executionNode.relations.length; i++) {
							childRelationNode = executionTree.getRelationNode(executionNode.relations[i]);
							childRelationNode.result = self._extractResultForRelation(childRelationNode, result);
						}
						executionNode.result = childRelationNode.result;
					}
					
					callback();
				});
			},
			function onProcessExecutionTree(err) {
				if (err) {
					done(err);
				} else {
					var output;
					var rootRelation = relationsTreeMap[relationsTreeMap.$root];
					if (Array.isArray(mainQueryResult)) {
						output = [];
						for (var i = 0; i < mainQueryResult.length; i++) {
							var singleResult = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult[i], i);
							if (singleResult) {
								output.push(singleResult);
							}
						}
					} else {
						output = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult, 0);
					}
					done(null, output);
				}
			}
		);
	};
	
	Processor.prototype._getExecutionList = function(executionTree, executionNode, expandContext) {
	    var self = this;
		
		var relationTree = executionTree.getRelationTree();
		var relationNode = executionTree.getRelationNode(executionNode.name);
		var relationResult = relationNode.result;
		
		var executeDefinitions = [];
		for (var i = 0; i < executionNode.children.length; i++) {
			var executeDefinition;
			
			var childNodeName = executionNode.children[i];
			var childExecutionNode = executionTree.getNode(childNodeName);
			var childRelationNode = executionTree.getRelationNode(childNodeName);
			if (childRelationNode.aggregateExpression) {
				var relationResult = relationResult;
				if (!Array.isArray(relationResult)) relationResult = [ relationResult ];
				
				for (var j = 0; j < relationResult.length; j++) {
					executeDefinition = this._getExecuteDefinitionForItem(relationResult[j], childRelationNode, relationTree, expandContext);
					executeDefinitions.push(executeDefinition);
				}
			} else {
				executeDefinition = this._getExecuteDefinitionForNode(executionTree, childExecutionNode, expandContext);
				executeDefinitions.push(executeDefinition);
			}
			
			var childFunctions = this._getExecutionList(executionTree, childExecutionNode, expandContext);
			executeDefinitions = executeDefinitions.concat(childFunctions);
		}
		
		return executeDefinitions;
	};
	
	//Adjusts the filter for the query
	Processor.prototype._adjustFilterForExecuteDefinition = function (executionTree, executeDefinition) {
		var filter;
		
		var relationNode = executeDefinition.relationNode;
		
		if (executeDefinition.dataItem) {
			filter = this._getFilterFromSingleItem(executeDefinition.dataItem, relationNode);
		} else {
			var executionNode = executeDefinition.executionNode;
			var parentRelationNode = executionTree.getRelationNode(relationNode.parentPath);
			var includeArrays = !(parentRelationNode.parentPath && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
			filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);
		}
	
		executeDefinition.executeOptions.filter = filter;
	};
	
	Processor.prototype._getExecuteDefinitionForItem = function (dataItem, relationNode, relationTree, expandContext) {
		//Create ExecuteOptions object
		var executeOptions = {};
		executeOptions.select = relationNode.fieldsExpression;
		executeOptions.sort = relationNode.sortExpression;
		executeOptions.skip = relationNode.skip;
		executeOptions.take = relationNode.take;
		executeOptions.targetTypeName = relationNode.targetTypeName;
		executeOptions.returnItemsCount = relationNode.returnItemsCount;
		executeOptions.aggregate = relationNode.aggregateExpression;
	
		return {
			executeOptions: executeOptions,
			relationNode: relationNode,
			dataItem: dataItem
		};
	};
	
	Processor.prototype._getExecuteDefinitionForNode = function (executionTree, executionNode, expandContext) {
		//get the relation node for the only relation of the execution node.
		var relationNode = executionTree.getRelationNode(executionNode.relations[0]);
	
		// if we have such options executionNode should have only one relation.
		var executeOptions = {};
		executeOptions.select = relationNode.fieldsExpression;
		executeOptions.sort = relationNode.sortExpression;
		executeOptions.skip = relationNode.skip;
		executeOptions.take = relationNode.take;
		executeOptions.targetTypeName = relationNode.targetTypeName;
		executeOptions.returnItemsCount = relationNode.returnItemsCount;
		executeOptions.aggregate = relationNode.aggregateExpression;
	
		return {
			executeOptions: executeOptions,
			relationNode: relationNode,
			executionNode: executionNode
		};
	};
	
	/**
	 * Gets filter expression from a single item for certain relation.
	 * along with user defined filters.
	 * @param dataItem - The dataItem to get filter for.
	 * @param relationNode - A RelationNode instance.
	 * @returns {*}
	 */
	Processor.prototype._getFilterFromSingleItem = function (dataItem, relationNode) {
		var userDefinedFilter = relationNode.filterExpression;
		var itemFilter;
			
		var relationFieldName = relationNode.relationField;
		
		if (relationNode.isInvertedRelation) {
			itemFilter = {};
			itemFilter[relationNode.relationField] = dataItem.Id;
		} else {
			var relationData = dataItem[relationFieldName];
			if (relationData) {
				if (Array.isArray(relationData)) {
					itemFilter = { "Id": { "$in": relationData } };
				} else {
					itemFilter = { "Id": relationData };
				}
			} else {
				//TODO
				//Here we must stop the query, as there are no related items
			}
		}
			
		if (itemFilter && userDefinedFilter) {
			return { '$and': [itemFilter, userDefinedFilter] };
		} else if (itemFilter) {
			return itemFilter;
		} else if (userDefinedFilter) {
			return userDefinedFilter;
		} else {
			return null;
		}
	};
	
	Processor.Constants = Constants;
	
	module.exports = Processor;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Constants = __webpack_require__(39);
	var _ = __webpack_require__(1);
	var ExpandError = __webpack_require__(94);
	
	function RelationNode(options) {
	    this.parentPath = options.parent;
	    this.relationField = options.relationField;
	    this.path = options.path || options.parent + '.' + options.relationField;
	    this.fieldsExpression = options.fieldsExpression || {};
	    this.targetTypeName = options.targetTypeName;
		//An array containing the paths(strings) of the child relations for this node
	    this.children = [];
	    this.isInvertedRelation = options.isInvertedRelation;
	    this.isArrayRoot = options.isArrayRoot; //used for validation of cases where various expand features are disabled for a GetAll scenario.
	    this.hasArrayValues = false;//set when we have executed the query. Used in validation scenarios where we do not have metadata about whether the relation is an array or not.
	
	    var expandExpression = options.expandExpression || {};
	
	    this.parentRelationField = expandExpression[Constants.ParentRelationFieldName] || Constants.IdFieldNameClient;
	    var relationField = this.isInvertedRelation ? this.path : this.relationField; //inverted relations appear with the full path - ContentType.Field - in the result when expanding.
	    this.userDefinedName = expandExpression[Constants.ReturnAsFieldName] || relationField;
	    _.extend(this.fieldsExpression, expandExpression[Constants.FieldsExpressionName]);
	    this.originalFieldsExpression = {};
	    _.extend(this.originalFieldsExpression, this.fieldsExpression);
	    this.singleFieldName = expandExpression[Constants.SingleFieldExpressionName];
	    this.filterExpression = expandExpression[Constants.FilterExpressionName];
	    this.sortExpression = expandExpression[Constants.SortExpressionName];
	    this.skip = expandExpression[Constants.SkipExpressionName];
	    this.take = this._getTakeLimit(expandExpression[Constants.TakeExpressionName], options.maxTakeValue);
		this.returnItemsCount = expandExpression[Constants.ReturnItemsCountFieldName];
		this.aggregateExpression = expandExpression[Constants.AggregateExpressionFieldName];
	}
	
	
	/**
	 * Gets the take limit depending on the application and the take value that the user has provided.
	 * @param clientTakeValue
	 * @param maxTakeValue
	 * @returns {number}
	 */
	RelationNode.prototype._getTakeLimit = function (clientTakeValue, maxTakeValue) {
	    maxTakeValue = maxTakeValue || Constants.DefaultTakeItemsCount;
	    if (clientTakeValue) {
	        if (clientTakeValue > maxTakeValue) {
	            throw new ExpandError('The maximum allowed take value when expanding relations is ' + maxTakeValue + '!');
	        }
	        return clientTakeValue;
	    } else {
	        return maxTakeValue;
	    }
	};
	
	/**
	 * Anyone using the bs-expand-processor module can set whether the relation is a multiple relation in the prepare phase.
	 * This will allow for certain restrictions to be enforced directly on the prepare phase instead of the execution phase.
	 */
	RelationNode.prototype.setIsArrayFromMetadata = function () {
	    this.isArrayFromMetadata = true;
	};
	
	RelationNode.prototype.isArray = function () {
	    // We can find out if a relation is an array in the following cases:
	    // From metadata in the API Server.
	    // All inverted relations are array.
	    // Once values have been received we can find out. This is used for scenarios where we do not have metadata about the relation (offline storage in SDK).
	    return this.isArrayFromMetadata || this.isInvertedRelation || this.hasArrayValues;
	};
	
	/**
	 * Creates a RelationNode object representing an external(inverted) relation.
	 * @param relationPath - A path to the external relation field (example: "Comments.ActivityId")
	 * @param expandExpression - The expand expression that contains all information about the relation
	 * @param parentRelationPath - Name of the parent relation.
	 * @returns {RelationNode}
	 */
	RelationNode.createInverted = function (relationPath, expandExpression, parentRelationPath, maxTakeValue) {
	    var relationNameParts = relationPath.split('.');
		var targetTypeName = relationNameParts[0];
		var relationField = relationNameParts[1];
		
		return RelationNode._create(relationPath, targetTypeName, relationField, parentRelationPath, maxTakeValue, expandExpression, true);
	};
	
	/**
	 * Creates a RelationNode object representing a regular relation.
	 * @param relationField - The field to expand (example: "Likes")
	 * @param expandExpression - The expand expression that contains all information about the relation
	 * @param parentRelationPath - Name of the parent relation.
	 * @returns {RelationNode}
	 */
	RelationNode.createRegular = function (relationField, expandExpression, parentRelationPath, maxTakeValue) {
	    var options = {};
		
		var relationPath = parentRelationPath + '.' + relationField;
		var targetTypeName = expandExpression[Constants.TargetTypeNameFieldName];
		
		return RelationNode._create(relationPath, targetTypeName, relationField, parentRelationPath, maxTakeValue, expandExpression, false);
	};
	
	RelationNode._create = function(relationPath, targetTypeName, releationField, parentRelationPath, maxTakeValue, expandExpression, isInvertedRelation) {
		var options = {};
		
		options.parent = parentRelationPath;
	    options.path = relationPath;
	    options.maxTakeValue = maxTakeValue;
	    options.validated = false;
		options.expandExpression = expandExpression;
		options.relationField = releationField;
		options.targetTypeName = targetTypeName;
	    options.isInvertedRelation = isInvertedRelation;
		
	    return new RelationNode(options);
	};
	
	module.exports = RelationNode;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var RelationNode = __webpack_require__(180);
	var _ = __webpack_require__(1);
	var Constants = __webpack_require__(39);
	var ExpandError = __webpack_require__(94);
	
	//var relationFieldPropertyName = Constants.RelationExpressionName;
	
	var possibleExpandOptions = [
	    Constants.ExpandExpressionName,
	    Constants.ReturnAsFieldName,
	    Constants.FieldsExpressionName,
	    Constants.SingleFieldExpressionName,
	    Constants.SortExpressionName,
	    Constants.FilterExpressionName,
	    Constants.SkipExpressionName,
	    Constants.TakeExpressionName,
	    Constants.ParentRelationFieldName,
	    Constants.TargetTypeNameFieldName,
		Constants.ReturnItemsCountFieldName,
		Constants.AggregateExpressionFieldName
	];
	
	
	/**
	 * A class used to parse Expand expression and build a corresponding relation tree.
	 * In a process of creating the relation tree are performed several checks in order to force some limitations -
	 * 50 items both for master and child queries and entire amount of all queries limited to 20.
	 * Checks if the relation field given by the customer is valid (for example: user gives "Like" while the relation field is "Likes").
	 * Checks for possible expand options.
	 * @constructor
	 */
	var RelationTreeBuilder = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, metadataProviderFunction, context) {
	    this.maxTakeValue = maxTakeValue;
	    this._metadataProviderFunction = metadataProviderFunction;
	    this.context = context;
	    this.expandExpression = this._processExpandExpression(expandExpression);
	    // mark the main query in order to avoid some duplication issues.
	    this.map = {};
	    this.map[mainTypeName] = new RelationNode({
	        targetTypeName: mainTypeName,
	        isArrayRoot: isArray,
	        fieldsExpression: fieldsExpression,
	        validated: true,
	        path: mainTypeName,
	        maxTakeValue: maxTakeValue
	    });
	    this.map[mainTypeName].originalFieldsExpression = {};
	    _.extend(this.map[mainTypeName].originalFieldsExpression, fieldsExpression);
	    this.map.$root = mainTypeName;
	};
	
	/**
	 * Creates fully qualified expand expression from shorthand usages:
	 * {"Likes": true} -> {"Likes": {"ReturnAs": "Likes"}}
	 * {"Likes": "LikesExpanded"} -> {"Likes": {"ReturnAs": "LikesExpanded"}}
	 * @param expandExpression
	 * @returns {*}
	 */
	RelationTreeBuilder.prototype._processExpandExpression = function (expandExpression) {
	    for (var property in expandExpression) {
	        if (expandExpression.hasOwnProperty(property)) {
	            if (typeof expandExpression[property] === 'boolean') {
	                expandExpression[property] = {};
	                expandExpression[property][Constants.ReturnAsFieldName] = property;
	            }
	            if (typeof expandExpression[property] === 'string') {
	                var relationField = expandExpression[property];
	                expandExpression[property] = {};
	                expandExpression[property][Constants.ReturnAsFieldName] = relationField;
	            }
	        }
	    }
	    return expandExpression;
	};
	
	/**
	 * Builds the relation tree.
	 * @param done
	 */
	RelationTreeBuilder.prototype.build = function (done) {
	    try {
	        this.buildMapInternal(this.expandExpression, this.map.$root);
	    } catch (e) {
	        return done(e);
	    }
	    var self = this;
	    __webpack_require__(95).series([
	        this.configureRelationTree.bind(this),
	        this.validateRelationTree.bind(this)
	    ], function (err) {
	        done(err, self.map);
	    });
	};
	
	/**
	 * An internal method which parses the expand expression and produces a basic relation tree (only names and parent relations).
	 * @param expandExpression - The expand expression which will be processed.
	 * @param rootName - The name of the root relation (master query) usually the name of the requested content type (Activities).
	 */
	RelationTreeBuilder.prototype.buildMapInternal = function (expandExpression, rootName) {
	    for (var relationName in expandExpression) {
	        if (expandExpression.hasOwnProperty(relationName)) {
	            var fieldExpression = expandExpression[relationName];
				
				//Check if all options in an expand field definition are recognized
	            for (var option in fieldExpression) {
	                if (fieldExpression.hasOwnProperty(option) && possibleExpandOptions.indexOf(option) === -1) {
	                    throw new ExpandError('\"' + option + '\"' + ' is not a valid option for Expand expression');
	                }
	            }
	
	            if (relationName.indexOf('.') > -1) { //If the relation is inverted
	                var invertedRelation = RelationNode.createInverted(relationName, fieldExpression, rootName, this.maxTakeValue);
					
	                this.map[invertedRelation.path] = invertedRelation;
	                this.map[rootName].children.push(invertedRelation.path);
					
	                // adds a field expression in the original fields expression in order to get the result for that field
	                RelationTreeBuilder.addFieldToFieldsExpression(this.map[invertedRelation.parentPath].originalFieldsExpression, invertedRelation.userDefinedName);
	
	                if (expandExpression[relationName][Constants.ExpandExpressionName]) {
	                    var processedExpandExpression = this._processExpandExpression(expandExpression[relationName][Constants.ExpandExpressionName]);
	                    this.buildMapInternal(processedExpandExpression, invertedRelation.path);
	                }
	            } else {
	                var relationNode = RelationNode.createRegular(relationName, fieldExpression, rootName, this.maxTakeValue);
					
	                this.map[relationNode.path] = relationNode;
	                this.map[rootName].children.push(relationNode.path);
	
	                if (fieldExpression.hasOwnProperty(Constants.ExpandExpressionName)) {
	                    if (typeof(fieldExpression[Constants.ExpandExpressionName]) === 'object') {
	                        this.buildMapInternal(this._processExpandExpression(fieldExpression.Expand), relationNode.path);
	                    } else {
	                        throw new ExpandError(relationNode.path + '.Expand must be a valid expand expression!');
	                    }
	                }
	            }
	        }
	    }
	};
	
	/**
	 * Adds additional metadata which is necessary to execute a query.
	 * Name of the content type of the child relation get via relation field.
	 * @param done
	 */
	RelationTreeBuilder.prototype.configureRelationTree = function (done) {
	    if (this._metadataProviderFunction) {
	        var relationNames = [];
	        var self = this;
	
	        for (var relationPath in this.map) {
	            if (this.map.hasOwnProperty(relationPath)) {
	                if (this.map[relationPath].parentPath !== null) {
	                    relationNames.push(this.map[relationPath].relationField);
	                }
	            }
	        }
	
	        this._metadataProviderFunction(relationNames, this.map, this.context, function (err, result) {
	            done(err);
	        });
	    } else {
	        return done();
	    }
	};
	
	/**
	 * Performs several checks like:
	 * Validity of the relation field.
	 * To not use filter or sorting expression within a "GetByFilter" scenario.
	 * Does not allow to nest (expand multiple relation field) after a multiple relation.
	 * Does not allow to use both "Fields" and "SingleField" options.
	 * @param done
	 * @returns {*}
	 */
	RelationTreeBuilder.prototype.validateRelationTree = function (done) {
	    var errorMessage = '';
	    var EOL = '\r\n';
	    for (var relationPath in this.map) {
	        if (relationPath !== '$root' && this.map.hasOwnProperty(relationPath)) {
	            var relation = this.map[relationPath];
	            errorMessage += RelationTreeBuilder.validateSingleRelation(relation, this);
	            this.configureFieldsExpressionsForRelation(relation);
	        }
	    }
	    if (errorMessage !== '') {
	        var finalErrorMessage = errorMessage.substr(0, errorMessage.lastIndexOf(EOL));
	        var error = new ExpandError(finalErrorMessage);
	        return done(error);
	    } else {
	        done();
	    }
	};
	
	/**
	 * Add relation fields to parent relation fields expression if needed (otherwise relation cannot be established).
	 * @param relation - A relation which will be configured.
	 */
	RelationTreeBuilder.prototype.configureFieldsExpressionsForRelation = function (relation) {
	    if (relation.parentPath) {
	        var parentRelationFieldsExpression = this.map[relation.parentPath].fieldsExpression;
	        if (relation.isInvertedRelation) {
	            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.parentRelationField);
	        } else {
	            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.relationField);
	        }
	    }
	    if (relation.isInvertedRelation) {
	        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, relation.relationField);
	    } else {
	        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, Constants.IdFieldNameClient);
	    }
	    RelationTreeBuilder.adjustParentRelationFieldsExpression(this.map[relation.parentPath], relation);
	};
	
	
	/**
	 * Validates a single relation for all build-in limitations.
	 * @param relationNode - A relation which will be validated.
	 * @param relationTree - The whole relation tree.
	 * @returns {string} - Returns an error message with all errors or empty string if there is no errors.
	 */
	RelationTreeBuilder.validateSingleRelation = function (relationNode, relationTree) {
	    var errorMessage = '';
		var relationTreeMap = relationTree.map;
		var rootRelationNode = relationTreeMap[relationTreeMap.$root];
	    var EOL = '\r\n';
	    var isGetByFilterQuery = rootRelationNode.isArrayRoot;
	
	    if (relationNode.path === relationNode.parentPath) {
	        errorMessage += relationNode.path + ' has same parent which will cause an infinite loop.' + EOL;
	        return errorMessage;
	    }
	
	    if (relationNode.isArray()) {
	        var multipleQueriesCount = RelationTreeBuilder._getParentMultipleRelationsCount(relationNode, relationTree);
	        if (multipleQueriesCount > 0) {
	            errorMessage += 'Expand expression has multiple relation \"' + relationNode.path + '\" inside a multiple relation.';
	            errorMessage += EOL;
	        }
	
	        if (relationTreeMap[relationNode.parentPath] === rootRelationNode &&
	            isGetByFilterQuery &&
	            (relationNode.filterExpression || relationNode.sortExpression)) {
	            errorMessage += 'Filter and Sort are not allowed when expanding multiple items.';
	            errorMessage += EOL;
	        }
			
			if (relationTreeMap[relationNode.parentPath] === rootRelationNode &&
	            isGetByFilterQuery && relationNode.isInvertedRelation &&
	            relationNode.skip) {
	            errorMessage += 'Skip and Take are not supported when expanding multiple items with external relation.';
	            errorMessage += EOL;
	        }
	
	        //if (isGetByFilterQuery && relationNode.isInvertedRelation) {
	        //    errorMessage += 'Expanding an external content type is not allowed with GetByFilter scenario.';
	        //    errorMessage += EOL;
	        //}
	    }
		
	    if (!relationNode.targetTypeName) {
	        errorMessage += 'Expanding relation \"' + relationNode.relationField + '\" has no target type name specified. You should use \"TargetTypeName\" to specify it.';
	        errorMessage += EOL;
	    }
		
	    if (relationNode.fieldsExpression && Object.keys(relationNode.fieldsExpression).length && relationNode.singleFieldName) {
	        errorMessage += relationNode.path + ' ';
	        errorMessage += 'expand expression contains both \"Fields\" and \"SingleField\" expressions.';
	        errorMessage += EOL;
	    }
		
	    if (relationNode.singleFieldName) {
	        if (relationNode.children) {
	            if (relationNode.children.length > 1) {
	                errorMessage += relationNode.path + ' has multiple expand expressions with a single field option.' + EOL;
	            }
	            if (relationNode.children.length === 1 && relationTreeMap[relationNode.children[0]].relationField !== relationNode.singleFieldName) {
	                errorMessage += 'Expand expression ' + relationNode.path;
	                errorMessage += ' single field \"' + relationNode.singleFieldName + '\"';
	                errorMessage += ' does not match child relation field \"' + relationTreeMap[relationNode.children[0]].relationField + '\".';
	                errorMessage += EOL;
	            }
	        }
	    }
	
	    return errorMessage;
	};
	
	/**
	 * Gets the count of parent multiple relations.
	 * @param relation - Starting relation.
	 * @returns {number} - count of all parent multiple relations
	 */
	RelationTreeBuilder._getParentMultipleRelationsCount = function (relationNode, relationTree) {
	    var result = 0;
	    var currentRelation = relationNode;
	    while (currentRelation.parentPath) {
	        var parentRelation = relationTree.map[currentRelation.parentPath];
	        if (parentRelation.isArray() && parentRelation.parentPath) {
	            result += 1;
	        }
	        currentRelation = parentRelation;
	    }
	    return result;
	};
	
	
	
	/**
	 * Adjusts fields expression of the parent relation based on paging setting of a relation (skip, take).
	 * In that case we put a "$slice" option within the parent relation fields expression.
	 * @param parentRelation
	 * @param relation
	 */
	RelationTreeBuilder.adjustParentRelationFieldsExpression = function (parentRelation, relation) {
	    if (!relation.isInvertedRelation && relation.take && typeof relation.take === 'number') {
	        // when relation has filter or sorting skip and take should not be transferred to the parent relation as $slice.
	        var shouldTransferPagingToParentRelation = relation.isArray() && !relation.filterExpression && !relation.sortExpression && parentRelation;
	        if (shouldTransferPagingToParentRelation) {
	            if (parentRelation.fieldsExpression === undefined) {
	                parentRelation.fieldsExpression = {};
	            }
	
	            if (relation.skip && typeof relation.skip === 'number') {
	                parentRelation.fieldsExpression[relation.relationField] = {
	                    '$slice': [relation.skip, relation.take]
	                };
	            } else {
	                parentRelation.fieldsExpression[relation.relationField] = {
	                    '$slice': relation.take
	                };
	            }
	            relation.take = null;
	            relation.skip = null;
	            relation.movedSkipTakeAsSlice = true;
	        }
	    }
	};
	
	/**
	 * Adds field to parent relation fields expression. For example if the relation field is excluded from the master request.
	 * @param fieldsExpression - Fields expression of the parent relation.
	 * @param relationField - Name of the field which should be returned.
	 */
	RelationTreeBuilder.addFieldToFieldsExpression = function (fieldsExpression, relationField) {
	    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
	        return;
	    }
	    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);
	
	    if (isExclusive === undefined) {
	        return;
	    }
	
	    if (isExclusive) {
	        delete fieldsExpression[relationField];
	    } else {
	        fieldsExpression[relationField] = 1;
	    }
	};
	
	/**
	 * Gets if the fields expression is exclusive ("FieldName" : 0)
	 * @param fieldsExpression - Fields expression to check.
	 * @returns {*}
	 */
	RelationTreeBuilder.getIsFieldsExpressionExclusive = function (fieldsExpression) {
	    var isExclusive;
	    for (var fieldName in fieldsExpression) {
	        if (fieldName !== Constants.IdFieldNameClient && fieldsExpression.hasOwnProperty(fieldName)) {
	            if (isExclusive === undefined) {
	                if (fieldsExpression[fieldName] === 0) {
	                    isExclusive = true;
	                    break;
	                } else {
	                    if (typeof fieldsExpression[fieldName] === 'object') {
	                        continue;
	                    } else {
	                        // fieldsExpression[fieldName] === 1
	                        isExclusive = false;
	                        break;
	                    }
	                }
	            }
	        }
	    }
	    return isExclusive;
	};
	
	module.exports = RelationTreeBuilder;


/***/ },
/* 182 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_182__ === 'undefined') {var e = new Error("Cannot find module \"application-settings\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_182__;

/***/ },
/* 183 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_183__ === 'undefined') {var e = new Error("Cannot find module \"file-system\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_183__;

/***/ },
/* 184 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_184__ === 'undefined') {var e = new Error("Cannot find module \"https\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_184__;

/***/ },
/* 185 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_185__ === 'undefined') {var e = new Error("Cannot find module \"local-settings\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_185__;

/***/ },
/* 186 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_186__ === 'undefined') {var e = new Error("Cannot find module \"nativescript-push-notifications\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_186__;

/***/ },
/* 187 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_187__ === 'undefined') {var e = new Error("Cannot find module \"node-localstorage\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_187__;

/***/ },
/* 188 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_188__ === 'undefined') {var e = new Error("Cannot find module \"platform\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_188__;

/***/ },
/* 189 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_189__ === 'undefined') {var e = new Error("Cannot find module \"url\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_189__;

/***/ },
/* 190 */
/***/ function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_190__ === 'undefined') {var e = new Error("Cannot find module \"zlib\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_190__;

/***/ },
/* 191 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 192 */
191
/******/ ])))
});
;
//# sourceMappingURL=everlive.map